-- MariaDB dump 10.19  Distrib 10.11.2-MariaDB, for debian-linux-gnu (x86_64)
--
-- Host: localhost    Database: algopat
-- ------------------------------------------------------
-- Server version	10.11.2-MariaDB-1:10.11.2+maria~ubu2204

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `gpt_problem_summary`
--

DROP TABLE IF EXISTS `gpt_problem_summary`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `gpt_problem_summary` (
  `gpt_problem_summary_seq` bigint(20) NOT NULL AUTO_INCREMENT,
  `problem_id` bigint(20) DEFAULT NULL,
  `gpt_problem_summary_description` text DEFAULT NULL,
  `gpt_problem_summary_input` text DEFAULT NULL,
  `gpt_problem_summary_output` text DEFAULT NULL,
  `gpt_problem_summary_constraints` text DEFAULT NULL,
  `gpt_time_complexity` text DEFAULT NULL,
  `gpt_time_complexity_reason` text DEFAULT NULL,
  `gpt_space_complexity` text DEFAULT NULL,
  `gpt_space_complexity_reason` text DEFAULT NULL,
  `problem_algorithm_type` text DEFAULT NULL,
  `problem_time_limit` text DEFAULT NULL,
  `problem_space_limit` text DEFAULT NULL,
  PRIMARY KEY (`gpt_problem_summary_seq`)
) ENGINE=InnoDB AUTO_INCREMENT=142 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `gpt_problem_summary`
--

LOCK TABLES `gpt_problem_summary` WRITE;
/*!40000 ALTER TABLE `gpt_problem_summary` DISABLE KEYS */;
INSERT INTO `gpt_problem_summary` VALUES
(106,1008,'Given two integers A and B, output the result of A/B. If the absolute or relative error between the actual answer and the output value is less than or equal to 10^-9, it is considered correct.','Two integers A and B are given. (0 < A, B < 10)\n','Print A/B on the first line. If the absolute or relative error between the actual answer and the output value is less than or equal to 10^-9, it is correct.','None','O(1)','The time complexity is constant because the operation being performed is a simple division operation, which takes constant time regardless of the input size.','O(1)','The space complexity is constant because the program only needs to store two integers, A and B, and the output value, which all have a fixed size regardless of the input size.','Mathematics, Implementation, Arithmetic Operations','2','128'),
(107,24727,'Given the size of a square engineering building and the required sizes of computer science and other department spaces, find the minimum number of chairs needed to accommodate all students. Chairs must be arranged in a straight line and each can accommodate only one student. If the given conditions cannot be met, output -1. Otherwise, output 1 followed by N lines representing the divided spaces, where 1 represents the computer science space, 2 represents the space for other departments, and 0 represents a barricade.','The input consists of two texts, each divided into 1000 tokens. The first text is provided to aid memory and is partially reflected in the existing summary. The second text contains the problem information that needs to be summarized.','Given two integers C (1 ≤ C ≤ N^2) and E (1 ≤ E ≤ N^2), representing the sizes of the required computer science space and the required space for other departments, respectively, the output should be the minimum number of chairs needed to accommodate all the students. Each chair can accommodate at most one student, and the chairs must be arranged in a straight line. If the given conditions cannot be met, output -1. Otherwise, output 1 on the first line, followed by N lines representing the divided spaces, where 1 represents the computer science space, 2 represents the space for other departments, and 0 represents a barricade.','The programming expert must convert the given problem information into the given form step by step. The names of the variables, their definitions, and their scope must be included in the summary. If the information given is not in English, it must be translated into English.','O(N^2)','The algorithm needs to iterate through the entire square building of size N^2 to determine the minimum number of chairs needed to accommodate all students. This requires O(N^2) time complexity.','O(N^2)','The algorithm needs to store the entire square building of size N^2 and the spaces for computer science and other departments. This requires O(N^2) space complexity.','Not specified','1','1024'),
(108,1012,'Given the width and height of a cabbage field and the coordinates of cabbage locations, find the minimum number of cabbage worms needed to cover all the cabbage locations. Cabbage worms can move to adjacent cabbage locations.','The input consists of the number of test cases T, followed by M (the width of the cabbage field), N (the height of the cabbage field), and K (the number of cabbage locations). Then, K lines follow with the X and Y coordinates of each cabbage location.','For each test case, output the minimum number of cabbage worms needed to cover all the cabbage locations.','None.','O(M*N), where M is the width of the cabbage field and N is the height of the cabbage field.','We need to traverse the entire cabbage field to find all the cabbage locations and then perform a traversal algorithm (such as BFS or DFS) to find the minimum number of cabbage worms needed to cover all the cabbage locations. The time complexity of traversing the cabbage field is O(M*N).','O(M*N), where M is the width of the cabbage field and N is the height of the cabbage field.','We need to store the cabbage field in memory to perform the traversal algorithm. The space complexity of storing the cabbage field is O(M*N).','Graph theory, graph traversal, breadth-first search, depth-first search.','1','512'),
(109,1000,'Given two integers A and B, output their sum.','Two integers A and B are given. (0 < A, B < 10)','Print the sum of A and B on the first line.','None','O(1)','The time complexity is constant because the program only needs to perform a single addition operation.','O(1)','The space complexity is constant because the program only needs to store two integers, A and B, and the result of their sum.','Mathematics Implementation Arithmetic','2 seconds','128 MB'),
(110,1001,'Given two integers A and B, output the result of A-B.','Two integers A and B are given. (0 < A, B < 10)','Output the result of A-B on the first line.','None','O(1)','The operation of subtracting two integers takes constant time regardless of the size of the input.','O(1)','The program only needs to store two integers, A and B, and the result of A-B, which takes constant space.','Mathematics Implementation Arithmetic','2 seconds','128 MB'),
(111,16935,'Given an N x M array, perform R operations on the array. The operations include flipping the array vertically, flipping the array horizontally, rotating the array 90 degrees clockwise, rotating the array 90 degrees counterclockwise, and shifting sub-arrays of the array in a specific pattern. The result of performing R operations on the array in the specified order must be returned.','The size of an array N, M and the number of operations R to be performed are given in the first line. The next N lines contain the elements Aij of the array A. The last line contains the operations to be performed, separated by spaces.','The result of performing R operations on the given array A in the order specified in the input.','N and M are even integers between 2 and 100, R is an integer between 1 and 1000, and the elements of Aij are integers between 1 and 10^8.','O(R*N*M)','The time complexity of each operation is O(N*M) since each element in the array must be visited at least once. Since there are R operations to be performed, the total time complexity is O(R*N*M).','O(N*M)','The space complexity is O(N*M) since the array must be stored in memory. No additional data structures are used in the algorithm.','Implementation','2 seconds','512 MB'),
(112,16139,'Given a string S consisting of lowercase letters with a length of up to 200,000 and an integer q representing the number of questions, the task is to find the number of occurrences of a given character αi in the substring of S defined by li and ri for each question. The substring is defined by two integers li and ri (0 ≤ li ≤ ri < |S|).','A string S consisting of lowercase letters with a length of up to 200,000 and an integer q representing the number of questions. Each question consists of two integers li and ri (0 ≤ li ≤ ri < |S|), representing a substring of S.','For each question, output the number of occurrences of a given character αi in the substring of S defined by li and ri.','The input string S consists of lowercase letters and has a length of up to 200,000. The number of questions q is given by an integer between 1 and 200,000. Each substring is defined by two integers li and ri (0 ≤ li ≤ ri < |S|). The output for each question is a single integer representing the number of occurrences of a given character αi in the substring of S defined by li and ri.','O(n+q), where n is the length of the string S.','We can use the cumulative sum algorithm to preprocess the string S and store the number of occurrences of each character up to each index. This preprocessing takes O(n) time. Then, for each question, we can calculate the number of occurrences of the given character αi in the substring of S defined by li and ri in constant time using the preprocessed cumulative sum array. Since we have q questions, the total time complexity is O(n+q).','O(n), where n is the length of the string S.','We need to store the preprocessed cumulative sum array, which requires O(n) space. The space complexity of the algorithm is dominated by this array.','Cumulative Sum','1','256'),
(113,14500,'Given a paper with size N x M and a set of natural numbers not exceeding 1,000 written on it, the task is to place a tetromino on the paper in such a way that the sum of the numbers written on the cells where the tetromino is placed is maximized. The tetromino must be placed on a single square and can be rotated or reflected. ','The vertical size N and horizontal size M of a paper are given in the first line. (4 ≤ N, M ≤ 500) From the second line, N lines of numbers written on the paper are given. The j-th number in the i-th line is the number written in the i-th cell from the top and the j-th cell from the left. The given numbers are natural numbers not exceeding 1,000.','Print the maximum sum of numbers written on the cells where the tetromino is placed.','None.','O(NM)','The algorithm needs to iterate through all possible positions of the tetromino on the paper, which requires two nested loops that run from 0 to N-1 and from 0 to M-1, respectively. Therefore, the time complexity is O(NM).','O(1)','The algorithm only needs to store a few variables to keep track of the maximum sum found so far and the current sum being calculated. Therefore, the space complexity is constant, or O(1).','Implementation Brute-force algorithm','2','512'),
(114,1003,'Given a function to calculate the Nth Fibonacci number, the program should output the number of times 0 and 1 are printed when the function is called with a given value of N.\n','The number of test cases T and N for each test case, where N is a natural number less than or equal to 40 or 0.\n','For each test case, output the number of times 0 and 1 are printed, separated by a space.\n','None.','O(2^n)','The function uses recursion to calculate the Fibonacci number, which results in a time complexity of O(2^n) as each call to the function results in two more calls until the base case is reached.','O(n)','The space complexity is O(n) as the maximum number of function calls on the stack at any given time is equal to the value of N.','Dynamic Programming','0.25 seconds (no additional time allowed)','128 MB '),
(115,1002,'Given the coordinates and distances of two turrets and their respective distances to an unknown point, determine the number of possible locations where the unknown point could be located. If the number of possible locations is infinite, output -1.\n','The input consists of the number of test cases T, followed by T lines each containing six integers x1, y1, r1, x2, y2, r2. x1, y1, x2, y2 are integers between -10,000 and 10,000 inclusive, and r1, r2 are non-negative integers less than or equal to 10,000.\n','For each test case, output the number of possible locations where Ryu can be located. If the number of possible locations is infinite, output -1.\n','None.','O(T), where T is the number of test cases.','The algorithm only needs to perform a constant number of operations for each test case, so the time complexity is linear in the number of test cases.','O(1).','The algorithm only needs to store a constant number of variables for each test case, so the space complexity is constant.','Mathematics Geometry, Conditional Statements','2','128'),
(116,1111,'Given a sequence of N integers, find the next number in the sequence based on a pattern. The pattern is always of the form \"previous number * a + b\", where a and b are integers. If there are multiple possible answers, output A. If it is impossible to determine the next number, output B.','The input consists of two lines. The first line contains a single integer N (N ≤ 50), and the second line contains N integers, each with an absolute value of no more than 100.','Output the next number in the sequence. If there are multiple possible answers, output A. If it is impossible to determine the next number, output B.','None.','O(N)','The algorithm needs to iterate through the entire sequence of N integers to find the pattern. This requires O(N) time complexity.','O(1)','The algorithm only needs to store the input sequence and the values of a and b, which are constant. Therefore, the space complexity is O(1).','Mathematics Implementation Brute-force Algorithm Many Conditional Branches.','2 seconds.','128 MB.'),
(117,17144,'Given a grid of size RxC, with an air purifier always located at the first column, the amount of fine dust in each cell is monitored in real-time. In one second, the fine dust diffuses to adjacent cells, except for those with the air purifier or no cell. The amount of fine dust diffused is A<sub>r,c</sub>/5, and the remaining amount is A<sub>r,c</sub> - (A<sub>r,c</sub>/5)×(number of directions diffused). Then, the air purifier operates, and the wind blows in a specific direction, moving all fine dust in that direction by one cell. The wind direction alternates between clockwise and counterclockwise for the top and bottom air purifiers, respectively. The task is to determine the amount of fine dust remaining in the room after T seconds.','The input consists of R, C, and T where R and C are integers between 6 and 50 inclusive, and T is an integer between 1 and 1000 inclusive. Following that, there are R lines of A<sub>r,c</sub> values where -1 ≤ A<sub>r,c</sub> ≤ 1000. The value -1 represents the location of the air purifier, and the other values represent the amount of fine dust. ','The output should be the amount of fine dust remaining in the room after T seconds.','There are no additional constraints for this problem.','O(RCT)','The algorithm needs to iterate over all cells in the grid R times (for each second) and perform calculations on each cell, which takes O(C) time. Therefore, the time complexity is O(RCT).','O(RC)','The algorithm only needs to store the grid of size RxC, which takes O(RC) space. No additional data structures are required.','implementation simulation','1','512'),
(118,17081,'The problem involves playing an RPG game on an N x M 2D grid. The grid contains empty spaces, walls, item boxes, spike traps, monsters, and a boss monster. The hero (@) must defeat monsters, collect items, and level up to defeat the boss monster (M). The hero can move in four directions (L, R, U, D) and has a set of actions to perform. The item boxes contain equipment (weapons, armor, accessories) that can be used to replace existing equipment or worn if there is space. The spike traps cause damage to the hero if stepped on. The monsters have names, attack power, defense power, health, and experience points. When the hero encounters a monster, they engage in a turn-based battle. The hero always attacks first, and each attack deals max(1, my attack power - enemy defense power) damage. The battle ends when one of the combatants\' health reaches 0 or below. The game ends when the hero defeats the boss monster. The program must output the final state of the grid, the number of turns passed, the hero\'s status, and the result of the game.','The size of a grid N and M are given in the first line. Next N lines contain M characters each representing the state of the grid. The characters are explained in the problem statement. There is exactly one boss monster represented by \'M\' and one hero represented by \'@\'. The next line contains a string S consisting of L, R, U, and D characters (1 ≤ |S| ≤ 5,000) which represents the hero\'s actions. The information of each of the K monsters is given in the next K lines. Each line contains R, C, S, W, A, H, and E (1 ≤ R ≤ N, 1 ≤ C ≤ M, 1 ≤ |S| ≤ 10, 1 ≤ W, A, H, E ≤ 20). The number of item boxes is L, and the information of each box is given in the next L lines. Each line contains R, C, T, and S. T can be \'W\', \'A\', or \'O\', and S is a string that represents the effect of the item box.\nThe grid, monster, and item box information is guaranteed to be valid.','Output the final state of the grid after the hero completes all actions. Also output the number of turns passed in the format \"Passed Turns: T\" where T is the number of turns. Output the hero\'s status in the format specified in the problem statement. Finally, output the result of the game in the format specified in the problem statement.','The grid size N and M are integers between 1 and 100, and N*M is at least 2. The string S representing the hero\'s actions has a length between 1 and 5,000. The information of each monster is given exactly once. The name of each monster is a string consisting of 1 to 10 alphabetic characters, and all monster names are distinct. The values of W, A, H, and E for each monster are integers between 1 and 20. The number of item boxes L is a positive integer. The values of R and C for each monster and item box are integers between 1 and N and between 1 and M. T for each item box is either \'W\', \'A\', or \'O\'. The string S for each item box is either \"HR\", \"RE\", \"CO\", \"EX\", \"DX\", \"HU\", or \"CU\". The total running time of the program must not exceed 5 seconds, and the program must not use more than 1024 MB of memory.','O(N*M*(K+L+S)) where N and M are the size of the grid, K is the number of monsters, L is the number of item boxes, and S is the length of the hero\'s actions string.','The program must iterate through the entire grid (N*M) to perform various actions such as moving the hero, opening item boxes, and checking for spike traps. It must also iterate through the list of monsters (K) to check for encounters and battles. The program must also iterate through the list of item boxes (L) to check for equipment and effects. Finally, the program must iterate through the hero\'s actions string (S) to perform the actions.','O(N*M + K + L)','The program must store the entire grid (N*M) and the information for each monster (K) and item box (L). This information includes the position, type, and effects of each monster and item box. The program does not need to store the hero\'s actions string as it can be processed on the fly.','implementation simulation','5','1024'),
(119,3649,'Given the width of a hole and a list of Lego piece lengths, the task is to find two Lego pieces whose lengths add up to the width of the hole. If such a pair exists, output their lengths with the largest difference. Otherwise, output \'danger\'. \n','The input consists of multiple test cases. Each test case starts with an integer x (1 ≤ x ≤ 20) representing the width of a hole in centimeters. The next line contains an integer n (0 ≤ n ≤ 1000000) representing the number of Lego pieces in a physics laboratory. The following n lines contain integers ℓ representing the length of each Lego piece in nanometers. The length of a block does not exceed 10 centimeters (100000000 nanometers).\n','For each test case, if there are no two Lego pieces that can perfectly cover the hole, output \'danger\'. Otherwise, output \'yes ℓ1 ℓ2\' where ℓ1 and ℓ2 are the lengths of the two Lego pieces that can cover the hole perfectly. If there are multiple solutions, output the one with the largest |ℓ1 - ℓ2|.\n','None.','O(nlogn)','The algorithm involves sorting the list of Lego piece lengths, which takes O(nlogn) time. Then, using two pointers, we can traverse the sorted list and find the pair of Lego pieces that add up to the hole width. This traversal takes O(n) time. Therefore, the overall time complexity is O(nlogn).','O(n)','We only need to store the list of Lego piece lengths, which takes O(n) space. The sorting algorithm used in the solution does not require additional space. Therefore, the overall space complexity is O(n).','Sorting, Binary Search, Two Pointers','5','256'),
(120,1806,'Given a sequence of N natural numbers less than or equal to 10,000, find the length of the shortest subsequence whose sum is greater than or equal to S. If such a subsequence does not exist, output 0.','Two integers N and S are given on the first line, where 10 ≤ N < 100,000 and 0 < S ≤ 100,000,000. The second line contains a sequence of N integers separated by spaces, where each integer is a natural number less than or equal to 10,000.','Output the minimum length of the subsequence that adds up to S. If such a sum is impossible, output 0.','None.','O(N)','We can use the two pointers algorithm to find the shortest subsequence. We start with two pointers, left and right, both pointing to the first element of the sequence. We then move the right pointer to the right until the sum of the subsequence between the left and right pointers is greater than or equal to S. We then move the left pointer to the right until the sum of the subsequence between the left and right pointers is less than S. We repeat this process until the right pointer reaches the end of the sequence. Since each element is visited at most twice, the time complexity is O(N).','O(1)','We only need to store the left and right pointers, and a variable to keep track of the minimum length of the subsequence found so far. Therefore, the space complexity is O(1).','Cumulative sum, Two pointers.','0.5 seconds.','128 MB.'),
(121,1157,'Given a word consisting of uppercase and lowercase letters, find the most frequently used alphabet in the word in uppercase. If there are multiple alphabets with the same frequency, print \"?\" while ignoring case sensitivity.','A word consisting of uppercase and lowercase letters is given. The length of the word is not more than 1,000,000.','Print the most frequently used alphabet in the word in uppercase. If there are multiple alphabets with the same frequency, print \"?\".','None','O(n)','We need to iterate through the entire word once to count the frequency of each alphabet. Therefore, the time complexity is directly proportional to the length of the word, which is n.','O(1)','We only need to store the frequency of each alphabet, which can be done using a constant amount of space. Therefore, the space complexity is constant, which is O(1).','Implementation String','2','128'),
(122,15652,'Given two natural numbers N and M, find all sequences of length M that satisfy the following conditions: \n1. The sequence consists of M numbers chosen from 1 to N.\n2. The same number can be chosen multiple times.\n3. The sequence is non-decreasing (i.e., each number is greater than or equal to the previous number).\nPrint each sequence on a separate line, in increasing order, and do not print duplicate sequences.\n','Two natural numbers N and M are given on the first line. (1 ≤ M ≤ N ≤ 8)\n','Print one sequence per line that satisfies the conditions of the problem. Duplicate sequences should not be printed multiple times, and each sequence should be separated by a space.\nThe sequences should be printed in increasing order.\n','None','O(N^M)','We need to generate all possible sequences of length M, each with N possible values. Therefore, the time complexity is O(N^M).','O(M)','We only need to store the current sequence of length M, so the space complexity is O(M).','Backtracking','1','512'),
(123,14502,'Given a rectangular map of size N x M, consisting of empty spaces, walls, and virus locations, the task is to find the maximum size of the safe area that can be obtained by building exactly 3 walls. The virus can spread to adjacent empty spaces.','The vertical size N and horizontal size M of a map are given on the first line. (3 ≤ N, M ≤ 8) From the second line, the shape of the map is given. 0 represents an empty space, 1 represents a wall, and 2 represents the location of a virus. The number of 2\'s is a natural number greater than or equal to 2 and less than or equal to 10. There are at least 3 empty spaces.','Print the maximum size of the safe area that can be obtained on the first line.','None specified.','O(N^2M^2)','The algorithm needs to iterate through all possible combinations of 3 walls that can be built in the map, which is O(NM choose 3) or O(N^2M^2). For each combination, a BFS algorithm needs to be run to find the size of the safe area, which takes O(NM) time. Therefore, the overall time complexity is O(N^2M^2).','O(NM)','The algorithm needs to store the map, which takes O(NM) space. Additionally, the BFS algorithm needs to store a queue of cells to be visited, which can take up to O(NM) space in the worst case if all cells are part of the safe area. Therefore, the overall space complexity is O(NM).','Implementation Graph Theory Brute Force Algorithm Graph Search Breadth First Search','2','512'),
(124,10950,'Write a program that takes two integers A and B as input and outputs their sum. The program should be able to handle multiple test cases, with each test case consisting of a single line containing two integers A and B. The number of test cases T is given on the first line. (0 < A, B < 10)\n','The number of test cases T is given on the first line. Each test case consists of a single line containing two integers A and B. (0 < A, B < 10)\n','For each test case, output the sum of A and B.\n','None.','O(T)','The program needs to iterate through T test cases, and for each test case, it performs a constant time operation of adding two integers. Therefore, the time complexity is linear in the number of test cases, which is O(T).','O(1)','The program only needs to store two integers at a time (A and B) and the sum of A and B. Therefore, the space complexity is constant, which is O(1).','Mathematics Implementation Arithmetic','1','256'),
(125,1520,'Given a rectangular map with M rows and N columns, where each cell represents a point with a certain height, find the number of possible paths from the top-left cell to the bottom-right cell, only moving to adjacent cells with lower height. The input consists of M, N, and the heights of each point on the map. The output is a single integer representing the number of possible paths.','The input consists of the size of a map, M and N, followed by M lines each containing N integers representing the height of each point on the map. M and N are natural numbers less than or equal to 500, and the height of each point is a natural number less than or equal to 10000.','The output is a single integer representing the number of possible paths that can be taken on the map. For all inputs, this integer is a non-negative integer less than or equal to 1 billion.','None.','O(M*N)','We need to traverse the entire map once to calculate the number of possible paths. Therefore, the time complexity is proportional to the number of cells in the map, which is M*N.','O(M*N)','We need to store the number of possible paths for each cell in the map. Therefore, the space complexity is proportional to the number of cells in the map, which is M*N.','Dynamic programming, graph theory, graph traversal, depth-first search.','2 seconds.','128 MB.'),
(126,17485,'Given a matrix of size N x M representing the space between Earth and the Moon, where each element is the amount of fuel needed to travel through that space, find the minimum amount of fuel needed to travel from any point on Earth to any point on the Moon using a spaceship that can only move in certain directions and cannot move in the same direction twice in a row. ','The size of a matrix representing the space between Earth and the Moon, N and M (2 ≤ N, M ≤ 1000), followed by N lines of elements in the matrix, where each element is a natural number less than or equal to 100.','The minimum amount of fuel needed for a trip to the Moon.','None.','O(NM)','We need to traverse the entire matrix of size N x M to find the minimum amount of fuel needed to travel from any point on Earth to any point on the Moon. Therefore, the time complexity is O(NM).','O(NM)','We need to store the entire matrix of size N x M to calculate the minimum amount of fuel needed to travel from any point on Earth to any point on the Moon. Therefore, the space complexity is O(NM).','Dynamic Programming','1','256'),
(127,10026,'Given an N x N grid of colored cells (R, G, B), determine the number of areas seen by a person without color blindness and the number of areas seen by a person with color blindness. Areas are defined as regions of cells with the same color, where adjacent cells (including diagonals) of the same color belong to the same area.','An integer N (1 ≤ N ≤ 100) representing the number of pictures followed by N lines of pictures.','The number of areas seen by a person without color blindness and the number of areas seen by a person with color blindness, separated by a space.','None.','O(N^2)','We need to traverse the entire grid of size N x N to identify the areas. This requires visiting each cell at most once, resulting in a time complexity of O(N^2).','O(N^2)','We need to store the entire grid of size N x N in memory to perform the traversal and identify the areas. This results in a space complexity of O(N^2).','Graph theory, graph traversal, breadth-first search, depth-first search.','1 second.','128 MB.'),
(128,14499,'Given a map of size N x M, a dice with initial coordinates (x, y) and a set of commands, the task is to simulate the movement of the dice and output the number on the top face of the dice after each move. The dice has six faces with numbers from 1 to 6, and initially, all faces have 0. If the dice moves to a cell with a number, the number on the bottom face of the dice is replaced with the number on the cell. If the cell has a 0, the number on the cell is copied to the bottom face of the dice. The dice cannot move outside the map.','The input includes the size of a map (N, M), the coordinates of the starting point of a dice (x, y), the number of commands (K), the numbers written on the map, and the commands for moving the dice.','The output should be the number written on the top face of the dice after each move.','N and M are integers between 1 and 20, x and y are integers between 0 and N-1 and 0 and M-1 respectively, K is an integer between 1 and 1000. The numbers written on the map are integers between 0 and 9.','O(K)','The algorithm needs to simulate K moves of the dice, and each move takes constant time to execute. Therefore, the time complexity is O(K).','O(1)','The algorithm only needs to store the current state of the dice, which has a constant number of variables. Therefore, the space complexity is O(1).','implementation simulation','2','512'),
(129,2110,'Given the coordinates of N houses on a number line, the task is to install C routers in such a way that the maximum distance between any two adjacent routers is maximized. Each house can have only one router. Find the maximum distance between the two closest routers.\n','The input includes the number of houses N (2 ≤ N ≤ 200,000) and the number of routers C (2 ≤ C ≤ N) separated by one or more spaces. From the second line onwards, N lines indicate the coordinates of the houses, x_i (0 ≤ x_i ≤ 1,000,000,000), one per line.\n','The output is the maximum distance between the two closest routers.\n','None.','O(N log N)','The algorithm involves sorting the coordinates of the houses, which takes O(N log N) time. Then, a binary search is performed on the sorted coordinates to find the maximum distance between the two closest routers. The binary search takes O(log N) time. Therefore, the overall time complexity is O(N log N).','O(N)','The algorithm requires an array to store the coordinates of the houses, which takes O(N) space. No additional space is required for the binary search or sorting. Therefore, the overall space complexity is O(N).','Binary Search, Parameter Search','2','128'),
(130,25314,'Given an integer N, which is a multiple of 4 and 4 ≤ N ≤ 1,000, the task is to print the name of the integer data type that can store up to N bytes according to Hyae\'s assumption.\n','An integer N is given, where N is a multiple of 4 and 4 ≤ N ≤ 1,000.\n','Print the name of the integer data type that can store up to N bytes according to Hyae\'s assumption.\n','None.','O(1)','The time complexity of the solution is constant because it only involves printing the name of the integer data type that can store up to N bytes. The size of N is limited to a small range, so the solution does not depend on the input size.\n','O(1)','The space complexity of the solution is constant because it only involves storing the name of the integer data type that can store up to N bytes, which is a fixed string of characters. The size of N is limited to a small range, so the solution does not depend on the input size.\n','Implementation','0.5 seconds','1024 MB \n'),
(131,17406,'Given an N x M array A, where the value of each row represents the sum of all the numbers in that row, find the minimum value of A after performing K rotation operations. Each rotation operation is defined by three integers (r, c, s) and rotates a square of elements in A clockwise by one position. The constraints are N and M between 3 and 50, K between 1 and 6, the values of A between 1 and 100, s at least 1, and the constraints for r, c, and s are given.\n','The size of array A (N, M), the number of rotation operations K, the values of array A, and the information of rotation operations (r, c, s).\n','The minimum value of array A.\n','N and M are between 3 and 50, K is between 1 and 6, the values of array A are between 1 and 100, s is at least 1, and the constraints for r, c, and s are given.\n','O(N^3 * K)','The brute force approach to solve this problem would be to perform all possible combinations of K rotation operations and calculate the minimum value of A for each combination. The number of possible combinations is K choose K, which is K!/(K-K)!*K! = K!. For each combination, we need to perform N^2 rotations, which takes O(N^2) time. Therefore, the time complexity is O(N^2 * K!). However, since K is at most 6, we can consider it as a constant and simplify the time complexity to O(N^2).\n','O(N*M)','We only need to store the original array A and the array after each rotation operation. Therefore, the space complexity is O(N*M).','Implementation Brute Force Backtracking','1','512'),
(132,21610,'The problem involves simulating the movement of clouds in a grid and performing operations on the cells of the grid based on the movement. The goal is to calculate the sum of water in the cells after a certain number of movements. The input includes the size of the grid, the initial water amounts in each cell, and the movement information. The movement information includes the direction and distance of each movement. The movements involve moving the clouds, increasing the water amount in cells under the clouds, performing a water replication magic on certain cells, and creating new clouds based on the water amount in certain cells.','The input includes N and M on the first line, followed by N lines of N integers representing A[r][c], and M lines of movement information d_i and s_i.','The output is the sum of the amount of water in the basket after M movements.','N is between 2 and 50, M is between 1 and 100, A[r][c] is between 0 and 100, d_i is between 1 and 8, and s_i is between 1 and 50.','O(NM)','The algorithm involves simulating M movements on a grid of size N x N. Each movement involves iterating through all the clouds and updating their positions, iterating through all the cells and updating their water amounts, performing a water replication magic on certain cells, and creating new clouds based on the water amount in certain cells. Therefore, the time complexity is O(NM).','O(N^2)','The algorithm involves storing the initial water amounts in each cell of the grid, as well as creating new grids to store the updated water amounts after each movement. Therefore, the space complexity is O(N^2).','Implementation Simulation','1 second','1024 MB'),
(133,1049,'Given the number of broken guitar strings N and the prices of M different brands of guitar strings, where each brand offers a package of 6 strings and individual strings can also be purchased, the task is to find the minimum amount of money required to buy at least N guitar strings.','The input includes two integers N and M, where N is a natural number less than or equal to 100, and M is a natural number less than or equal to 50. Following this, M lines are given, each containing the package price and the individual price of each brand separated by a space. Prices are integers between 0 and 1000.','The output is the minimum amount of money needed to buy at least N guitar strings.','None.','O(M log M)','The algorithm involves sorting the M brands based on their individual string prices, which takes O(M log M) time. Then, the algorithm iterates through the sorted brands and calculates the cost of buying N strings from each brand, choosing the minimum cost. This takes O(M) time. Therefore, the overall time complexity is O(M log M + M), which simplifies to O(M log M).','O(M)','The algorithm only requires storing the prices of the M brands, which takes O(M) space. Therefore, the space complexity is O(M).','Mathematics Greedy Algorithm','2','128'),
(134,1015,'Given an array A of size N and a sequence P containing integers from 0 to N-1, apply P to A to create a new array B where B[P[i]] = A[i]. Find a sequence P that results in a non-descending order of B. If multiple sequences exist, output the lexicographically smallest one.','An integer N representing the size of array A followed by N integers representing the elements of array A in order,','An array P in non-descending order,','None','O(NlogN)','The algorithm type is sorting, which typically has a time complexity of O(NlogN). We need to sort the sequence P to obtain the lexicographically smallest non-descending order of B. Sorting takes O(NlogN) time.','O(N)','We need to store the input array A and the output array B, both of size N. Therefore, the space complexity is O(N).','Sorting','2 seconds','128 MB.'),
(135,2557,'Given an HTML tag <p> with no content, output an HTML tag <p> containing the text \"Hello World!\".','The input consists of an HTML tag <p> with no content.','The output should be an HTML tag <p> containing the text \"Hello World!\".','There are no constraints specified for this problem.','O(1)','The time complexity is constant because the operation of outputting \"Hello World!\" is a simple and fixed operation that does not depend on the size of the input.','O(1)','The space complexity is constant because the output HTML tag <p> containing the text \"Hello World!\" is a fixed size and does not depend on the size of the input.','Implementation','1','128'),
(136,14503,'Given the size and state of a room, as well as the initial position and direction of a robot vacuum cleaner, the program should output the number of cleaned locations after the robot has finished cleaning the room. The room is represented by an N x M grid of squares, where each square is either a wall or an empty space that needs to be cleaned. The robot always starts in an empty space and can move in one of four directions: north, south, east, or west. The robot cleaner operates as follows: if the current location is dirty, it cleans it; then it moves to the adjacent location in the direction it is facing. If all adjacent locations are either walls or have already been cleaned, it moves back to the previous location and turns to face a new direction. The program should output the number of cleaned locations after the robot has finished cleaning the room.','The input consists of two texts, each divided into 1000 tokens. The first text provides information about the size of the room, including the number of rows and columns, and the second text contains information about the initial position and direction of the robot vacuum cleaner, including the row and column coordinates and the direction the robot is facing. Following this, there are N lines, each containing M values representing the state of each location in the room. Each value represents the state of a location in the room, where 0 indicates an empty location that needs to be cleaned and 1 indicates a location with a wall. The robot vacuum cleaner always starts in an empty location.','The program should output the number of cleaned locations after the robot has finished cleaning the room.','The programming expert must convert the given problem information into the given form step by step. The summary of inputs and outputs should include information about the names of the variables, their definitions, and their scope. If the information given is not in English, it must be translated into English.','O(NM)','The program needs to iterate through each location in the room, which is represented by N rows and M columns. The robot cleaner may visit each location at most once, so the time complexity is O(NM).','O(NM)','The program needs to store the state of each location in the room, which is represented by N rows and M columns. Therefore, the space complexity is O(NM). Additionally, the program needs to store the current location and direction of the robot cleaner, which requires constant space. The algorithm type for this problem is Implementation Simulation. The program should avoid inefficient algorithms and brute force.','Implementation Simulation','2','512'),
(137,14890,'Given a map of size N x N with the height of each cell, find the number of passable roads. A road is a row or column where all cells have the same height or a slope of length L can be placed to connect cells with a height difference of 1. Constraints include ensuring that the slope is placed on a continuous sequence of L cells with the same height, the slope does not overlap with another slope, and the slope does not go out of bounds.','The first line contains two integers N (2 ≤ N ≤ 100) and L (1 ≤ L ≤ N). The next N lines contain the map, where each cell\'s height is a natural number less than or equal to 10.','Print the number of passable roads on the first line.','None','O(N^2)','We need to iterate through each cell in the map to check if it is part of a passable road or if a slope can be placed on it. This requires a nested loop that iterates through each row and column, resulting in a time complexity of O(N^2).','O(N)','We only need to store the height of each cell in the map, resulting in a space complexity of O(N).','Implementation','2','512'),
(138,5052,'Given a list of phone numbers, the program determines whether the list is consistent or not. To maintain consistency, no phone number should be a prefix of another phone number. \n','The input includes the number of test cases (t), the number of phone numbers in each test case (n), and n lines of phone numbers with a maximum length of 10 digits. \n','For each test case, output \"YES\" if the list of phone numbers is consistent, and \"NO\" otherwise. \n','None. ','O(nlogn)','The program needs to sort the list of phone numbers in order to efficiently check for prefixes. Sorting takes O(nlogn) time complexity.','O(n)','The program needs to store the list of phone numbers, which takes O(n) space complexity.','Data Structures Strings Sorting Trees Tries ','1','256'),
(139,17070,'Given a grid representing a house with empty spaces and walls, and a pipe that can be moved in three directions and rotated, find the number of ways to move one end of the pipe from (1,1) to (N,N) without touching any walls. The pipe can only occupy empty spaces and can be moved in three directions: right, down-right diagonal, and down. The pipe can also be rotated 45 degrees in the direction of movement. \n','The size of a house N (3 ≤ N ≤ 16) is given on the first line. From the second line to the Nth line, the state of the house is given. An empty space is represented by 0 and a wall is represented by 1. (1, 1) and (1, 2) are always empty spaces.\n','Print the number of ways to move one end of the pipe to (N, N). If it is impossible to move, print 0. The number of ways is always less than or equal to 1,000,000.\n','None.','O(N^2)','We need to traverse the entire grid of size N x N to calculate the number of ways to move the pipe from (1,1) to (N,N). Therefore, the time complexity is O(N^2).','O(N^2)','We need to store the number of ways to reach each cell in the grid, which requires a 2D array of size N x N. Therefore, the space complexity is O(N^2).','Dynamic Programming Graph Theory Graph Traversal','1 second (no additional time)','512 MB '),
(140,3040,'Given nine distinct natural numbers between 1 and 99, find the seven numbers that add up to 100. These seven numbers represent the hats of seven dwarfs. Output the seven numbers, one per line.\n','The input consists of nine lines, each containing a natural number between 1 and 99, inclusive. All numbers are distinct, and only unique solutions are given as input.\n','Output the numbers written on the hats of the seven dwarfs, one per line.\n','None.','O(1)','Since there are only nine numbers to choose from, we can simply check all possible combinations of seven numbers and output the combination that adds up to 100. This process takes constant time since the input size is fixed.','O(1)','We only need to store the seven numbers that add up to 100, which is a fixed amount of data. Therefore, the space complexity is constant.','Brute force algorithm.','1 second.','128 MB. '),
(141,7569,'Given a tomato farm with tomatoes stored in a grid-shaped box, where each box can contain a ripe tomato, an unripe tomato, or an empty cell, the task is to find the minimum number of days required for all the tomatoes to ripen. If all the tomatoes are already ripe when stored, the output should be 0. If it is impossible for all the tomatoes to ripen, the output should be -1. Tomatoes ripen in one day and an unripe tomato becomes ripe if it is adjacent to a ripe tomato in the top, bottom, left, right, front, or back direction. The problem requires finding the shortest path from unripe tomatoes to ripe tomatoes using breadth-first search.','The input includes three integers: M, N, and H, representing the size of the box and the number of stacked boxes. M represents the number of horizontal cells in the box, N represents the number of vertical cells in the box, and H represents the number of boxes stacked. The second line onwards includes information about the tomatoes stored in the boxes, from the bottom box to the top box. Each line represents the state of the tomatoes in a box, with M integers representing the state of the tomatoes in each horizontal row. The integer 1 represents a ripe tomato, 0 represents an unripe tomato, and -1 represents an empty cell. ','The output should be the minimum number of days required for all the tomatoes to ripen. If all the tomatoes are already ripe when stored, the output should be 0. If it is impossible for all the tomatoes to ripen, the output should be -1.','M and N are between 2 and 100, and H is between 1 and 100. There is at least one tomato. ','O(M*N*H), where M, N, and H are the dimensions of the box.','The algorithm requires visiting each cell in the box once, and the worst-case scenario is that all cells are unripe tomatoes, so the algorithm must visit each cell in each box H times. Therefore, the time complexity is O(M*N*H).','O(M*N*H), where M, N, and H are the dimensions of the box.','The algorithm requires storing the state of each cell in the box, which requires M*N*H space. Therefore, the space complexity is O(M*N*H).','Graph theory, graph traversal, breadth-first search','1','256');
/*!40000 ALTER TABLE `gpt_problem_summary` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `gpt_solution`
--

DROP TABLE IF EXISTS `gpt_solution`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `gpt_solution` (
  `gpt_solution_seq` bigint(20) NOT NULL AUTO_INCREMENT,
  `submission_id` bigint(20) DEFAULT NULL,
  `user_seq` bigint(20) DEFAULT NULL,
  `gpt_solution_time_complexity` text DEFAULT NULL,
  `gpt_solution_time_complexity_reason` text DEFAULT NULL,
  `gpt_solution_time_score` bigint(20) DEFAULT NULL,
  `gpt_solution_time_complexity_good_point` text DEFAULT NULL,
  `gpt_solution_time_complexity_bad_point` text DEFAULT NULL,
  `gpt_improving_time_complexity_suggestion` text DEFAULT NULL,
  `gpt_solution_space_complexity` text DEFAULT NULL,
  `gpt_solution_space_complexity_reason` text DEFAULT NULL,
  `gpt_solution_space_score` bigint(20) DEFAULT NULL,
  `gpt_solution_space_complexity_good_point` text DEFAULT NULL,
  `gpt_solution_space_complexity_bad_point` text DEFAULT NULL,
  `gpt_improving_space_complexity_suggestion` text DEFAULT NULL,
  `gpt_solution_clean_score` bigint(20) DEFAULT NULL,
  `gpt_solution_refactoring_suggestion` text DEFAULT NULL,
  `gpt_total_score` bigint(20) DEFAULT NULL,
  PRIMARY KEY (`gpt_solution_seq`),
  KEY `idx_submission_id` (`submission_id`)
) ENGINE=InnoDB AUTO_INCREMENT=218 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `gpt_solution`
--

LOCK TABLES `gpt_solution` WRITE;
/*!40000 ALTER TABLE `gpt_solution` DISABLE KEYS */;
INSERT INTO `gpt_solution` VALUES
(169,7720108,1,'O(1)','수행되는 작업이 간단한 나눗셈 연산이기 때문에 입력 크기에 관계없이 일정한 시간이 소요되므로 시간 복잡도는 상수입니다.',100,'이 코드는 이미 시간 복잡도에 대해 최적화되어 있습니다.','없습니다.','없습니다.','O(1)','프로그램은 입력 크기와 관계없이 고정 크기를 가진 두 개의 정수 A와 B, 그리고 출력 값만 저장하면 되므로 공간 복잡도는 상수입니다.',100,'이 코드는 이미 공간 복잡도에 대해 최적화되어 있습니다.','없습니다.','없습니다.',80,'1. \"input1\"와 \"input2\" 대신에 \"분자\"와 \"분모\"와 같은 더 구체적인 변수 이름을 사용하세요.\n2. 불필요한 헤더 파일을 제거하세요. 이 경우, <stdio.h>는 필요하지 않습니다.\n3. 일관성을 위해 printf 대신 cout를 사용하세요.\n4. 출력 이후에 개행 문자를 추가하여 문제 설명과 일치시키세요.\n5. 코드의 목적과 복잡한 로직을 설명하는 주석을 추가하는 것을 고려하세요.\n6. 0으로 나누는 경우에 대한 오류 처리를 추가하는 것을 고려하세요.\n7. 입력 중 예외가 발생할 수 있는 경우 try-catch 블록을 사용하는 것을 고려하세요.\n8. 코드가 더 큰 프로그램의 일부인 경우 main() 대신 더 구체적인 함수 이름을 사용하는 것을 고려하세요.\n9. 입력과 출력이 정수임이 보장된다면 double 대신 int나 long long과 같은 더 구체적인 데이터 유형을 사용하는 것을 고려하세요.\n10. 분모가 0인 경우를 처리하기 위해 if 문 대신 삼항 연산자를 사용하는 것을 고려하세요.',93),
(170,52376911,7,'O(N^2)','코드에는 크기 N^2의 정사각형 건물 전체를 반복하는 중첩 루프가 있습니다. 또한, fill, wood 및 fill2 메서드는 건물을 탐색하기 위해 큐를 사용하므로 시간 복잡도가 증가합니다. 따라서 코드의 시간 복잡도는 O(N^2)입니다.',100,'이 코드는 큐와 같은 효율적인 데이터 구조를 사용하여 건물을 탐색하고 공간을 채우는 데 사용됩니다. 또한 fill, wood 및 fill2 메서드의 사용은 문제를 더 작은 하위 문제로 분해하여 코드를 모듈화하고 이해하기 쉽게 만드는 데 도움이 됩니다.','코드에는 전체 정사각형 건물을 반복하는 중첩 루프가 있으며, 큰 입력에 대해서는 시간이 많이 소요될 수 있습니다. 또한 체크 메서드는 빈 공간의 수를 세기 위해 전체 건물을 반복하므로 시간 복잡도가 증가합니다.','1. 건물 전체를 반복하여 빈 공간의 수를 계산하는 대신, 코드는 컴퓨터 과학 및 기타 학과의 공간을 채우면서 빈 공간의 수를 추적할 수 있습니다. 이렇게 하면 check 메소드의 시간 복잡도가 O(N^2)에서 O(1)로 줄어듭니다.\n2. 코드는 컴퓨터 과학 및 기타 학과의 공간을 채우기 위해 더 효율적인 알고리즘을 사용할 수 있습니다. 예를 들어, 그리디 알고리즘을 사용하여 필요한 의자 수를 최소화하는 방식으로 공간을 채울 수 있습니다. 이렇게 하면 fill 및 fill2 메소드의 시간 복잡도가 O(N^2)에서 O(NlogN) 또는 O(N)으로 줄어듭니다.\n3. 코드는 동적 프로그래밍을 사용하여 컴퓨터 과학 및 기타 학과의 공간 채우기를 최적화할 수 있습니다. 이렇게 하면 fill 및 fill2 메소드의 시간 복잡도가 O(N^2)에서 O(N)으로 줄어듭니다.\n4. 코드는 건물 순회 및 공간 채우기 속도를 높이기 위해 병렬 처리를 사용할 수 있습니다. 그러나 이는 채점 서버의 제약으로 인해 불가능합니다.','O(N^2)','코드는 N^2 크기의 정사각형 건물과 컴퓨터 과학 및 기타 부서의 공간을 2D 배열에 저장합니다. 따라서 코드의 공간 복잡도는 O(N^2)입니다.',100,'이 코드는 컴퓨터 과학 및 다른 학과의 공간을 저장하기 위해 2D 배열을 사용하며, 이는 간단하고 효율적인 데이터 구조입니다. 건물을 탐색하기 위해 큐를 사용하는 것은 메모리 사용을 최소화하는 데 도움이 됩니다.','이 코드는 크기가 N^2인 정사각형 건물 전체를 메모리에 저장하므로, 더 큰 입력에 대해서는 메모리 집약적일 수 있습니다. 또한 건물을 탐색하기 위해 큐를 사용하면 메모리 사용량이 더욱 증가합니다.','1. 코드는 희소 행렬 데이터 구조를 사용하여 컴퓨터 과학 및 다른 학과의 건물과 공간을 저장할 수 있습니다. 이렇게 하면 행렬에서 0이 아닌 요소의 수인 M에 따라 코드의 메모리 사용량이 O(N^2)에서 O(M)으로 줄어듭니다.\n2. 코드는 비트 조작을 사용하여 컴퓨터 과학 및 다른 학과의 건물과 공간을 저장할 수 있습니다. 이렇게 하면 비트 조작에 사용되는 데이터 유형의 크기에 따라 코드의 메모리 사용량이 O(N^2/32) 또는 O(N^2/64)로 줄어듭니다.\n3. 코드는 동적 프로그래밍을 사용하여 컴퓨터 과학 및 다른 학과의 공간 채우기를 최적화할 수 있습니다. 이렇게 하면 코드의 메모리 사용량이 O(N^2)에서 O(N)으로 줄어듭니다.\n4. 코드는 입력 및 출력 데이터를 메모리에 저장하는 대신 파일 입출력을 사용하여 읽고 쓸 수 있습니다. 그러나 문제의 제약 조건에 따라 이것이 실행 가능하지 않을 수 있습니다.',70,'1. 약어 대신 더 자세한 변수 이름을 사용하세요. 예를 들어, \"C\"와 \"E\" 대신 \"csSpace\"와 \"otherSpace\"를 사용하세요.\n2. 코드에 가치를 더하지 않는 불필요한 주석을 제거하세요.\n3. 코드에서 하드코딩된 9 값 대신 상수 변수를 사용하세요.\n4. \"wood\" 메소드에서 여러 if 문 대신 switch 문을 사용하세요.\n5. \"print\" 메소드의 중첩된 for 루프에 대해 별도의 메소드를 사용하여 가독성을 향상시키세요.\n6. \"sb\" 변수에 대해 \"outputStringBuilder\"와 같은 더 자세한 이름을 사용하세요.\n7. \"fill\" 메소드에 대해 \"fillWithSpaces\"와 같은 더 자세한 이름을 사용하세요.\n8. \"fill2\" 메소드에 대해 \"fillRemainingSpaces\"와 같은 더 자세한 이름을 사용하세요.\n9. \"check\" 메소드에 대해 \"hasEnoughSpace\"와 같은 더 자세한 이름을 사용하세요.\n10. \"wood\" 메소드에 대해 \"markAdjacentSpaces\"와 같은 더 자세한 이름을 사용하세요.\n11. \"dr\"과 \"dc\" 배열에 대해 \"rowOffsets\"와 \"columnOffsets\"와 같은 더 자세한 이름을 사용하세요.\n12. \"fill2\" 메소드에서 큐에 대해 더 효율적인 데이터 구조인 ArrayDeque를 사용하세요.\n13. 코드에서 하드코딩된 -1 값 대신 상수 변수를 사용하세요.\n14. main 메소드의 if-else 블록에 대해 별도의 메소드를 사용하여 가독성을 향상시키세요.\n15. \"map\" 변수에 대해 \"spaceMap\"과 같은 더 자세한 이름을 사용하세요.\n16. \"cnt\" 변수에 대해 \"spaceCount\"와 같은 더 자세한 이름을 사용하세요.\n17. \"cur\" 변수에 대해 \"currentSpace\"와 같은 더 자세한 이름을 사용하세요.\n18. \"nr\"과 \"nc\" 변수에 대해 \"nextRow\"와 \"nextColumn\"과 같은 더 자세한 이름을 사용하세요.\n19. \"N\" 변수에 대해 \"spaceSize\"와 같은 더 자세한 이름을 사용하세요.\n20. \"row\"와 \"col\" 변수에 대해 더 자세한 이름을 사용하거나 사용하지 않는 경우 제거하세요.',90),
(171,60894714,7,'O(N^2)','코드에는 크기 N^2의 정사각형 건물 전체를 반복하는 중첩 루프가 있습니다. 또한 fill, wood 및 fill2 메서드는 건물을 탐색하기 위해 큐를 사용하므로 시간 복잡도가 증가합니다. 따라서 코드의 시간 복잡도는 O(N^2)입니다.',100,'이 코드는 큐와 같은 효율적인 데이터 구조를 사용하여 건물을 탐색하고 공간을 채우는 데 사용됩니다. 또한 fill, wood 및 fill2 메서드의 사용은 문제를 더 작은 하위 문제로 분해하여 코드를 모듈화하고 이해하기 쉽게 만드는 데 도움이 됩니다.','코드에는 전체 정사각형 건물을 반복하는 중첩 루프가 있으며, 큰 입력에 대해서는 시간이 많이 소요될 수 있습니다. 또한 체크 메서드는 빈 공간의 수를 세기 위해 전체 건물을 반복하므로 시간 복잡도가 증가합니다.','1. 건물 전체를 반복하여 빈 공간의 수를 계산하는 대신, 코드는 컴퓨터 과학 및 기타 학과의 공간을 채우면서 빈 공간의 수를 추적할 수 있습니다. 이렇게 하면 check 메소드의 시간 복잡도를 O(N^2)에서 O(1)로 줄일 수 있습니다.\n2. 코드는 컴퓨터 과학 및 기타 학과의 공간을 채우기 위해 더 효율적인 알고리즘을 사용할 수 있습니다. 예를 들어, 의자 수를 최소화하는 방식으로 공간을 채우기 위해 탐욕 알고리즘을 사용할 수 있습니다. 이렇게 하면 fill 및 fill2 메소드의 시간 복잡도를 줄일 수 있습니다.\n3. 코드는 동적 프로그래밍을 사용하여 컴퓨터 과학 및 기타 학과의 공간을 채우는 것을 최적화할 수 있습니다. 이렇게 하면 fill 및 fill2 메소드의 시간 복잡도를 O(N^2)에서 O(N)으로 줄일 수 있습니다.\n4. 코드는 모든 학생을 수용하기 위해 필요한 최소 의자 수를 찾기 위해 이진 검색을 사용할 수 있습니다. 이렇게 하면 코드의 시간 복잡도를 O(N^2)에서 O(N log N)으로 줄일 수 있습니다.\n5. 코드는 메모이제이션을 사용하여 동일한 하위 문제를 여러 번 다시 계산하지 않도록 할 수 있습니다. 이렇게 하면 중복 계산을 제거하여 코드의 시간 복잡도를 줄일 수 있습니다.','O(N^2)','코드는 컴퓨터 과학 및 다른 학과의 공간을 포함한 크기 N^2의 전체 정사각형 건물을 저장해야 합니다. 또한, 건물을 탐색하기 위해 큐를 사용하는 것은 공간 복잡도를 더욱 증가시킵니다. 따라서, 코드의 공간 복잡도는 O(N^2)입니다.',100,'이 코드는 건물을 나타내기 위해 2D 배열을 사용하며, 건물을 저장하는 효율적인 방법입니다. 또한 건물을 탐색하기 위해 큐를 사용함으로써 메모리 사용량을 최소화할 수 있습니다.','코드는 컴퓨터 과학 및 다른 학과를 위한 공간과 함께 전체 정사각형 건물을 저장해야 하므로 대형 입력에 대해 메모리 집약적일 수 있습니다. 또한 건물을 탐색하기 위해 큐를 사용하면 메모리 사용량이 더욱 증가합니다.','1. 코드는 희소 행렬을 사용하여 정사각형 건물을 나타낼 수 있으며, 많은 빈 공간이 있는 건물의 메모리 사용량을 줄일 수 있습니다.\n2. 코드는 비트 조작을 사용하여 정사각형 건물을 나타낼 수 있으며, 많은 빈 공간이 있는 건물의 메모리 사용량을 더욱 줄일 수 있습니다.\n3. 코드는 깊이 우선 탐색 또는 너비 우선 탐색과 같은 더 효율적인 데이터 구조를 사용하여 건물을 탐색할 수 있습니다. 이를 통해 큐가 필요하지 않아 코드의 메모리 사용량을 줄일 수 있습니다.',70,'1. 약어 대신 더 구체적인 변수 이름을 사용하세요. 예를 들어, \"C\"와 \"E\" 대신 \"csSpace\"와 \"otherSpace\"를 사용하세요.\n2. 코드에 가치를 추가하지 않는 불필요한 주석을 제거하세요.\n3. 코드에서 하드코딩된 9 값 대신 상수 변수를 사용하세요.\n4. \"wood\" 메소드에서 여러 if 문 대신 switch 문을 사용하세요.\n5. \"print\" 메소드의 중첩된 for 루프에 대해 별도의 메소드를 사용하여 가독성을 향상시키세요.\n6. \"sb\" 변수에 대해 \"outputStringBuilder\"와 같은 더 구체적인 이름을 사용하세요.\n7. \"fill\" 메소드에 대해 \"fillWithSpaces\"와 같은 더 구체적인 이름을 사용하세요.\n8. \"fill2\" 메소드에 대해 \"fillRemainingSpaces\"와 같은 더 구체적인 이름을 사용하세요.\n9. \"check\" 메소드에 대해 \"hasEnoughSpace\"와 같은 더 구체적인 이름을 사용하세요.\n10. \"dr\" 및 \"dc\" 배열에 대해 \"rowDirections\" 및 \"columnDirections\"와 같은 더 구체적인 이름을 사용하세요.\n11. 큐에 대해 LinkedList 대신 ArrayDeque와 같은 더 효율적인 데이터 구조를 사용하세요.\n12. \"wood\" 메소드의 중첩된 for 루프에 대해 별도의 메소드를 사용하여 가독성을 향상시키세요.\n13. \"main\" 메소드의 중첩된 if 문에 대해 별도의 메소드를 사용하여 가독성을 향상시키세요.\n14. \"N\" 변수에 대해 \"gridSize\"와 같은 더 구체적인 이름을 사용하세요.\n15. \"map\" 변수에 대해 \"grid\"와 같은 더 구체적인 이름을 사용하세요.\n16. \"cnt\" 변수에 대해 \"spaceCount\"와 같은 더 구체적인 이름을 사용하세요.\n17. \"cur\" 변수에 대해 \"currentPosition\"과 같은 더 구체적인 이름을 사용하세요.\n18. \"nr\" 및 \"nc\" 변수에 대해 \"nextRow\" 및 \"nextColumn\"과 같은 더 구체적인 이름을 사용하세요.\n19. 중첩된 for 루프에서 \"i\" 및 \"j\" 변수에 대해 \"row\" 및 \"column\"과 같은 더 구체적인 이름을 사용하세요.\n20. \"fill\" 및 \"fill2\" 메소드의 \"type\" 매개변수에 대해 \"spaceType\"과 같은 더 구체적인 이름을 사용하세요.',90),
(172,60895315,6,'O(1)','프로그램은 단일 덧셈 연산만 수행하면 되므로 시간 복잡도는 상수입니다. 입력 크기에 관계없이 일정한 시간이 소요됩니다.',100,'이 코드는 이미 시간 복잡도에 대해 최적화되어 있습니다.','없습니다.','없습니다.','O(1)','프로그램은 A와 B 두 정수와 그들의 합의 결과만 저장하면 되므로 입력 크기에 관계없이 일정한 공간을 차지하므로 공간 복잡도는 상수입니다.',100,'이 코드는 이미 공간 복잡도에 대해 최적화되어 있습니다.','없습니다.','없습니다.',90,'1. \'num1\'와 \'num2\' 대신 의미 있는 변수 이름을 사용하세요. 예를 들어 \'first_number\'와 \'second_number\'를 사용하세요.\n2. \'using namespace std;\' 줄을 제거하고 대신 표준 라이브러리 함수에 대해 std:: 접두사를 사용하세요.\n3. 이 경우에는 불필요하므로 \'return 0;\' 줄을 제거하세요.\n4. 잘못된 입력 값에 대한 오류 처리를 추가하는 것을 고려하세요.\n5. \'A와 B의 합은 X입니다\'와 같이 더 구체적인 출력 메시지를 사용하는 것을 고려하세요. 여기서 X는 A와 B의 합입니다.\n6. \'main\' 대신 \'calculate_sum\'과 같이 더 구체적인 함수 이름을 사용하는 것을 고려하세요.\n7. 코드의 목적과 복잡한 로직을 설명하는 주석을 추가하는 것을 고려하세요.',96),
(173,60555780,1,'O(M*N)','코드는 모든 양배추 위치를 찾기 위해 전체 양배추 밭을 반복하고, 그런 다음 순회 알고리즘 (BFS)을 수행하여 모든 양배추 위치를 커버하기 위해 필요한 최소한의 양배추 애벌레 수를 찾습니다. 양배추 밭을 순회하는 시간 복잡도는 O(M*N)이며, BFS의 시간 복잡도는 최악의 경우에도 O(M*N)입니다.',100,'이 코드는 모든 양배추 위치를 커버하기 위해 필요한 최소한의 양배추 애벌레 수를 찾기 위해 효율적인 알고리즘 (BFS)을 사용합니다.','없습니다.','이 코드의 시간 복잡도는 이미 최적화되어 있습니다. 더 이상 개선할 수 없습니다.','O(M*N)','코드는 순회 알고리즘을 수행하기 위해 양배추 밭을 메모리에 저장합니다. 양배추 밭을 저장하는 공간 복잡도는 O(M*N)입니다.',100,'이 코드는 양배추 밭을 저장하기 위해 최적의 메모리 양을 사용합니다.','없습니다.','코드의 공간 복잡도는 이미 최적화되어 있습니다. 더 이상 개선할 수 없습니다.',80,'1. 단일 문자 변수 대신 더 구체적인 변수 이름을 사용하십시오. 예를 들어, \"m\" 대신 \"width\"를 사용하고 \"n\" 대신 \"height\"를 사용하십시오.\n2. 불필요한 \"result\" 변수를 제거하고 \"bfs\" 메소드에서 결과를 직접 반환하십시오.\n3. 상수를 사용하여 메소드에서 하드코딩된 \"dir\" 배열을 대체하십시오.\n4. BufferedReader를 수동으로 닫는 대신 try-with-resources 문을 사용하여 자동으로 닫으십시오.\n5. 콘솔에 직접 출력하는 대신 StringBuilder를 사용하여 출력을 연결하십시오.\n6. 음수 또는 보드 범위를 벗어난 값과 같은 잘못된 입력 값에 대한 오류 처리를 추가하십시오.\n7. 메모리 사용량을 줄이기 위해 2D 배열 대신 HashSet을 사용하여 양배추 위치를 저장하는 것을 고려하십시오.\n8. 메모리 사용량을 줄이기 위해 2D 배열 대신 BitSet을 사용하여 방문한 위치를 저장하는 것을 고려하십시오.\n9. \"q\" 변수에 대해 더 구체적인 이름을 사용하십시오. 예를 들어 \"queue\"와 같은 이름을 사용하십시오.\n10. 큐의 int[] 배열을 위한 새로운 클래스를 만드는 대신 람다 표현식을 사용하는 것을 고려하십시오.',93),
(174,60896293,1,'O(M*N)','코드는 모든 양배추 위치를 찾기 위해 전체 양배추 밭을 반복하고, 그 후 순회 알고리즘 (BFS)을 수행하여 모든 양배추 위치를 커버하기 위해 필요한 최소한의 양배추 애벌레 수를 찾습니다. 양배추 밭을 순회하는 시간 복잡도는 O(M*N)이며, BFS의 시간 복잡도는 최악의 경우에도 O(M*N)입니다.',100,'이 코드는 모든 양배추 위치를 덮기 위해 필요한 최소한의 애벌레 수를 찾기 위해 효율적인 BFS 알고리즘을 사용합니다.','없습니다.','이 코드의 시간 복잡도는 이미 최적화되어 있습니다. 더 이상 개선할 수 없습니다.','O(M*N)','코드는 BFS 알고리즘을 수행하기 위해 양배추 밭을 메모리에 저장합니다. 양배추 밭을 저장하는 공간 복잡도는 O(M*N)입니다.',100,'이 코드는 양배추 밭을 저장하기 위해 최적의 메모리 양을 사용합니다.','없습니다.','코드의 공간 복잡도는 이미 최적화되어 있습니다. 더 이상 개선할 수 없습니다.',80,'1. 단일 문자 변수 대신 더 구체적인 변수 이름을 사용하십시오. 예를 들어, \"m\" 대신 \"width\"를 사용하고 \"n\" 대신 \"height\"를 사용하십시오.\n2. 불필요한 \"result\" 변수를 제거하고 \"bfs\" 메소드에서 결과를 직접 반환하십시오.\n3. 상수를 사용하여 메소드에서 하드코딩된 \"dir\" 배열을 대체하십시오.\n4. BufferedReader를 수동으로 닫는 대신 try-with-resources 문을 사용하여 자동으로 닫으십시오.\n5. 콘솔에 직접 출력하는 대신 StringBuilder를 사용하여 출력을 연결하십시오.\n6. 음수 또는 보드 범위를 벗어난 값과 같은 잘못된 입력 값에 대한 오류 처리를 추가하십시오.\n7. 메모리 사용량을 줄이기 위해 2D 배열 대신 HashSet을 사용하여 양배추 위치를 저장하는 것을 고려하십시오.\n8. 메모리 사용량을 줄이기 위해 2D 배열 대신 BitSet을 사용하여 방문한 위치를 저장하는 것을 고려하십시오.\n9. BFS 대신 Union-Find와 같은 더 효율적인 알고리즘을 사용하여 문제를 해결하는 것을 고려하십시오.\n10. 코드 전체에서 일관된 들여쓰기를 사용하여 가독성을 향상시키십시오.',93),
(175,60896584,7,'O(1)','프로그램은 단일 덧셈 연산만 수행하면 되기 때문에 시간 복잡도는 상수입니다. 입력 크기는 프로그램이 수행하는 연산의 수에 영향을 미치지 않습니다.',100,'이 코드는 이 문제에 대해 가능한 최상의 시간 복잡도를 가지고 있습니다. 간단하고 직관적입니다.','시간 복잡도와 관련된 나쁜 점은 없습니다.','이 코드의 시간 복잡도는 이미 최적화되어 있습니다. 더 이상 개선할 수 없습니다.','O(1)','프로그램은 A와 B 두 정수와 그들의 합의 결과만 저장하면 되기 때문에 공간 복잡도는 상수입니다. 입력 크기는 프로그램이 사용하는 메모리 양에 영향을 미치지 않습니다.',100,'이 코드는 이 문제에 대해 가능한 최상의 공간 복잡도를 가지고 있습니다. 간단하고 직관적입니다.','공간 복잡도와 관련된 나쁜 점은 없습니다.','코드의 공간 복잡도는 이미 최적화되어 있습니다. 더 이상 개선할 수 없습니다.',90,'1. sumValueA와 sumValueB 대신에 num1과 num2와 같은 더 구체적인 변수 이름을 사용하세요.\n2. 코드에서 사용되지 않으므로 problem_constraints를 제거하세요.\n3. 사용자로부터 입력을 읽을 때 예외를 처리하기 위해 try-catch 블록을 사용하는 것을 고려하세요.\n4. 두 개의 별도 줄 대신 변수를 선언하고 초기화하는 데 하나의 줄을 사용하세요.\n5. Main 대신 더 구체적인 클래스 이름을 사용하는 것을 고려하세요.\n6. main 대신 더 구체적인 메소드 이름을 사용하세요.\n7. sc 대신 더 구체적인 변수 이름을 사용하는 것을 고려하세요.\n8. println 대신 더 구체적인 메소드 이름을 사용하는 것을 고려하세요.\n9. sum 대신 더 구체적인 변수 이름을 사용하는 것을 고려하세요.\n10. 코드의 목적과 복잡한 로직을 설명하는 주석을 추가하는 것을 고려하세요.',96),
(176,60898163,6,'O(1)','이 코드는 두 정수를 빼는 단일 작업만 수행하며, 입력 크기에 관계없이 상수 시간이 소요됩니다. 시간 복잡도는 입력 크기에 영향을 받지 않습니다.',100,'이 코드는 O(1)의 최적 시간 복잡도를 가지고 있습니다.','시간 복잡도와 관련된 나쁜 점은 없습니다.','사용자의 코드는 이미 최적화되어 있으며 시간 복잡도 측면에서 더 개선될 수 없습니다.','O(1)','프로그램은 A와 B 두 정수와 A-B의 결과만 저장하면 되며, 이는 상수 공간을 차지합니다. 입력 크기에 따라 공간 복잡도가 영향을 받지 않습니다.',100,'이 코드는 O(1)의 최적 공간 복잡도를 가지고 있습니다.','공간 복잡도와 관련된 나쁜 점은 없습니다.','사용자의 코드는 이미 최적화되어 있으며 공간 복잡도 측면에서 더 개선될 수 없습니다.',90,'1. 코드를 더 읽기 쉽게 하기 위해 num1과 num2 대신 의미 있는 변수 이름을 사용하세요. 예를 들어, minuend와 subtrahend를 사용하세요.\n2. cout 문 이후 불필요한 endl을 제거하세요. 프로그램이 즉시 0을 반환하기 때문에 필요하지 않습니다.\n3. 입력 값이 지정된 범위(0 < A, B < 10)를 벗어나는 경우에 대한 오류 처리를 추가하는 것을 고려해보세요.\n4. 이 코드가 더 큰 프로그램의 일부인 경우, main() 대신 더 구체적인 함수 이름을 사용하는 것을 고려해보세요.\n5. 코드를 더 유지보수하기 쉽게 하기 위해 입력 범위(0 < A, B < 10)에 대한 const 변수를 사용하는 것을 고려해보세요.',96),
(177,47489089,2,'O(R*N*M)','각 작업의 시간 복잡도는 배열의 각 요소를 적어도 한 번 방문해야 하므로 O(N*M)입니다. 수행해야 할 작업이 R개이므로 총 시간 복잡도는 O(R*N*M)입니다.',98,'이 코드는 이미 최적화되어 있으며 불필요한 루프나 연산이 없습니다.','없습니다.','1. 배열을 회전시키는 더 효율적인 알고리즘을 사용하세요. 예를 들어, 시간 복잡도가 O(N^2)인 인플레이스 회전 알고리즘을 사용할 수 있습니다.\n2. 하위 배열을 이동시키는 더 효율적인 알고리즘을 사용하세요. 예를 들어, 시간 복잡도가 O(N)인 슬라이딩 윈도 기술을 사용할 수 있습니다.\n3. 배열을 저장하는 더 효율적인 데이터 구조를 사용하세요. 예를 들어, 압축 희소 행렬(CSR)은 공간 복잡도를 O(N+M)으로 줄일 수 있습니다.\n4. 병렬 처리를 사용하여 작업을 동시에 수행하세요. 이렇게 하면 전체 시간 복잡도를 줄일 수 있습니다.','O(N*M)','배열은 메모리에 저장되어야 하므로 공간 복잡도는 O(N*M)입니다. 알고리즘에서는 추가적인 데이터 구조를 사용하지 않습니다.',100,'이 코드는 배열을 저장하는 데 필요한 최소한의 메모리를 사용합니다.','없습니다.','코드의 공간 복잡도는 이미 최적화되어 더 개선될 수 없습니다.',70,'1. 약어 대신 더 자세한 변수 이름을 사용하세요. 예를 들어, \"N\" 대신 \"rows\"를 사용하고, \"M\" 대신 \"cols\"를 사용하세요.\n2. 필요하지 않은 경우에는 정적 변수 사용을 피하고, 대신 변수를 매개변수로 전달하세요.\n3. \"up\"과 \"left\" 메소드를 하나의 \"rotate\" 메소드로 결합하고, 회전 방향을 나타내는 매개변수를 사용하세요.\n4. 가독성을 높이기 위해, 메인 메소드에서 여러 if 문 대신 switch 문을 사용하세요.\n5. \"mod\" 변수에 미리 크기를 지정하지 않기 위해, 배열 대신 List를 사용하세요.\n6. 성능을 높이기 위해, 문자열을 루프에서 연결하는 대신 StringBuilder를 사용하세요.\n7. 각 모드의 코드를 별도의 메소드로 추출하여 가독성과 유지보수성을 높이세요.\n8. 가독성을 높이기 위해, 연산자 주변과 쉼표 뒤에 더 많은 공백을 사용하세요.\n9. \"rightRo\"와 \"leftRo\" 메소드에서 \"temp\" 변수에 더 자세한 이름을 사용하세요.\n10. \"mode5\"와 \"mode6\" 메소드의 시간 복잡도가 O(n^2)인 경우, 더 효율적인 알고리즘을 사용하는 것을 고려하세요.',89),
(178,52695049,2,'O(n+q)','코드는 먼저 입력 문자열 S를 전처리하여 문자열의 각 문자에 대한 누적 합 배열을 생성합니다. 이 전처리는 O(n) 시간이 소요됩니다. 그런 다음, 각각의 q 질문에 대해 코드는 li와 ri로 정의된 S의 부분 문자열에서 주어진 문자 αi의 발생 횟수를 전처리된 누적 합 배열을 사용하여 계산합니다. 각 질문이 상수 시간이 걸리므로 총 시간 복잡도는 O(n+q)입니다.',100,'이 코드는 누적 합 알고리즘을 사용하여 입력 문자열 S를 전처리하며, 이를 통해 부분 문자열에서 주어진 문자의 발생 횟수를 상수 시간으로 계산할 수 있습니다. 이로 인해 효율적인 O(n+q) 시간 복잡도가 나타납니다.','없습니다.','사용자의 코드는 이미 효율적인 O(n+q) 시간 복잡도로 최적화되어 있습니다. 추가 개선이 필요하지 않습니다.','O(n)','코드는 입력 문자열 S의 각 문자에 대한 전처리된 누적 합 배열을 저장합니다. 이는 O(n) 공간을 필요로 합니다. 알고리즘의 공간 복잡도는 이 배열에 의해 지배됩니다.',100,'이 코드는 입력 문자열 S의 각 문자에 대해 단일 전처리된 누적 합 배열을 사용하여 부분 문자열에서 주어진 문자의 발생 횟수를 효율적으로 계산합니다. 이로 인해 효율적인 O(n) 공간 복잡도가 발생합니다.','없습니다.','사용자의 코드는 이미 효율적인 O(n) 공간 복잡도로 최적화되어 있습니다. 추가 개선이 필요하지 않습니다.',70,'1. \'bf\', \'sb\', \'vis\', \'k\', \'map\', \'N\', \'a\', \'start\', \'end\', 그리고 \'answer\'와 같은 약어 대신 더 구체적인 변수 이름을 사용하세요.\n2. 문자가 이미 방문되었는지 확인하기 위해 비트 연산자 대신 HashSet을 사용하세요.\n3. \'map\' ArrayList를 길이가 1인 빈 배열로 초기화하는 대신 null 값을 사용하고 방문한 문자에 대해서만 배열을 생성하세요.\n4. \'map\' ArrayList를 반복하는 두 개의 루프를 하나의 루프로 결합하여 코드 반복을 줄이세요.\n5. 주어진 문자의 배열 길이를 확인하기 위해 if-else 문 대신 switch 문을 사용하세요.\n6. 출력 문자열을 만들기 위해 String에 추가하는 대신 StringBuilder를 사용하세요.\n7. BufferedReader를 자동으로 닫기 위해 try-with-resources를 사용하세요.\n8. 각 문자에 대해 부분 문자열을 반복하는 대신 Segment Tree와 같은 더 효율적인 데이터 구조를 사용하여 쿼리에 대답하세요.\n9. 부분 문자열에서 문자의 발생을 찾기 위해 반복하는 대신 Knuth-Morris-Pratt (KMP)와 같은 더 효율적인 알고리즘을 사용하세요.',90),
(179,54894098,6,'O(N^2M^2)','알고리즘은 종이 위에서 테트로미노의 모든 가능한 위치를 반복하려면 두 개의 중첩된 루프를 사용하며, 이는 O(NM) 시간 복잡도를 필요로합니다. 각 반복에서 len4_func 및 octo_func 함수가 호출되며, 이 또한 O(NM) 시간 복잡도를 필요로합니다. 따라서 전체 시간 복잡도는 O(N^2M^2)입니다.',98,'알고리즘은 테트로미노의 모든 가능한 위치를 올바르게 고려하며, 서로 다른 테트로미노 모양을 처리하기 위해 두 개의 별도 함수를 사용합니다.','알고리즘은 두 개의 중첩된 루프와 두 개의 별도 함수를 사용하여 시간 복잡도가 높아집니다.','1. 서로 다른 테트로미노 모양에 대해 두 개의 별도 함수를 사용하는 대신, 모든 모양을 처리할 수 있는 하나의 함수로 결합하십시오. 이렇게하면 함수 호출 수가 줄어들고 시간 복잡도가 개선됩니다.\n2. 동적 프로그래밍을 사용하여 지금까지 찾은 최대 합을 저장하고 불필요한 계산을 피하십시오. 이렇게하면 반복 횟수가 줄어들고 시간 복잡도가 개선됩니다.\n3. 카다네 알고리즘과 같은 더 효율적인 알고리즘을 사용하여 최대 합을 찾으십시오. 이렇게하면 시간 복잡도가 O(NM)으로 줄어듭니다.','O(NM)','알고리즘은 종이 위의 숫자와 테트로미노의 위치를 추적하기 위해 크기가 N x M인 2D 배열 두 개만 저장하면 됩니다. 따라서 공간 복잡도는 O(NM)입니다.',87,'알고리즘은 필요한 정보를 저장하기 위해 최소한의 메모리를 사용합니다.','알고리즘은 큰 입력에 대해 높은 공간 복잡도를 유발할 수 있는 두 개의 2D 배열을 사용합니다.','1. 2D 배열 대신 1D 배열을 사용하여 종이에 적힌 숫자를 저장하세요. 이렇게 하면 메모리 사용량이 N 배 감소합니다.\n2. 2D 배열 대신 비트 조작을 사용하여 테트로미노의 위치를 저장하세요. 이렇게 하면 메모리 사용량이 8 배 감소합니다.',70,'1. 약어 대신 의미 있는 변수 이름을 사용하세요. 예를 들어, \"num_arr\" 대신 \"num_array\", \"mxscore\" 대신 \"max_score\"를 사용하세요.\n2. 코드에 가치를 더하지 않는 불필요한 주석을 제거하세요.\n3. 배열을 반복하는 두 개의 중첩된 for 루프를 하나의 루프로 결합하여 코드 반복을 줄이세요.\n4. 가독성을 높이기 위해 가능한 경우 전통적인 for 루프 대신 범위 기반 for 루프를 사용하세요.\n5. 변수의 값이 변경되지 않음을 나타내기 위해 적절한 경우 const를 사용하세요.\n6. 메모리 관리를 개선하고 잠재적인 버퍼 오버플로우를 피하기 위해 C 스타일 배열 대신 std::vector를 사용하세요.\n7. 가독성을 높이고 코드 반복을 줄이기 위해 std::min_element를 사용하여 octo_func에서 최소값을 수동으로 찾는 대신 사용하세요.\n8. 가독성을 높이고 코드 반복을 줄이기 위해 std::accumulate를 사용하여 octo_func에서 값을 수동으로 합산하는 대신 사용하세요.\n9. 가독성을 높이기 위해 if 문 대신 std::max를 사용하여 octo_func에서 max_score를 업데이트하세요.\n10. 가독성과 유지 보수성을 개선하기 위해 메인 함수와 결합하는 대신 주어진 테트로미노의 숫자 합을 계산하는 별도의 함수를 사용하세요.',85),
(180,48382175,6,'O(2^n)','이 함수는 피보나치 수를 계산하기 위해 재귀를 사용하며, 함수 호출마다 두 개의 호출이 추가되어 기본 케이스에 도달할 때까지 O(2^n)의 시간 복잡도를 가집니다.',100,'이 코드는 동적 프로그래밍을 사용하여 출력된 0과 1의 수를 저장하여 필요한 재귀 호출 수를 줄입니다.','피보나치 함수의 재귀 구현은 O(2^n)의 시간 복잡도를 가지며, n 값이 큰 경우에는 최적이 아닙니다.','1. 재귀적인 방법 대신 반복적인 방법을 사용하여 피보나치 수를 계산하십시오. 이렇게하면 시간 복잡도가 O(n)으로 줄어듭니다.\n2. 이미 계산된 피보나치 수열의 값을 저장하기 위해 메모이제이션을 사용하십시오. 이렇게하면 필요한 재귀 호출 수가 줄어들고 시간 복잡도가 O(n)으로 개선됩니다.\n3. 피보나치 수를 계산하기 위해 폐쇄형 표현식을 사용하십시오. 이렇게하면 시간 복잡도가 O(1)로 줄어듭니다.','O(n)','주어진 코드에서 스택에 있는 함수 호출의 최대 수는 N의 값과 같으므로, 코드는 각 N 값에 대해 출력된 0과 1의 수를 저장하기 위해 배열을 사용하며, 이에 따라 공간 복잡도는 O(n)입니다.',100,'주어진 문제 제약 조건에 대해 공간 복잡도가 최적입니다.','없습니다.','주어진 문제 제약 조건에 대해 공간 복잡도는 이미 최적화되어 있습니다.',70,'1. \'result\'와 \'st\'와 같은 전역 변수 사용을 피하고 대신 메인 함수 내에서 선언하고 \'fibonacci\' 함수에 인수로 전달하세요.\n2. \'Node\' 구조체에 대해 \'z\'와 \'o\' 대신 더 구체적인 변수 이름을 사용하세요.\n3. 사용되지 않는 \'de\' 변수를 제거하세요.\n4. 입력 값을 배열 \'in\'에 저장하는 대신 루프 내에서 \'num\' 변수를 직접 사용할 수 있습니다.\n5. \'num\' 값이 더 큰 경우 정수 오버플로우를 피하기 위해 \'int\' 대신 \'long long\' 데이터 유형을 사용하세요.\n6. 고정 크기 제약 조건을 피하기 위해 배열 대신 \'vector\'를 사용하세요.\n7. 동일한 값을 여러 번 다시 계산하지 않도록 재귀 대신 메모이제이션을 사용하세요.\n8. 출력 루프 내에서 수를 계산하는 대신 별도의 함수를 사용하여 0과 1의 수를 계산하세요.\n9. 함수 내에서 수정되지 않는 변수에 대해 \'const\' 키워드를 사용하세요.\n10. \'\\n\'보다 느릴 수 있으므로 필요한 경우에만 \'endl\'을 사용하세요.',90),
(181,60901305,6,'O(2^n)','이 함수는 피보나치 수를 계산하기 위해 재귀를 사용하며, 함수 호출마다 두 개의 호출이 추가되어 기본 케이스에 도달할 때까지 O(2^n)의 시간 복잡도를 가집니다.',100,'이 코드는 동적 프로그래밍을 사용하여 출력된 0과 1의 수를 저장하여 필요한 재귀 호출 수를 줄입니다.','피보나치 함수의 재귀 구현은 O(2^n)의 시간 복잡도를 가지며, n 값이 큰 경우에는 최적이 아닙니다.','1. 재귀적인 방법 대신 반복적인 방법을 사용하여 피보나치 수를 계산하세요. 이렇게 하면 시간 복잡도가 O(n)으로 줄어듭니다.\n2. 이미 계산된 피보나치 수열의 값을 저장하기 위해 메모이제이션을 사용하세요. 이렇게 하면 필요한 재귀 호출 수가 줄어들어 시간 복잡도가 O(n)으로 개선됩니다.','O(n)','주어진 코드에서 스택에 있는 함수 호출의 최대 수는 N의 값과 같으므로, 코드는 각 N 값에 대해 출력된 0과 1의 수를 저장하기 위해 배열을 사용하며, 이에 따라 공간 복잡도는 O(n)입니다.',100,'주어진 문제 제약 조건에 대해 공간 복잡도가 최적입니다.','없습니다.','주어진 문제 제약에 대해 공간 복잡도는 이미 최적화되어 있으므로 추가적인 개선은 필요하지 않습니다.',70,'1. \'result\'와 \'st\'와 같은 전역 변수 사용을 피하고 대신 메인 함수 내에서 선언하고 \'fibonacci\' 함수에 인수로 전달하세요.\n2. \'Node\' 구조체에 대해 \'z\'와 \'o\' 대신 더 구체적인 변수 이름을 사용하세요.\n3. 사용되지 않는 \'de\' 변수를 제거하세요.\n4. 입력 값을 \'in\' 배열에 저장하는 대신 루프 내에서 \'num\' 변수를 직접 사용할 수 있습니다.\n5. \'num\' 값이 더 큰 경우 정수 오버플로우를 피하기 위해 \'int\' 대신 \'long long\' 데이터 유형을 사용하세요.\n6. 고정 크기 제약 조건을 피하기 위해 배열 대신 \'vector\'를 사용하세요.\n7. 동일한 값을 여러 번 다시 계산하지 않도록 재귀 대신 메모이제이션을 사용하세요.\n8. 출력 루프 내에서 수를 계산하는 대신 별도의 함수를 사용하여 0과 1의 수를 계산하세요.\n9. 함수 내에서 수정되지 않는 변수에 대해 \'const\' 키워드를 사용하세요.\n10. \'\\n\'보다 느릴 수 있으므로 필요한 경우에만 \'endl\'을 사용하세요.',90),
(182,60901486,6,'O(T)','코드에는 각각 T번 반복하는 두 개의 루프가 있으므로 시간 복잡도는 테스트 케이스 수에 선형적입니다.',100,'이 코드는 간단하고 직관적인 구현을 가지고 있습니다.','없습니다.','1. 제곱근을 계산하는 대신 피타고라스의 정리와 같은 더 빠른 거리 계산 방법을 사용하세요.\n2. 두 개의 루프 대신 하나의 루프를 사용하여 테스트 케이스를 반복하세요.\n3. cin/cout 대신 scanf/printf와 같은 더 빠른 입력/출력 방법을 사용하세요.','O(T)','코드는 각 테스트 케이스마다 일정한 공간을 사용하므로, 공간 복잡도는 테스트 케이스 수에 선형적입니다.',100,'이 코드는 최소한의 공간을 사용합니다.','없습니다.','없습니다. 코드의 공간 복잡도는 이미 최적화되어 있습니다.',70,'1. \'arr\'와 \'result\'와 같은 일반적인 변수 이름 사용을 피하고, 변수의 목적을 전달하는 더 구체적인 이름을 사용하세요.\n2. 코드에서 계산을 여러 번 반복하는 대신 두 점 사이의 거리를 계산하는 별도의 함수를 사용하는 것을 고려하세요.\n3. 초기화 후 수정되지 않는 변수에는 const 키워드를 사용하세요.\n4. 가능한 경우 전통적인 for 루프 대신 range-based for 루프를 사용하세요.\n5. 코드를 읽고 이해하기 어려울 수 있는 \'continue\' 문 사용을 피하고, 대신 if-else 문을 사용하여 다른 경우를 처리하세요.\n6. 가독성을 높이기 위해 여러 개의 if-else 문 대신 switch 문을 사용하는 것을 고려하세요.\n7. x1, y1, r1, x2, y2, r2와 같은 입력 값에 대해 의미 있는 변수 이름을 사용하세요.\n8. 결과 값을 출력하는 것보다 더 구체적인 출력 메시지를 사용하세요.\n9. 배열 대신 우선순위 큐나 집합과 같은 더 효율적인 데이터 구조를 사용하는 것을 고려하세요.\n10. 코드의 가독성을 높이기 위해 더 많은 공백과 들여쓰기를 사용하세요.',90),
(183,52604648,2,'O(N)','알고리즘은 패턴을 찾기 위해 N개의 정수 시퀀스 전체를 반복해야 합니다. 이는 O(N) 시간 복잡도를 필요로 합니다. 알고리즘에는 몇 가지 조건문이 있지만, 시간 복잡도에 큰 영향을 미치지 않습니다.',100,'이 코드는 알고리즘을 명확하고 간결한 논리로 간단하게 구현하였습니다.','없습니다.','1. 현재 구현은 이미 최적화되어 있으므로, KMP 알고리즘 또는 Boyer-Moore 알고리즘과 같은 더 효율적인 알고리즘을 사용하면 코드가 더욱 향상될 수 있습니다. 그러나 입력 크기가 작기 때문에 현재 구현이 이미 최적입니다.\n2. BufferedReader 및 StringTokenizer와 같은 더 빠른 I/O 작업을 사용하면 입력/출력 속도를 향상시킬 수 있지만, 알고리즘의 시간 복잡도에는 큰 영향을 미치지 않습니다.','O(1)','알고리즘은 입력 시퀀스와 상수인 a와 b의 값만 저장하면 됩니다. 따라서 공간 복잡도는 O(1)입니다.',100,'이 코드는 주어진 문제에 최적화된 최소한의 공간을 사용합니다.','없습니다.','없습니다. 코드는 이미 공간 복잡도에 최적화되어 있습니다.',70,'1. a와 b 대신에 기울기와 y절편과 같은 더 구체적인 변수 이름을 사용하세요.\n2. N==1과 N==2를 따로 확인하는 대신, 하나의 if 문으로 결합하여 코드를 간소화하세요.\n3. map 배열을 반복할 때 일반적인 for 루프 대신 for-each 루프를 사용하세요.\n4. ArrayDeque 대신 List를 사용하여 입력에서 정수를 저장하세요. 이렇게 하면 코드가 간소화되고 가독성이 높아집니다.\n5. BufferedReader를 생성할 때 try-with-resources를 사용하여 자동으로 닫으세요.\n6. bf와 st 대신 BufferedReader와 StringTokenizer와 같은 의미 있는 변수 이름을 사용하세요.\n7. if 문에서 조건을 괄호로 묶어 가독성을 높이세요.\n8. 마지막 if-else 문을 간소화하기 위해 삼항 연산자를 사용하세요.\n9. 코드의 각 부분의 목적을 설명하는 주석을 추가하여 가독성을 높이세요.',90),
(184,48325029,2,'O(RCT)','알고리즘은 격자의 모든 셀을 R번 (각 초마다) 반복하고 각 셀에서 계산을 수행하며, 이는 O(C) 시간이 소요됩니다. 따라서 시간 복잡도는 O(RCT)입니다.',100,'이 코드는 미세먼지의 확산과 공기 청정기의 이동을 효율적으로 처리합니다.','없습니다.','이 코드의 시간 복잡도는 이미 최적화되어 있습니다.','O(RC)','알고리즘은 크기 RxC의 그리드만 저장하면 되며, 이는 O(RC) 공간을 차지합니다. 추가적인 데이터 구조는 필요하지 않습니다.',100,'이 코드는 최소한의 공간을 사용하며 추가적인 데이터 구조가 필요하지 않습니다.','없습니다.','이 코드의 공간 복잡도는 이미 최적입니다.',70,'1. 약어 대신 더 구체적인 변수 이름을 사용하세요. 예를 들어, \"R\" 대신 \"rows\", \"C\" 대신 \"columns\", \"T\" 대신 \"time\"을 사용하세요.\n2. 불필요한 배열 복제를 피하세요. \"map\" 배열 전체를 복제하는 대신, 업데이트해야 하는 행만 \"tmp\" 배열에 복제하세요.\n3. \"spread\" 메소드와 같은 더 구체적인 이름을 사용하세요. 예를 들어, \"updateAdjacentCells\"와 같은 이름을 사용하세요.\n4. \"air\" 메소드와 같은 더 구체적인 이름을 사용하세요. 예를 들어, \"updateAirFlow\"와 같은 이름을 사용하세요.\n5. \"updateAdjacentCells\" 메소드에서 if-else 문 대신 switch 문을 사용하여 가독성을 향상시키세요.\n6. 배열을 반복할 때 전통적인 for 루프 대신 for-each 루프를 사용하여 가독성을 향상시키세요.\n7. \"updateAdjacentCells\" 메소드에서 4의 값을 하드코딩하는 대신 상수 변수를 사용하세요.\n8. \"updateAirFlow\" 메소드에서 2의 값을 하드코딩하는 대신 상수 변수를 사용하세요.\n9. \"updateAirFlow\" 메소드에서 0의 값을 하드코딩하는 대신 상수 변수를 사용하세요.\n10. \"updateAirFlow\" 메소드에서 1의 값을 하드코딩하는 대신 상수 변수를 사용하세요.\n11. \"MAX\" 변수에 \"Integer.MAX_VALUE\" 값을 하드코딩하는 대신 상수 변수를 사용하세요.\n12. \"vis\" 변수와 같은 더 구체적인 이름을 사용하세요. 예를 들어, \"visitedCells\"와 같은 이름을 사용하세요.\n13. \"sb\" 변수와 같은 더 구체적인 이름을 사용하세요. 예를 들어, \"outputStringBuilder\"와 같은 이름을 사용하세요.\n14. 가독성과 유지 보수성을 향상시키기 위해 \"main\" 메소드를 더 작고 중심이 맞는 메소드로 분할하는 것을 고려하세요.\n15. 감소하는 먼지 농도 순서로 인접한 셀을 업데이트하기 위해 우선순위 큐와 같은 더 효율적인 데이터 구조를 사용하는 것을 고려하세요.\n16. 방 안에서 먼지의 확산을 시뮬레이션하는 더 효율적인 알고리즘인 cellular automaton을 사용하는 것을 고려하세요.',90),
(185,60845144,4,'O(N*M*(K+L+S))','코드는 영웅을 이동하고 아이템 상자를 열고 가시 함정을 확인하는 등 다양한 작업을 수행하기 위해 전체 그리드 (N * M)를 반복합니다. 또한 몬스터 목록 (K)을 반복하여 조우와 전투를 확인합니다. 코드는 장비와 효과를 확인하기 위해 아이템 상자 목록 (L)을 반복하며, 마지막으로 영웅의 작업 문자열 (S)을 반복하여 작업을 수행합니다. 시간 복잡도는 O (N * M * (K + L + S))입니다.',100,'이 코드는 이미 최적화되어 있으며 중복 루프나 작업이 없습니다.','없습니다.','이 코드는 이미 최적화되어 있으며 중복 루프나 연산이 없습니다. 그러나 Java의 내장 ArrayList나 HashSet와 같은 라이브러리를 사용하면 특정 작업에 필요한 반복 횟수를 줄여 시간 복잡도를 개선할 수 있습니다. 또한 Scanner 대신 BufferedReader를 사용하여 I/O 작업을 최적화하는 것도 코드의 실행 시간을 개선할 수 있습니다.','O(N*M + K + L)','이 코드는 전체 그리드(N*M)와 각 몬스터(K) 및 아이템 상자(L)에 대한 정보를 저장합니다. 이 정보에는 각 몬스터 및 아이템 상자의 위치, 유형 및 효과가 포함됩니다. 영웅의 행동 문자열을 저장할 필요는 없으며, 필요할 때 처리할 수 있습니다. 공간 복잡도는 O(N*M + K + L)입니다.',100,'이 코드는 이미 최적화되어 있으며 중복된 데이터 구조 또는 변수가 없습니다.','없습니다.','이 코드는 이미 최적화되어 있으며 중복된 데이터 구조 또는 변수가 없습니다. 그러나 ArrayList 대신 더 효율적인 데이터 구조인 배열을 사용하면 코드의 공간 복잡도를 개선할 수 있습니다. 또한, 문자 대신 비트셋을 사용하여 그리드의 상태를 저장하면 그리드를 저장하는 데 필요한 공간을 줄일 수 있습니다.',60,'1. ATT, DEF, HP 등의 약어 대신 더 구체적인 변수 이름을 사용하세요. 이렇게 하면 코드를 더 읽기 쉽고 이해하기 쉽게 만들 수 있습니다.\n2. O_HR, O_RE 등 여러 부울 변수를 사용하여 아이템 효과를 추적하는 대신, Set이나 Map과 같은 단일 데이터 구조를 사용하여 활성 효과를 저장하는 것이 좋습니다. 이렇게 하면 코드가 단순화되고 향후 효과를 추가하거나 제거하기 쉬워집니다.\n3. 격자를 반복하려면 중첩된 루프 대신 선형 인덱스를 사용하는 단일 루프를 고려하세요. 이렇게 하면 코드가 단순화되고 더 효율적으로 만들 수 있습니다.\n4. 몬스터와 아이템에 대한 정보를 저장하기 위해 사용자 정의 Object_info 클래스를 사용하는 대신, 각 유형의 개별 클래스를 사용하는 것이 좋습니다. 이렇게 하면 코드가 모듈화되고 유지 보수가 쉬워집니다.\n5. 각 아이템 유형에 대한 if-else 체인 대신 다형성을 사용하여 개별 아이템 유형에 대한 별도의 클래스를 만드는 것이 좋습니다. 이렇게 하면 코드가 단순화되고 확장성이 높아집니다.\n6. 게임을 시뮬레이션하기 위해 true 조건을 가진 while 루프 대신, 명령 문자열의 길이를 기반으로 한 고정된 반복 횟수를 가진 for 루프를 사용하는 것이 좋습니다. 이렇게 하면 코드가 더 읽기 쉽고 이해하기 쉬워집니다.\n7. 모든 영웅 속성을 저장하기 위해 단일 Player 클래스를 사용하는 대신, 체력, 공격, 방어 등 각 속성에 대한 개별 클래스를 사용하는 것이 좋습니다. 이렇게 하면 코드가 모듈화되고 유지 보수가 쉬워집니다.\n8. 게임 상태를 출력하기 위해 사용자 정의 print 메서드를 사용하는 대신, 출력 형식을 위한 별도의 클래스를 사용하는 것이 좋습니다. 이렇게 하면 코드가 모듈화되고 유지 보수가 쉬워집니다.\n9. \'B\', \'&\', \'M\' 등과 같은 값을 하드코딩하는 대신 상수를 사용하세요. 이렇게 하면 코드가 더 읽기 쉽고 이해하기 쉬워집니다.\n10. BufferedReader를 수동으로 닫는 대신 try-with-resources 문을 사용하여 자동으로 닫으세요. 이렇게 하면 코드가 단순화되고 효율적으로 만들 수 있습니다.\n11. 문자열을 \'+\' 연산자로 연결하는 대신 StringBuilder를 사용하세요. 이렇게 하면 코드의 성능이 향상됩니다.\n12. 루프 카운터에 \'i\', \'j\'와 같은 의미 없는 변수 이름 대신 의미 있는 변수 이름을 사용하세요. 이렇게 하면 코드가 더 읽기 쉽고 이해하기 쉬워집니다.\n13. 제네릭 타입의 인스턴스화를 단순화하기 위해 다이아몬드 연산자를 사용하세요. 이렇게 하면 코드가 더 간결하고 읽기 쉬워집니다.\n14. 컬렉션을 반복할 때 전통적인 for 루프 대신 개선된 for 루프를 사용하세요. 이렇게 하면 코드가 단순화되고 읽기 쉬워집니다.\n15. 간단한 조건에 대해서는 if-else 문 대신 삼항 연산자를 사용하세요. 이렇게 하면 코드가 더 간결하고 읽기 쉬워집니다.\n16. 컬렉션이 비어 있는지 확인하기 위해 크기를 확인하는 대신 isEmpty() 메서드를 사용하세요. 이렇게 하면 코드가 단순화되고 읽기 쉬워집니다.\n17. 아이템 유형을 확인할 때 긴 if-else 체인 대신 switch 문을 사용하세요. 이렇게 하면 코드가 단순화되고 읽기 쉬워집니다.',86),
(186,60519947,1,'O(1)','프로그램은 단일 덧셈 연산만 수행하면 되므로 시간 복잡도는 상수입니다. 입력 크기에 관계없이 일정한 시간이 소요됩니다.',100,'이 코드는 이 문제에 대해 최적의 시간 복잡도를 달성했습니다.','없습니다.','없습니다.','O(1)','프로그램은 A와 B 두 정수와 그들의 합의 결과만 저장하면 되므로 입력 크기에 관계없이 일정한 공간을 차지하므로 공간 복잡도는 상수입니다.',100,'이 코드는 이 문제에 대해 최적의 공간 복잡도를 달성했습니다.','없습니다.','없습니다.',90,'1. \'a\', \'b\', 및 \'result\' 대신 더 구체적인 변수 이름을 사용하십시오. 예를 들어, \'first_number\', \'second_number\', 및 \'sum\'.\n2. 코드의 목적과 복잡한 논리를 설명하는 주석을 추가하십시오.\n3. 사용자가 지정된 범위를 벗어나는 값을 입력하는 경우에 대한 오류 처리를 추가하는 것이 좋습니다.\n4. 변수에 할당하는 대신 합계를 출력하기 위해 하나의 printf 문을 사용하십시오.\n5. 특히 이 코드가 더 큰 프로그램의 일부인 경우 \'main\' 대신 더 구체적인 함수 이름을 사용하는 것이 좋습니다.\n6. main 함수의 불필요한 return 문을 제거하십시오.\n7. 개선된 보안을 위해 scanf 대신 scanf_s와 같은 더 현대적인 입력 방법을 사용하는 것이 좋습니다.\n8. 일관성과 이식성을 향상시키기 위해 \'int\' 대신 \'int32_t\'와 같은 더 현대적인 데이터 유형을 사용하는 것이 좋습니다.\n9. 가독성을 향상시키기 위해 단순히 \"%d\" 대신 \"%d + %d = %d\"와 같은 더 구체적인 형식 문자열을 사용하는 것이 좋습니다.\n10. 가독성을 향상시키기 위해 줄 바꿈 문자를 printf 문 뒤에 추가하는 등의 공백 및 서식을 추가하는 것이 좋습니다.',96),
(187,31468002,7,'O(T)','알고리즘은 각 테스트 케이스마다 일정한 수의 작업을 수행하며, 입력 크기와는 독립적입니다. 따라서 시간 복잡도는 테스트 케이스 수에 선형적입니다.',100,'코드는 간단하고 직관적인 구현을 가지고 있어 이해와 유지보수가 쉽습니다.','없습니다.','이 코드의 시간 복잡도는 이미 최적이며, 개선할만한 제안은 더 이상 없습니다.','O(1)','알고리즘은 각 테스트 케이스마다 입력 크기와 독립적인 상수 개수의 변수만 저장하면 됩니다. 따라서 공간 복잡도는 상수입니다.',100,'이 코드는 최소한의 메모리를 사용하여 효율적이고 최적화되어 있습니다.','없습니다.','코드의 공간 복잡도는 이미 최적이며, 개선할만한 제안은 더 이상 없습니다.',80,'1. 약어 대신 더 자세한 변수 이름을 사용하세요. 예를 들어, \'r1\' 대신 \'radius1\'을(를) 사용하세요.\n2. \'location_count\' 함수 내에서 \'print\' 문을 사용하지 마세요. 대신, 결과를 반환하고 함수 외부에서 출력하세요.\n3. \'distance==0\'을 따로 확인하는 대신 \'abs\' 함수를 사용하여 \'distance\'의 절대값을 계산하세요.\n4. 가독성을 높이기 위해 중첩된 \'if\' 문 대신 \'elif\' 문을 사용하세요.\n5. \'distance==r1+r2\' 또는 \'m==sum(dis)\'인 경우 \'if-else\' 문을 단순화하기 위해 \'ternary operator\'를 사용하세요.\n6. 문제 설명에 의존하는 대신 입력 제약 조건을 확인하기 위해 \'assert\' 문을 사용하세요.\n7. 더 정확한 비교를 위해 \'==\' 대신 \'math.isclose\' 함수를 사용하여 부동 소수점 수를 비교하세요.\n8. 입력 독서 중 발생할 수 있는 예외를 처리하기 위해 \'try-except\' 블록을 사용하세요.\n9. \'dis\' 리스트를 생성하기 위해 \'list comprehension\'을(를) 사용하여 단순화하세요.\n10. 최소값과 최대값을 찾기 위해 \'dis\' 리스트를 정렬하는 대신 \'min\' 및 \'max\' 함수를 사용하세요.',93),
(188,51357713,2,'O(nlogn)','먼저 코드는 입력을 읽어들이는데 O(n) 시간이 소요됩니다. 그 다음, Arrays.sort()를 사용하여 레고 조각의 길이 배열을 정렬하며 이는 O(nlogn) 시간이 소요됩니다. 마지막으로, 정렬된 배열을 순회하기 위해 두 개의 포인터를 사용하며 이는 O(n) 시간이 소요됩니다. 따라서, 이 코드의 전체 시간 복잡도는 O(nlogn)입니다.',98,'이 코드는 Lego 조각 길이 배열을 정렬하기 위해 효율적인 정렬 알고리즘 Arrays.sort()를 사용합니다.','없습니다.','1. 정렬된 배열을 탐색하기 위해 두 개의 포인터를 사용하는 대신, 바이너리 서치를 사용하여 구멍 너비를 더하는 레고 조각 쌍을 찾을 수 있습니다. 이렇게 하면 시간 복잡도가 O(nlogn)으로 줄어듭니다.\n2. 해시 테이블을 사용하여 레고 조각 길이와 해당 인덱스를 저장할 수 있습니다. 그런 다음 배열을 반복하고 해시 테이블이 현재 레고 조각 길이의 보완을 포함하는지 확인할 수 있습니다. 이렇게 하면 시간 복잡도가 O(n)으로 줄어듭니다.\n3. 레고 조각 길이 배열을 정렬하기 위해 병합 정렬을 사용할 수 있습니다. 병합 정렬은 Arrays.sort()와 동일한 시간 복잡도를 가지지만, 상수 인자가 낮아 더 큰 입력 크기에 대해 더 빠를 수 있습니다.','O(n)','코드는 Lego 조각의 길이를 저장하기 위해 크기가 n인 배열을 사용합니다. 따라서 코드의 공간 복잡도는 O(n)입니다.',100,'이 코드는 추가적인 공간을 최소한으로 사용합니다.','없습니다.','이 코드의 공간 복잡도는 이미 최적입니다.',80,'1. 단일 문자 변수 대신 더 구체적인 변수 이름을 사용하세요. 예를 들어, \'X\' 대신 \'나노미터 단위의 구멍 너비\'를 사용하세요.\n2. 입력 정수를 10000000으로 곱하는 대신, 변환 상수 변수를 사용하세요. 이렇게 하면 코드가 더 읽기 쉽고 이해하기 쉬워집니다.\n3. for-each 루프를 사용하여 legos 배열을 반복 처리하세요. 이렇게 하면 코드가 더 간결하고 읽기 쉬워집니다.\n4. 배열을 정렬하고 두 개의 포인터를 사용하여 구멍을 완벽하게 덮을 수 있는 두 개의 레고 조각을 찾는 대신 이진 검색 알고리즘을 사용하세요. 이렇게 하면 코드의 성능이 향상됩니다.\n5. BufferedReader 객체가 더 이상 필요하지 않을 때 자동으로 닫히도록 try-with-resources 문을 사용하세요. 이렇게 하면 코드가 더 견고하고 오류가 적어집니다.\n6. 코드의 각 부분의 목적을 설명하는 주석을 추가하세요. 이렇게 하면 코드가 더 이해하기 쉽고 유지 보수하기 쉬워집니다.\n7. \'flag\' 변수와 같은 더 구체적인 이름을 사용하세요. 예를 들어, \'구멍이 덮여있는지 여부\'와 같은 이름을 사용하세요. 이렇게 하면 코드가 더 읽기 쉽고 이해하기 쉬워집니다.\n8. \'yes\' 문자열을 System.out.println() 문에서 하드 코딩하는 대신 상수 변수를 사용하세요. 이렇게 하면 코드가 더 유지 보수하기 쉽고 출력 형식이 변경되는 경우 수정하기 쉬워집니다.\n9. \'danger\' 문자열을 System.out.println() 문에서 하드 코딩하는 대신 상수 변수를 사용하세요. 이렇게 하면 코드가 더 유지 보수하기 쉽고 출력 형식이 변경되는 경우 수정하기 쉬워집니다.\n10. \'s\' 변수와 같은 더 구체적인 이름을 사용하세요. 예를 들어, \'왼쪽 인덱스\'와 같은 이름을 사용하세요. 이렇게 하면 코드가 더 읽기 쉽고 이해하기 쉬워집니다.',92),
(189,36914303,7,'O(n)','이 코드는 동적 프로그래밍을 사용하여 피보나치 수열을 반복적으로 계산합니다. 코드의 시간 복잡도는 N의 최대 값까지의 값 범위를 반복하고 각 값에 대해 상수 시간 연산을 수행하기 때문에 O(n)입니다.',100,'이 코드는 중복 계산을 피하고 시간 복잡도를 최적화하기 위해 동적 프로그래밍을 사용합니다.','없습니다.','이 코드의 시간 복잡도는 이미 최적화되어 더 개선될 수 없습니다.','O(n)','코드의 공간 복잡도는 피보나치 수를 저장하기 위해 크기가 41인 리스트를 생성하고 다른 변수에 대해서는 상수 공간을 사용하기 때문에 O(n)입니다.',100,'코드의 공간 복잡도는 최적이며 주어진 공간 제한을 초과하지 않습니다.','없습니다.','코드의 공간 복잡도는 이미 최적화되어 더 개선될 수 없습니다.',80,'1. \'data\'와 \'dp\' 대신 더 구체적인 변수 이름을 사용하세요.\n2. \'max(data)\' 대신 최대값을 따로 변수에 저장하여 가독성을 높이세요.\n3. \'dp[0]\'와 \'dp[1]\'의 초기화를 한 줄로 결합하세요.\n4. \'dp\'를 하드코딩하는 대신 루프를 사용하여 초기화하세요.\n5. 루프 대신 리스트 컴프리헨션을 사용하여 \'dp\'를 초기화하세요.\n6. 인덱스로 요소에 접근하는 대신 \'enumerate\'를 사용하여 \'data\'를 루프하세요.\n7. \'sys.stdin.readline\'과 \'int(input())\' 대신 \'input().split()\'을 사용하세요.\n8. 루프를 사용하는 대신 \'map\'을 사용하여 입력 값을 정수로 변환하세요.\n9. 연결 대신 \'f-strings\'를 사용하여 출력을 서식화하세요.\n10. \'dp\'에서 값을 수동으로 계산하는 대신 \'fibonacci\' 함수를 사용하세요.\n11. 리스트 대신 \'defaultdict\'를 사용하여 \'dp\'를 초기화하세요.\n12. 인덱스로 요소에 접근하는 대신 \'zip\'을 사용하여 \'dp\'와 \'data\'를 루프하세요.\n13. 범위 대신 \'itertools.islice\'를 사용하여 \'dp\'를 루프하세요.\n14. \'dp\'에 값을 저장하는 데 리스트 대신 튜플을 사용하세요.\n15. \'__name__ == \"__main__\":\'을 사용하여 파일이 실행될 때 실행되는 코드와 가져올 수 있는 코드를 분리하세요.\n16. 코드의 목적과 논리를 설명하는 주석을 추가하세요.',93),
(190,60912612,3,'O(N)','이 코드는 최단 부분 순서열을 찾기 위해 두 개의 포인터 알고리즘을 사용합니다. 누적 합을 계산하기 위해 시퀀스를 한 번 반복하고, 두 개의 포인터를 사용하여 시퀀스를 다시 반복하여 최단 부분 순서열을 찾습니다. 각 요소는 최대 두 번 방문하므로 시간 복잡도는 O(N)입니다.',100,'이 코드는 가장 짧은 부분 수열을 찾기 위해 효율적인 알고리즘을 사용합니다.','없습니다.','이 코드의 시간 복잡도는 이미 최적화되어 있습니다.','O(1)','코드는 왼쪽과 오른쪽 포인터, 그리고 지금까지 찾은 가장 짧은 부분 수열의 길이를 추적하는 변수만 저장하면 됩니다. 따라서 공간 복잡도는 O(1)입니다.',100,'이 코드는 문제를 해결하기 위해 최소한의 공간을 사용합니다.','없습니다.','이 코드의 공간 복잡도는 이미 최적입니다.',80,'1. \"using namespace std;\"는 이름 충돌을 일으킬 수 있으므로 사용하지 마십시오. 대신 필요한 경우 std:: 접두사를 사용하십시오.\n2. \"n\"과 \"m\"과 같은 한 글자 변수 이름 대신 더 구체적인 변수 이름을 사용하십시오.\n3. 불필요한 반복을 피하기 위해 두 while 루프를 하나의 for 루프로 결합하십시오.\n4. 코드를 단순화하고 잠재적인 버퍼 오버플로우를 피하기 위해 배열 대신 벡터를 사용하십시오.\n5. 가능한 경우 변수 선언을 단순화하기 위해 auto 키워드를 사용하십시오.\n6. 부분 수열을 찾기 위해 배열을 수동으로 반복하는 대신 lower_bound 함수를 사용하는 것이 좋습니다.\n7. 코드의 목적과 작동 방식을 설명하는 주석을 추가하십시오.\n8. 변수의 값이 변경되지 않아야 함을 나타내기 위해 적절한 경우 const를 사용하십시오.\n9. 가독성과 유지 관리성을 향상시키기 위해 코드를 작은 함수로 분할하는 것이 좋습니다.\n10. 배열을 반복하는 while 루프 대신 범위 기반 for 루프를 사용하십시오.',93),
(191,31846074,3,'O(1)','프로그램은 단일 덧셈 연산만 수행하면 되므로 시간 복잡도는 상수입니다. 입력 크기에 관계없이 일정한 시간이 소요됩니다.',100,'이 코드는 이미 시간 복잡도에 대해 최적화되어 있습니다.','없습니다.','없습니다.','O(1)','프로그램은 A와 B 두 정수와 그들의 합의 결과만 저장하면 되므로 입력 크기에 관계없이 일정한 공간을 차지하므로 공간 복잡도는 상수입니다.',100,'이 코드는 이미 공간 복잡도에 대해 최적화되어 있습니다.','없습니다.','없습니다.',90,'1. A와 B 대신 num1과 num2와 같은 더 구체적인 변수 이름을 사용하세요.\n2. 반환문 주석과 같은 불필요한 주석을 제거하세요.\n3. 잘못된 입력 값에 대한 오류 처리를 추가하는 것을 고려하세요.\n4. main과 같은 더 구체적인 함수 이름(sum_numbers 등)을 사용하세요.\n5. 보안 향상을 위해 scanf 대신 scanf_s와 같은 더 현대적인 입력 방법을 고려하세요.\n6. 반환문 앞에 빈 줄을 추가하여 가독성을 향상하세요.\n7. 변경되지 않는 변수에 대해 const를 사용하는 것을 고려하세요.\n8. \"num1과 num2의 합은 다음과 같습니다: \"와 같은 더 구체적인 출력 메시지를 사용하세요.\n9. 메모리 사용량을 개선하기 위해 int 대신 uint8_t와 같은 더 구체적인 변수 유형을 사용하세요.\n10. 가독성을 향상시키기 위해 if 문 대신 삼항 연산자를 사용하는 것을 고려하세요. 예를 들어 (num1 > num2) ? num1 : num2와 같습니다.',96),
(192,42713571,2,'O(1)','프로그램은 단일 덧셈 연산만 수행하면 되기 때문에 시간 복잡도는 상수입니다. 입력 크기는 프로그램이 수행하는 연산의 수에 영향을 미치지 않습니다.',100,'이 코드는 이 문제에 대해 가능한 최상의 시간 복잡도를 가지고 있습니다. 문제를 해결하는 데 필요한 최소한의 덧셈 연산만 수행합니다.','이 코드와 관련된 시간 복잡도에 대한 나쁜 점은 없습니다.','이 코드의 시간 복잡도는 이미 최적입니다. 더 이상 개선할 수 없습니다.','O(1)','프로그램은 A와 B 두 정수와 그들의 합의 결과만 저장하면 되기 때문에 공간 복잡도는 상수입니다. 입력 크기는 프로그램이 사용하는 메모리 양에 영향을 미치지 않습니다.',100,'이 코드는 이 문제에 대해 가능한 최상의 공간 복잡도를 가지고 있습니다. 문제를 해결하는 데 필요한 최소한의 메모리 양을 사용합니다.','이 코드와 관련된 공간 복잡도에 대한 나쁜 점은 없습니다.','이 코드의 공간 복잡도는 이미 최적화되어 있습니다. 더 이상 개선할 수 없습니다.',80,'1. A와 B 대신 num1과 num2와 같은 더 구체적인 변수 이름을 사용하세요.\n2. int()를 두 번 사용하여 입력을 정수로 변환하는 대신, map()을 사용하여 두 입력을 한 줄에 모두 정수로 변환할 수 있습니다. 예를 들어, num1, num2 = map(int, input().split())입니다.\n3. 문제 제약 조건에서 A와 B가 0에서 10 사이임을 명시하므로, 입력이 이 범위 내에 있는지 확인하는 검사를 추가할 수 있습니다. 예를 들어, if num1 < 0 or num1 > 10 or num2 < 0 or num2 > 10: print(\"Inputs out of range\")입니다.\n4. 코드가 하는 일을 설명하는 주석을 추가하세요. 예를 들어, # 이 코드는 두 정수를 입력받고 그 합을 출력합니다.\n5. 문제에서 요구하는 것이 A와 B의 합만 출력하는 것이므로, 코드의 처음에 A와 B에 0을 할당하는 불필요한 부분을 제거할 수 있습니다.\n6. 문자열 연결 대신 f-strings를 사용하여 출력을 서식화하는 것을 고려해보세요. 예를 들어, print(f\"{num1 + num2}\")입니다.\n7. 입력이 두 정수 대신 문자열 등의 올바른 형식이 아닌 경우에 대한 오류 처리를 추가하는 것을 고려해보세요.\n8. 코드의 목적과 입력/출력에 대해 설명하는 독스트링을 추가하는 것을 고려해보세요.',93),
(193,60912962,7,'O(1)','프로그램은 단일 덧셈 연산만 수행하면 되기 때문에 시간 복잡도는 상수입니다. 입력 크기는 프로그램이 수행하는 연산의 수에 영향을 미치지 않습니다.',100,'이 코드는 이 문제에 대해 가능한 최상의 시간 복잡도를 가지고 있습니다.','없습니다.','이 코드의 시간 복잡도는 이미 최적화되어 더 개선할 수 없습니다.','O(1)','프로그램은 A와 B 두 정수와 그들의 합의 결과만 저장하면 되기 때문에 공간 복잡도는 상수입니다. 입력 크기는 프로그램이 사용하는 메모리 양에 영향을 미치지 않습니다.',100,'이 코드는 이 문제에 대해 가능한 최상의 공간 복잡도를 가지고 있습니다.','없습니다.','이 코드의 공간 복잡도는 이미 최적화되어 더 개선될 수 없습니다.',90,'1. sumValueA와 sumValueB 대신 num1과 num2와 같은 더 구체적인 변수 이름을 사용하세요.\n2. 코드에서 사용되지 않으므로 problem_constraints를 제거하세요.\n3. 사용자로부터 입력을 읽을 때 예외 처리를 위해 try-catch 블록을 사용하세요.\n4. 변수를 선언하고 초기화하는 데 두 개의 별도의 줄 대신 단일 줄을 사용하세요.\n5. Main 대신 더 구체적인 클래스 이름을 사용하세요.\n6. 코드의 목적과 복잡한 로직을 설명하는 주석을 추가하세요.\n7. 성능 향상을 위해 Scanner 대신 BufferedReader와 같은 더 효율적인 입력 방법을 고려하세요.\n8. num1과 num2의 합을 출력하는 코드를 간단하게 만들기 위해 삼항 연산자를 사용하세요.\n9. 가독성을 높이기 위해 if-else 문 대신 switch 문을 사용하세요.\n10. 코드의 가독성을 높이기 위해 공백을 사용하세요.',96),
(194,60919420,7,'O(n)','코드는 각 알파벳의 빈도를 계산하기 위해 전체 단어를 한 번 반복합니다. 따라서 시간 복잡도는 단어의 길이인 n에 비례합니다.',95,'이 코드는 각 알파벳의 빈도를 세는 논리를 올바르게 구현하며 입력의 대소문자를 처리합니다.','코드를 최적화하여 전체 단어를 두 번 반복하는 것을 피할 수 있습니다.','1. 단어를 두 번 반복하는 대신, 한 번의 반복으로 각 알파벳의 빈도수를 계산할 수 있습니다. 우리는 각 알파벳의 빈도수를 저장하기 위해 사전을 사용하고, 단어를 반복하면서 업데이트할 수 있습니다. 이렇게 하면 시간 복잡도를 O(n)으로 줄이고 코드의 성능을 향상시킬 수 있습니다.\n2. 우리는 또한 collections 모듈의 내장 Counter 클래스를 사용하여 단어에서 각 알파벳의 빈도수를 계산할 수 있습니다. 이렇게 하면 코드를 간소화하고 가독성을 향상시킬 수 있습니다.','O(1)','이 코드는 각 알파벳의 빈도수만 저장하면 되므로 일정한 양의 공간을 사용할 수 있습니다. 따라서 공간 복잡도는 상수이며 O(1)입니다.',74,'이 코드는 각 알파벳의 빈도수를 저장하기 위해 일정한 양의 공간을 사용하며, 이는 최적화된 방법입니다.','방문한 목록을 사용하지 않고 공간을 덜 사용하도록 코드를 최적화할 수 있습니다.','1. 방문한 목록을 사용하여 각 알파벳의 빈도수를 추적하는 대신, 각 알파벳의 빈도수를 저장하기 위해 사전을 사용할 수 있습니다. 이렇게하면 공간 복잡도가 O(26)으로 줄어들고 코드의 성능이 향상됩니다.\n2. 또한 al 문자열을 생성하는 것을 피하고, 각 문자를 ASCII 코드로 변환하고 65를 빼서 알파벳에서의 인덱스를 얻기 위해 ord() 함수를 사용할 수 있습니다. 이렇게하면 al 문자열이 필요하지 않고 코드의 공간 복잡도가 줄어듭니다.',70,'1. \"s\", \"S\", \"al\", \"idx\", 및 \"a\"와 같은 한 글자 변수 대신 더 구체적인 변수 이름을 사용하십시오. 이렇게하면 코드가 더 읽기 쉽고 이해하기 쉬워집니다.\n2. \"visited\" 목록을 모두 0으로 초기화 한 다음 방문한 인덱스를 1로 설정하는 대신, \"visited\" 목록을 입력 문자열의 각 문자 수로 초기화하십시오. 이렇게하면 \"if visited[idx]==0\" 확인이 필요하지 않으며 코드가 단순화됩니다.\n3. 내장 \"collections.Counter\" 클래스를 사용하여 입력 문자열의 각 문자 빈도를 계산하십시오. 이렇게하면 코드가 단순화되고 효율적으로 만들 수 있습니다.\n4. 두 가장 빈번한 문자를 찾기 위해 \"max\" 함수를 두 번 사용하는 대신 \"collections.Counter.most_common\" 메서드를 사용하여 가장 일반적인 문자 및 빈도수 목록을 가져오십시오. 이렇게하면 코드가 단순화되고 효율적으로 만들 수 있습니다.\n5. 수동으로 연결하는 대신 \"join\" 메서드를 사용하여 알파벳 문자를 연결하십시오. 이렇게하면 코드가 단순화되고 읽기 쉬워집니다.\n6. 문자가 알파벳 문자인지 수동으로 확인하는 대신 \"isalpha\" 메서드를 사용하여 확인하십시오. 이렇게하면 코드가 단순화되고 효율적으로 만들 수 있습니다.\n7. 새 대문자 문자열을 만드는 대신 \"upper\" 메서드를 사용하여 입력 문자열을 대문자로 변환하십시오. 이렇게하면 코드가 단순화되고 효율적으로 만들 수 있습니다.\n8. 삼항 연산자를 사용하여 \"if a[0]==a[1]\" 확인을 단순화하십시오. 이렇게하면 코드가 간결하고 읽기 쉬워집니다.\n9. for 루프의 범위에서 불필요한 \"-1\"을 제거하십시오. 이렇게하면 코드가 단순화되고 읽기 쉬워집니다.\n10. 코드의 목적과 작동 방식을 설명하는 주석을 추가하십시오. 이렇게하면 다른 개발자가 코드를 더 잘 이해할 수 있습니다.',79),
(195,58423920,19,'O(N^M)','이 코드는 M 길이의 모든 가능한 시퀀스를 생성하기 위해 백트래킹을 사용하며, 각각 N 개의 가능한 값이 있습니다. 따라서 시간 복잡도는 O(N^M)입니다.',100,'이 코드는 이미 최적화되어 있으며 주어진 문제에 대한 효율적인 알고리즘을 사용합니다.','없습니다.','사용자의 코드는 이미 최적화되어 있으며 시간 복잡도를 개선할 제안이 없습니다.','O(M*N)','이 코드는 방문한 숫자를 추적하기 위해 크기가 N+2인 목록을 사용하고, 현재 시퀀스를 저장하기 위해 크기가 M인 목록을 사용합니다. 따라서 공간 복잡도는 O(M*N)입니다.',100,'주어진 문제에 대해 공간 복잡도가 이미 최적화되어 있으며 최소한의 메모리를 사용합니다.','없습니다.','사용자의 코드는 이미 최적화되어 있으며, 공간 복잡도를 개선할 제안이 없습니다.',70,'1. 약어 대신 더 구체적인 변수 이름을 사용하세요. 예를 들어, \'N\'과 \'M\' 대신 \'num1\'과 \'num2\' 또는 \'max_num\'과 \'min_num\'을 사용하세요.\n2. 답 리스트를 전역 변수로 사용하는 대신, dfs 함수의 매개변수로 전달하고 마지막에 반환하세요. 이렇게 하면 코드가 모듈화되어 테스트하기 쉬워집니다.\n3. 방문한 리스트를 초기화하기 위해 for 루프 대신 리스트 컴프리헨션을 사용하세요. 예를 들어, \'visited = [0 for _ in range(N+2)]\'를 사용하세요.\n4. \'if __name__ == \"__main__\":\' 문을 사용하여 코드가 모듈로 가져와지는 경우가 아닌 경우에만 실행되도록 하세요.\n5. 중복된 시퀀스를 확인하는 대신 \'set\' 데이터 구조를 사용하여 중복을 제거하세요.\n6. dfs 함수의 for 루프를 간단하게 하기 위해 \'range\' 함수를 세 개의 인수와 함께 사용하세요. 예를 들어, \'for i in range(s, N-M+n+2):\'를 사용하세요.\n7. 시퀀스의 요소를 연결하기 위해 \'print\' 함수 대신 \'join\' 메서드를 사용하세요. 예를 들어, \'print(\' \'.join(map(str, x)))\'를 사용하세요.\n8. 약어 대신 더 구체적인 함수 이름을 사용하세요. 예를 들어, \'dfs\' 대신 \'depth_first_search\'를 사용하세요.\n9. 함수의 목적과 동작을 문서화하기 위해 docstrings를 사용하세요.\n10. 함수 매개변수와 반환 값의 예상 타입을 나타내기 위해 타입 힌트를 사용하세요.',90),
(196,60924215,7,'O(T)','프로그램은 T개의 테스트 케이스를 반복해야 하며, 각 테스트 케이스마다 두 정수를 더하는 상수 시간 연산을 수행합니다. 따라서 시간 복잡도는 테스트 케이스 수에 선형적이며, O(T)입니다.',100,'이 코드는 이해하기 쉽고 유지보수하기 쉬운 간단하고 직관적인 구현이 있습니다.','없습니다.','이 코드의 시간 복잡도는 이미 최적화되어 있습니다.','O(1)','프로그램은 한 번에 두 개의 정수 (A와 B)와 A와 B의 합만 저장하면 됩니다. 따라서 공간 복잡도는 상수이며 O(1)입니다.',100,'이 코드는 최소한의 메모리를 사용하며 공간 사용 측면에서 효율적입니다.','없습니다.','이 코드의 공간 복잡도는 이미 최적입니다.',80,'1. 단일 문자 변수 대신 더 구체적인 변수 이름을 사용하세요. 예를 들어, \'N\' 대신 \'numTestCases\', \'i\' 대신 \'testCaseNum\', \'a\' 대신 \'firstNum\', \'b\' 대신 \'secondNum\'을 사용하세요.\n2. 테스트 케이스를 반복하는 for 루프 대신 foreach 루프를 사용하는 것이 코드를 더 읽기 쉽게 만들고 off-by-one 오류의 위험을 줄일 수 있습니다.\n3. Scanner 객체를 수동으로 닫는 대신 try-with-resources를 사용하여 자동으로 닫을 수 있습니다. 이렇게 하면 코드가 더 간결해지고 리소스 누출의 위험을 줄일 수 있습니다.\n4. 일반적인 Exception 클래스를 catch하는 대신 더 구체적인 예외를 사용하는 것이 코드를 더 견고하게 만들고 디버깅을 쉽게 할 수 있습니다.\n5. Scanner에서 하나씩 읽는 대신 배열이나 List와 같은 더 효율적인 데이터 구조를 사용하여 테스트 케이스를 저장하는 것이 Scanner.nextInt() 메서드를 여러 번 호출하는 오버헤드를 줄일 수 있습니다.\n6. 입력 값이 예상 범위 내에 있는지 확인하는 입력 유효성 검사를 추가하여 예기치 않은 동작을 방지하고 사용자 경험을 개선할 수 있습니다.\n7. 코드의 목적과 구현 세부 정보를 설명하는 주석을 추가하여 코드의 가독성과 유지 보수성을 향상시킬 수 있습니다.',93),
(197,60925343,7,'O(T)','프로그램은 T개의 테스트 케이스를 반복하며, 각 테스트 케이스마다 두 정수를 더하는 상수 시간 연산을 수행합니다. 따라서 시간 복잡도는 테스트 케이스 수에 선형적이며, O(T)입니다.',100,'이 코드는 이해하기 쉽고 유지보수하기 쉬운 간단하고 직관적인 구현이 있습니다.','없습니다.','이 코드의 시간 복잡도는 이미 최적화되어 있습니다.','O(1)','프로그램은 한 번에 두 개의 정수 (A와 B)와 A와 B의 합만 저장하면 됩니다. 따라서 공간 복잡도는 상수이며 O(1)입니다.',100,'이 코드는 최소한의 메모리를 사용하며 공간 사용 측면에서 효율적입니다.','없습니다.','이 코드의 공간 복잡도는 이미 최적입니다.',80,'1. 단일 문자 변수 대신 더 구체적인 변수 이름을 사용하세요. 예를 들어, \'N\' 대신 \'numTestCases\', \'i\' 대신 \'testCaseNum\', \'a\' 대신 \'firstNum\', \'b\' 대신 \'secondNum\'을 사용하세요.\n2. 테스트 케이스를 반복하는 데 for 루프 대신 foreach 루프를 사용하는 것이 코드를 더 읽기 쉽게 만들고 off-by-one 오류의 위험을 줄일 수 있습니다.\n3. Scanner 객체를 수동으로 닫는 대신 try-with-resources를 사용하여 자동으로 닫으세요.\n4. \'Main\' 클래스와 같은 더 구체적인 이름을 사용하세요.\n5. 코드의 목적과 복잡한 로직을 설명하는 주석을 추가하는 것이 좋습니다.\n6. 일반적인 Exception 클래스를 catch하는 대신 더 구체적인 예외를 사용하세요.\n7. Scanner 객체에서 하나씩 읽는 대신 배열이나 ArrayList와 같은 더 효율적인 데이터 구조를 사용하세요.\n8. 비정상적인 입력(정수가 아닌 값 또는 지정된 범위를 벗어난 값)에 대한 오류 처리를 추가하는 것이 좋습니다.\n9. 두 수의 합을 메인 메소드에서 인라인으로 계산하는 대신 별도의 메소드를 사용하세요.\n10. \'sc\' Scanner 객체와 같은 더 구체적인 이름을 사용하세요.',93),
(198,60924749,4,'O(NM)','코드에는 크기가 N x M인 전체 행렬을 반복하는 두 개의 중첩된 루프가 있습니다. 이 루프 내에서 배열 초기화 및 최소 계산과 같은 상수 시간 작업이 있습니다. 따라서 코드의 시간 복잡도는 O(NM)입니다.',100,'이 코드는 이미 시간 복잡도 측면에서 최적화되어 있습니다.','없습니다.','없습니다.','O(NM)','이 코드는 입력 행렬과 동적 프로그래밍 테이블을 저장하기 위해 크기가 N x M인 2개의 2D 배열과 크기가 N x M x 3인 3D 배열을 사용합니다. 따라서 코드의 공간 복잡도는 O(NM)입니다.',56,'이 코드는 문제를 해결하는 데 필요한 최소한의 공간을 사용합니다.','코드의 공간 사용량이 공간 제한에 근접합니다.','1. 동적 프로그래밍 테이블을 저장하기 위해 3D 배열 대신 N x 3 크기의 2D 배열을 사용하세요. 이렇게 하면 공간 사용량이 O(NM)에서 O(N)으로 줄어듭니다.\n2. 동적 프로그래밍 테이블을 저장하기 위해 롤링 배열을 사용하세요. 이렇게 하면 공간 사용량이 O(NM)에서 O(M)으로 줄어듭니다.\n3. 동적 프로그래밍 테이블을 저장하기 위해 비트셋을 사용하세요. 이렇게 하면 공간 사용량이 O(NM)에서 O(NM/32)으로 줄어들지만, 비트 연산 때문에 시간 복잡도가 증가할 수 있습니다.',70,'1. \'n\', \'m\', 및 \'arr\'과 같은 약어 대신 더 구체적인 변수 이름을 사용하세요.\n2. 중첩된 for 루프 대신 Arrays.fill() 메서드를 사용하여 dp 배열의 모든 값을 1000001로 설정하세요.\n3. 1000001과 같은 매직 넘버를 사용하지 마세요. 대신 설명적인 이름의 상수 변수를 정의하세요.\n4. \'result\' 변수에 대해 더 구체적인 이름을 사용하는 것이 좋습니다.\n5. 중첩된 for 루프 대신 Arrays.stream() 메서드를 사용하여 배열을 평면화하고 min() 메서드를 사용하여 최소값을 찾으세요.\n6. 코드를 더 작고 관리하기 쉬운 함수로 분해하여 가독성과 유지 관리성을 향상시키세요.\n7. 전체 배열을 반복하는 대신 우선순위 큐와 같은 더 효율적인 데이터 구조를 사용하여 최소값을 저장하고 검색하세요.\n8. 가독성을 향상시키기 위해 일관된 공백과 들여쓰기를 사용하세요.\n9. 코드에 가치를 추가하지 않는 불필요한 주석을 피하세요.',75),
(199,60925423,12,'O(M*N)','이 코드는 전체 지도를 한 번 탐색하는 데 깊이 우선 탐색 알고리즘을 사용하며, 이는 O(M*N) 시간 복잡도를 가집니다. DFS 함수는 지도의 각 셀에 대해 호출되며, 각 셀은 한 번만 방문됩니다. 시간 복잡도는 지도 내 셀의 수에 비례하며, 이는 M*N입니다.',98,'이 코드는 지도를 탐색하고 가능한 경로의 수를 찾기 위해 DFS 알고리즘을 올바르게 구현합니다. 코드는 중복 계산을 피하고 성능을 향상시키기 위해 메모이제이션을 사용합니다.','코드는 재귀를 사용하며, 큰 입력에 대해 스택 오버플로 오류를 일으킬 수 있습니다. 코드는 성능 최적화를 위해 어떠한 라이브러리나 내장 함수도 활용하지 않습니다.','1. 대규모 입력에 대한 스택 오버플로 오류를 피하기 위해 재귀 대신 반복적인 접근 방식을 사용하세요.\n2. 최단 경로를 찾고 성능을 향상시키기 위해 깊이 우선 탐색 대신 너비 우선 탐색 알고리즘을 사용하세요.\n3. 높이가 낮은 셀을 우선적으로 처리하고 탐색하는 우선순위 큐를 사용하면 특정 경우에 성능을 향상시킬 수 있습니다.','O(M*N)','이 코드는 맵의 각 셀에 대한 가능한 경로 수를 저장하기 위해 2D 배열을 사용하며, 이는 O(M*N) 공간 복잡도를 가집니다. 방문한 셀을 추적하기 위해 visited 배열도 사용되며, 이 또한 O(M*N) 공간 복잡도를 가집니다. 공간 복잡도는 M*N의 셀 수에 비례합니다.',100,'코드는 중복 계산을 피하고 공간 복잡도를 개선하기 위해 메모이제이션을 사용합니다. 코드는 불필요한 데이터 구조나 변수를 사용하지 않습니다.','이 코드는 2D 배열을 저장하기 위해 많은 메모리를 사용하므로 대규모 입력에 대해 메모리 오류가 발생할 수 있습니다. 이 코드는 공간 복잡도를 최적화하기 위해 어떠한 라이브러리나 내장 함수도 활용하지 않습니다.','1. 지도의 각 셀에 대한 가능한 경로 수를 저장하기 위해 2D 배열 대신 1D 배열을 사용하여 공간 복잡도를 M 배 감소시킬 수 있습니다.\n2. 방문한 셀을 저장하기 위해 불리언 배열 대신 비트셋을 사용하여 공간 복잡도를 8 배 감소시킬 수 있습니다.\n3. 각 셀에 필요한 정보만 저장하는 동적 프로그래밍 접근 방식을 사용하여 공간 복잡도를 M 또는 N 배 감소시킬 수 있습니다.',80,'1. 약어 대신 더 구체적인 변수 이름을 사용하세요. 예를 들어, \"map\" 대신 \"heightMap\", \"y\" 대신 \"currentY\"를 사용하세요.\n2. \"ny\"와 \"nx\"와 같은 불필요한 변수를 제거하고 코드에서 직접 값을 사용하세요.\n3. 코드에 하드코딩하지 말고, 값 -1에 대한 상수를 사용하세요.\n4. BufferedReader와 BufferedWriter를 자동으로 닫기 위해 try-with-resources 문을 사용하세요.\n5. 성능을 높이기 위해 BufferedWriter 대신 StringBuilder를 사용하세요.\n6. \"dp\" 배열의 초기화를 반복을 피하기 위해 별도의 메소드로 통합하세요.\n7. \"DFS\" 대신 메소드가 하는 일을 나타내는 더 구체적인 메소드 이름을 사용하세요.\n8. 성능을 향상시키기 위해 재귀 대신 PriorityQueue와 같은 더 효율적인 데이터 구조를 사용하세요.\n9. for 루프에서 \"i\" 대신 더 구체적인 변수 이름을 사용하세요.\n10. 코드와 알고리즘의 목적을 설명하는 주석을 추가하세요.',92),
(200,60926350,7,'O(T)','프로그램은 T개의 테스트 케이스를 반복하며, 각 테스트 케이스마다 두 정수를 더하는 상수 시간 연산을 수행합니다. 따라서 시간 복잡도는 테스트 케이스 수에 선형적이며, O(T)입니다.',100,'이 코드는 이해하기 쉽고 유지보수하기 쉬운 간단하고 직관적인 구현이 있습니다.','없습니다.','이 코드의 시간 복잡도는 이미 최적화되어 있습니다.','O(1)','프로그램은 한 번에 두 개의 정수 (A와 B)와 A와 B의 합만 저장하면 됩니다. 따라서 공간 복잡도는 상수이며 O(1)입니다.',100,'이 코드는 최소한의 메모리를 사용하며 공간 사용 측면에서 효율적입니다.','없습니다.','이 코드의 공간 복잡도는 이미 최적입니다.',80,'1. 단일 문자 변수 대신 더 구체적인 변수 이름을 사용하세요. 예를 들어, \'N\' 대신 \'numTestCases\', \'i\' 대신 \'testCaseNum\', \'a\' 대신 \'firstNum\', \'b\' 대신 \'secondNum\'을 사용하세요.\n2. 테스트 케이스를 반복하는 for 루프 대신 foreach 루프를 사용하여 코드를 더 읽기 쉽고 off-by-one 오류를 줄일 수 있습니다.\n3. Scanner 객체를 수동으로 닫는 대신 try-with-resources를 사용하여 자동으로 닫으세요.\n4. \'Main\' 클래스와 같은 더 구체적인 이름을 사용하세요. 예를 들어 \'SumOfTwoNumbers\'와 같은 이름을 사용할 수 있습니다.\n5. 코드의 목적과 복잡한 로직을 설명하는 주석을 추가하는 것이 좋습니다.\n6. 일반적인 Exception 클래스를 catch하는 대신 더 구체적인 예외를 사용하세요.\n7. Scanner 객체에서 하나씩 읽는 대신 배열이나 ArrayList와 같은 더 효율적인 데이터 구조를 사용하세요.\n8. 음수나 0에서 10 사이의 범위를 벗어난 입력에 대한 오류 처리를 추가하는 것이 좋습니다.\n9. 두 수의 합을 메인 메소드에서 인라인으로 계산하는 대신 별도의 메소드를 사용하세요.\n10. \'sc\' Scanner 객체와 같은 더 구체적인 이름을 사용하세요. 예를 들어 \'inputScanner\'와 같은 이름을 사용할 수 있습니다.',93),
(201,48230117,2,'O(N^2)','이 코드는 N x N 크기의 그리드 전체를 탐색하기 위해 두 개의 깊이 우선 탐색(DFS) 알고리즘을 사용합니다. 각 DFS 알고리즘은 각 셀을 최대 한 번씩 방문하며, 이로 인해 시간 복잡도는 O(N^2)가 됩니다.',100,'이 코드는 그래프와 그리드를 탐색하는 데 효율적인 DFS 알고리즘을 사용합니다. 또한 영역을 식별하는 데 간단하고 직관적인 방법을 사용합니다.','코드는 너비 우선 탐색(BFS)과 같은 최적화된 알고리즘을 사용하여 개선될 수 있습니다. 이는 특정 유형의 그래프와 격자에 대해 더 효율적일 수 있습니다.','1. 그리드를 탐색할 때 DFS 대신 BFS를 사용하세요. BFS는 넓이 우선 방식으로 노드를 방문하기 때문에 연결된 구성 요소가 많은 그리드에서 더 효율적일 수 있습니다. 이는 불필요한 방문 수를 줄일 수 있습니다.\n2. 연결된 구성 요소를 추적하기 위해 분리 집합 데이터 구조를 사용하세요. 이를 통해 연결된 구성 요소를 병합하는 union-find 연산을 사용하여 시간 복잡도를 O(N^2 log N)으로 줄일 수 있습니다.\n3. 영역을 식별하기 위해 홍수 채우기 알고리즘을 사용하세요. 이를 통해 각 영역을 고유한 색상으로 채우고 고유한 색상의 수를 계산하여 시간 복잡도를 O(N^2)으로 줄일 수 있습니다.\n4. 그리드를 작은 하위 그리드로 분할하고 재귀적으로 영역을 식별하기 위해 분할 정복 접근 방식을 사용하세요. 이를 통해 하위 그리드의 크기를 줄여 시간 복잡도를 O(N^2 log N)으로 줄일 수 있습니다.\n5. 이전 DFS 또는 BFS 방문 결과를 캐시하기 위해 메모이제이션을 사용하세요. 이를 통해 이전에 방문한 노드를 다시 방문하지 않아 시간 복잡도를 줄일 수 있습니다.','O(N^2)','이 코드는 전체 N x N 그리드를 메모리에 저장하여 순회 및 영역 식별을 수행합니다. 이로 인해 공간 복잡도는 O(N^2)가 됩니다.',100,'이 코드는 메모리에 그리드를 저장하기 위해 간단하고 직관적인 방법을 사용합니다. 이는 탐색과 영역 식별을 수행하는 데 필요합니다.','코드는 희소 그리드의 메모리 사용량을 줄일 수 있는 압축 희소 행렬(CSR)과 같은 더 메모리 효율적인 데이터 구조를 사용하여 개선될 수 있습니다.','1. 그리드를 메모리에 저장하기 위해 압축 희소 행렬(CSR)을 사용하세요. 이렇게 하면 0이 아닌 요소와 그 인덱스만 저장하여 희소 그리드의 메모리 사용량을 줄일 수 있습니다.\n2. 불리언 배열 대신 방문한 노드를 저장하기 위해 비트셋을 사용하세요. 이렇게 하면 각 노드를 하나의 비트로 표현하여 바이트 대신 메모리 사용량을 줄일 수 있습니다.\n3. 전체 그리드를 메모리에 저장하지 않고도 영역을 식별하기 위해 인플레이스 알고리즘을 사용하세요. 이렇게 하면 그리드를 그 자리에서 수정하여 공간 복잡도를 O(1)로 줄일 수 있습니다.\n4. 그리드를 작은 하위 그리드로 분할하고 재귀적으로 영역을 식별하기 위해 분할 정복 접근법을 사용하세요. 이렇게 하면 하위 그리드의 크기를 줄여 공간 복잡도를 O(log N)으로 줄일 수 있습니다.',70,'1. \"N\" 및 \"dx\", \"dy\"와 같은 약어 대신 더 구체적인 변수 이름을 사용하세요.\n2. 코드에서 사용되지 않으므로 불필요한 ArrayList \"answer\"를 제거하세요.\n3. 두 개의 dfs 함수를 하나로 결합하여 두 가지 경우를 구분하기 위해 추가 매개변수를 전달하세요.\n4. 성능을 향상시키기 위해 boolean 배열 대신 방문한 노드를 추적하기 위해 Set을 사용하세요.\n5. BufferedReader를 수동으로 닫는 대신 try-with-resources를 사용하여 자동으로 닫으세요.\n6. 가독성을 향상시키기 위해 여러 if-else 문 대신 switch 문을 사용하세요.\n7. \"map\" 변수와 같은 더 구체적인 이름을 사용하세요. 예를 들어 \"pictureGrid\"와 같은 이름을 사용할 수 있습니다.\n8. dfs 함수에서 \"a\" 매개변수와 같은 더 구체적인 이름을 사용하세요. 예를 들어 \"currentColor\"와 같은 이름을 사용할 수 있습니다.\n9. \"cnt\" 및 \"cnt1\" 변수와 같은 더 구체적인 이름을 사용하세요. 예를 들어 \"색맹이 있는 영역\" 및 \"색맹이 없는 영역\"과 같은 이름을 사용할 수 있습니다.\n10. 모듈성과 가독성을 향상시키기 위해 dfs 함수를 별도의 클래스나 메서드로 추출하는 것을 고려하세요.',90),
(202,60630938,15,'O(K)','코드는 K개의 명령어를 반복하며 각 명령어에 대해 상수 시간 연산을 수행합니다. 따라서 시간 복잡도는 O(K)입니다.',100,'이 코드는 이미 최적화되어 있으며 각 명령에 대해 상수 시간 작업을 수행합니다.','없습니다.','없습니다.','O(1)','이 코드는 주사위와 지도의 상태를 저장하기 위해 상수 개수의 변수만 사용합니다. 따라서 공간 복잡도는 O(1)입니다.',100,'이 코드는 주사위와 지도의 상태를 저장하기 위해 최소한의 메모리를 사용합니다.','없습니다.','없습니다.',70,'1. \'um\', \'N\', \'M\', \'K\', \'py\', \'px\', \'arr\'와 같은 전역 변수 사용을 피하고, 대신 필요한 함수에 매개 변수로 전달하세요.\n2. \'d\', \'m\', \'ny\', \'nx\', \'ord\' 등과 같은 변수 이름 대신 더 구체적인 변수 이름을 사용하세요. 이렇게 하면 코드를 더 읽기 쉽고 이해하기 쉽게 만들 수 있습니다.\n3. \'arr\' 배열의 크기를 하드코딩하는 대신 동적 메모리 할당을 사용하여 크기가 \'N\' x \'M\'인 2D 배열을 만드세요.\n4. \'dice_change\' 함수에서 if-else 문 대신 switch 문을 사용하여 코드를 더 읽기 쉽고 유지 보수하기 쉽게 만드세요.\n5. 값의 주사위 면을 저장하기 위해 unordered_map 대신 vector를 사용하세요. 이렇게 하면 코드가 단순화되고 성능이 향상됩니다.\n6. 값의 실수적인 수정을 방지하기 위해 가능한 경우 const 변수를 사용하세요.\n7. \'init\', \'input\', \'solve\' 등과 같은 함수 이름 대신 더 의미 있는 함수 이름을 사용하세요. 이렇게 하면 코드를 더 읽기 쉽고 이해하기 쉽게 만들 수 있습니다.\n8. 코드의 가독성을 높이기 위해 더 많은 공백을 사용하세요. 예를 들어 쉼표 뒤와 연산자 주변에 공백을 추가하세요.\n9. 코드의 목적과 작동 방식을 설명하는 더 많은 주석을 사용하세요. 이렇게 하면 다른 개발자들이 코드를 더 잘 이해할 수 있습니다.\n10. 잘못된 입력이나 예기치 않은 동작의 경우 코드가 충돌하거나 잘못된 결과를 생성하지 않도록 더 많은 오류 처리를 사용하세요.',90),
(203,38682815,1,'O(N log N)','알고리즘은 집들의 좌표를 정렬하는 것으로 시작합니다. 이 작업은 O(N log N) 시간이 소요됩니다. 그런 다음, 정렬된 좌표에서 이진 검색을 수행하여 두 가장 가까운 라우터 간의 최대 거리를 찾습니다. 이진 검색은 O(log N) 시간이 소요됩니다. 따라서 전체 시간 복잡도는 O(N log N)입니다.',100,'사용자의 코드는 이 문제에 대한 최적 알고리즘을 구현하며, 시간 복잡도는 O(N log N)입니다.','없습니다.','사용자의 코드는 이미 최적화되어 있으며 시간 복잡도 측면에서 더 개선될 수 없습니다.','O(N)','알고리즘은 집의 좌표를 저장하기 위한 배열이 필요하며, 이는 O(N) 공간을 차지합니다. 이진 검색 또는 정렬에 대한 추가 공간은 필요하지 않습니다. 따라서 전체 공간 복잡도는 O(N)입니다.',100,'사용자의 코드는 문제를 해결하는 데 필요한 최소한의 공간을 사용하며, 공간 복잡도는 O(N)입니다.','없습니다.','사용자의 코드는 이미 최적화되어 있으며 공간 복잡도 측면에서 더 개선될 수 없습니다.',70,'1. 약어 대신 더 구체적인 변수 이름을 사용하세요. 예를 들어, \"cnt\" 대신 \"count\"를 사용하세요.\n2. 집들을 반복하려면 while 루프 대신 range 함수와 함께 for 루프를 사용하세요. 이렇게 하면 코드를 더 읽기 쉽게 만들고 무한 루프의 위험을 줄일 수 있습니다.\n3. 수동으로 구현하는 대신 Python 표준 라이브러리에서 이진 검색 함수를 사용하세요. 이렇게 하면 코드를 더 효율적으로 만들고 오류의 위험을 줄일 수 있습니다.\n4. 각 함수와 코드 블록의 목적을 설명하는 주석을 추가하세요. 이렇게 하면 코드를 더 읽기 쉽게 만들고 다른 개발자들이 이해하기 쉽게 됩니다.\n5. \"check_space\" 대신 더 구체적인 함수 이름을 사용하세요. 예를 들어, \"count_houses_within_range\"를 사용하여 함수의 목적을 더 명확하게 만들 수 있습니다.\n6. 코드 블록을 구분하고 가독성을 높이기 위해 더 많은 공백을 사용하세요. 예를 들어, import 문 다음과 main 함수 이전에 빈 줄을 추가하세요.\n7. \"home\" 리스트를 만들기 위해 for 루프 대신 리스트 컴프리헨션을 사용하세요. 이렇게 하면 코드가 더 간결하고 읽기 쉬워집니다.\n8. 입력 값에 대해 더 구체적인 변수 이름을 사용하세요. 예를 들어, \"n\" 대신 \"num_houses\"를 사용하고 \"c\" 대신 \"num_routers\"를 사용하세요.\n9. 메인 함수와 입력 및 출력 매개변수의 목적을 설명하는 독스트링을 사용하세요. 이렇게 하면 코드가 더 자체 문서화되어 다른 개발자들이 이해하기 쉬워집니다.\n10. 이진 검색 루프에서 왼쪽과 오른쪽 변수에 대해 더 구체적인 변수 이름을 사용하세요. 예를 들어, \"min_distance\"와 \"max_distance\"를 사용하여 변수의 목적을 더 명확하게 만들 수 있습니다.',90),
(204,60932851,7,'O(T)','프로그램은 T개의 테스트 케이스를 반복해야 하며, 각 테스트 케이스마다 두 정수를 더하는 상수 시간 연산을 수행합니다. 따라서 시간 복잡도는 테스트 케이스 수에 선형적이며, O(T)입니다.',100,'이 코드는 이미 최적화되어 있으며 예상된 시간 복잡도를 가지고 있습니다.','없습니다.','사용자의 코드는 이미 최적화되어 있으며 시간 복잡도를 개선할 제안이 없습니다.','O(1)','프로그램은 한 번에 두 개의 정수 (A와 B)와 A와 B의 합만 저장하면 됩니다. 따라서 공간 복잡도는 상수이며 O(1)입니다.',100,'이 코드는 이미 최적화되어 있으며 예상된 공간 복잡도를 가지고 있습니다.','없습니다.','사용자의 코드는 이미 최적화되어 있으며, 공간 복잡도를 개선할 제안이 없습니다.',80,'1. 단일 문자 변수 대신 더 구체적인 변수 이름을 사용하세요. 예를 들어, \'N\' 대신 \'numTestCases\', \'i\' 대신 \'testCaseNum\', \'a\' 대신 \'firstNum\', \'b\' 대신 \'secondNum\'을 사용하세요.\n2. 테스트 케이스를 반복하는 for 루프 대신 foreach 루프를 사용하는 것이 코드를 더 읽기 쉽게 만들고 off-by-one 오류의 위험을 줄일 수 있습니다.\n3. try-with-resources를 사용하여 프로그램 끝에서 수동으로 닫는 대신 Scanner 객체를 자동으로 닫을 수 있습니다. 이렇게 하면 코드가 더 간결해지고 리소스 누출의 위험을 줄일 수 있습니다.\n4. 일반적인 Exception 클래스를 catch하는 대신 더 구체적인 예외를 사용하는 것이 코드를 더 견고하게 만들고 디버깅을 쉽게 할 수 있습니다.\n5. Scanner에서 하나씩 읽는 대신 배열이나 List와 같은 더 효율적인 데이터 구조를 사용하여 테스트 케이스를 저장하는 것이 Scanner.nextInt() 메서드를 여러 번 호출하는 오버헤드를 줄일 수 있습니다.\n6. 입력 값이 예상 범위 내에 있는지 확인하는 입력 유효성 검사를 추가하여 예기치 않은 동작을 방지하고 사용자 경험을 개선할 수 있습니다.\n7. 코드의 목적과 구현 세부 정보를 설명하는 주석을 추가하여 코드의 가독성과 유지 보수성을 향상시킬 수 있습니다.',93),
(205,56252197,21,'O(N/4)','for 루프는 N/4번 반복되며, 각 반복은 \"long\"을 출력하는 상수 시간 작업을 수행합니다. 마지막 출력문도 상수 시간이 소요됩니다. 따라서 코드의 시간 복잡도는 O(N/4)입니다.',95,'이 코드는 간단하고 이해하기 쉽습니다. 주어진 문제 설명에 따라 N 바이트까지 저장할 수 있는 정수 데이터 유형의 이름을 올바르게 출력합니다.','코드의 시간 복잡도가 최적이 아닙니다. 문제를 상수 시간에 해결할 수 있지만, 현재 구현은 선형 시간이 소요됩니다.','1. \"long\"을 N/4번 출력하기 위해 루프를 사용하는 대신, N을 4로 나눈 후 문자열 곱셈을 사용하여 \"long\"을 그만큼 출력할 수 있습니다. 이렇게 하면 시간 복잡도가 O(1)로 줄어듭니다.\n2. 정수 데이터 유형과 해당 바이트 크기를 저장하기 위해 사전을 사용할 수 있습니다. 그런 다음, 사전에서 N 바이트까지 저장할 수 있는 데이터 유형을 찾아서 해당 이름을 출력할 수 있습니다. 이렇게 하면 시간 복잡도도 O(1)로 줄어듭니다.','O(1)','이 코드는 정수 N과 문자열 \"long\"을 저장하기 위해 일정한 양의 공간만 사용합니다. 사용된 공간은 N의 크기에 따라 달라지지 않으므로 공간 복잡도는 O(1)입니다.',100,'코드의 공간 복잡도는 최적입니다. 그것은 최소한의 가능한 양인 상수 공간만 사용합니다.','없습니다.','코드의 공간 복잡도는 이미 최적이므로 추가적인 개선은 필요하지 않습니다.',70,'1. 단일 문자 변수 대신 더 구체적인 변수 이름을 사용하세요. 예를 들어, \"N\" 대신 \"num_bytes\"를 사용하세요.\n2. for 루프 대신 정수 나눗셈을 사용하여 필요한 \"long\" 데이터 타입의 수를 계산하고 한 줄에 출력하세요.\n3. for 루프 대신 리스트 컴프리헨션을 사용하여 \"long\" 데이터 타입을 생성하는 것을 고려하세요.\n4. 가독성을 높이기 위해 문자열 연결 대신 f-문자열을 사용하세요. 예를 들어, \"long \" 대신 f\"long \"을 사용하세요.\n5. 코드의 목적과 수행되는 계산을 설명하는 주석을 추가하는 것을 고려하세요.\n6. 입력이 4의 배수가 아니거나 주어진 범위를 벗어나는 경우에 대한 오류 처리를 추가하는 것을 고려하세요.',88),
(206,47524740,7,'O(N^3 * K)','사용자의 코드는 문제를 해결하기 위해 무차별 대입 방식을 사용합니다. 이는 K 회전 작업의 모든 가능한 조합을 생성하고 각 조합에 대해 A의 최소값을 계산합니다. 각 조합에 대해 N^2 회전을 수행하며, 이는 O(N^2) 시간이 소요됩니다. 따라서 사용자의 코드의 시간 복잡도는 O(N^2 * K!)이며, K가 최대 6이므로 O(N^3 * K)로 단순화될 수 있습니다.',85,'사용자의 코드는 문제 요구 사항을 올바르게 구현하며, A의 최소 값을 찾기 위해 K 회전 작업의 모든 가능한 조합을 생성합니다.','사용자의 코드는 무차별 대입 방식을 사용하며, 이는 시간 복잡도가 높아 큰 입력에 대해서는 효율적이지 않을 수 있습니다.','1. K 회전 작업의 모든 가능한 조합을 생성하는 대신, 사용자의 코드는 A의 최소값을 계산하는 더 효율적인 방법을 찾을 수 있습니다. 가능한 접근 방법 중 하나는 회전 작업을 시뮬레이션하고 시뮬레이션 중 A의 최소값을 추적하는 것입니다.\n2. 사용자의 코드는 회전 작업 자체를 최적화하기 위해 노력할 수도 있습니다. 각 요소를 하나씩 회전시키는 대신, 더 효율적인 알고리즘을 사용하여 요소의 전체 정사각형을 한 번에 회전시킬 수 있습니다.\n3. 사용자의 코드는 메모이제이션을 사용하여 동일한 값을 여러 번 다시 계산하지 않도록 할 수 있습니다.','O(N*M)','사용자의 코드는 원래 배열 A와 각 회전 작업 후의 배열만 저장하면 됩니다. 따라서 사용자의 코드의 공간 복잡도는 O(N*M)입니다.',100,'사용자의 코드는 최소한의 공간을 사용하며 필요한 데이터만 저장합니다.','사용자 코드와 관련된 공간 복잡도에 대한 나쁜 점은 없습니다.','사용자의 코드는 이미 공간 복잡도 측면에서 최적화되어 있으며 추가적인 개선이 필요하지 않습니다.',70,'1. 약어 대신 더 구체적인 변수 이름을 사용하세요. 예를 들어, \'N\' 대신 \'sizeOfArrayA\'를 사용하세요.\n2. 필요하지 않은 경우에는 정적 변수 사용을 피하고 인스턴스 변수를 사용하세요.\n3. 순열 메소드에서 전체 배열을 복사하는 대신, 배열의 복사본을 회전 메소드의 매개변수로 전달하는 것을 고려하세요.\n4. 방문한 배열에 대해 더 효율적인 데이터 구조를 사용하세요. 예를 들어, HashSet이나 BitSet을 사용하세요.\n5. 순열 메소드에 대해 더 효율적인 알고리즘을 사용하세요. 예를 들어, Heap\'s 알고리즘이나 Johnson-Trotter 알고리즘을 사용하세요.\n6. BufferedReader와 BufferedWriter를 자동으로 닫기 위해 try-with-resources 문을 사용하세요.\n7. 순열 메소드를 더 작고 관리하기 쉬운 메소드로 분할하여 가독성과 유지보수성을 향상시키세요.\n8. \'회전\'과 같은 일반적인 이름 대신 더 의미 있는 메소드 이름을 사용하세요.\n9. 회전 메소드를 위한 별도의 클래스를 사용하여 모듈성과 관심사 분리를 개선하세요.\n10. \'leftX\', \'rightX\', \'topY\', \'bottomY\'와 같은 회전 메소드의 매개변수에 대해 더 구체적인 변수 이름을 사용하세요.',85),
(207,60935478,6,'O(NM)','이 코드는 N x N 크기의 그리드에서 M개의 움직임을 시뮬레이션하는 것을 포함합니다. 각 움직임은 모든 구름을 반복하고 그들의 위치를 업데이트하며, 모든 셀을 반복하고 그들의 물 양을 업데이트하며, 특정 셀에서 물 복제 마법을 수행하고, 특정 셀의 물 양에 따라 새로운 구름을 생성합니다. 따라서 시간 복잡도는 O(NM)입니다.',100,'이 코드는 이미 최적화되어 있으며 불필요한 루프나 연산이 없습니다.','없습니다.','이 코드의 시간 복잡도는 이미 최적화되어 있습니다.','O(N^2)','이 코드는 그리드의 각 셀에 초기 물 양을 저장하고, 각 이동 후 업데이트된 물 양을 저장하기 위해 새로운 그리드를 생성하는 것을 포함합니다. 따라서 공간 복잡도는 O(N^2)입니다.',100,'이 코드는 최소한의 추가 데이터 구조를 사용하며 필요한 정보만 저장합니다.','없습니다.','이 코드의 공간 복잡도는 이미 최적입니다.',70,'1. \"ord\"와 \"n\"과 같이 의미가 불분명한 변수는 사용하지 마십시오.\n2. 코드 가독성을 향상시키기 위해 더 구체적인 변수 이름을 사용하는 것이 좋습니다.\n3. \"cloud_move\" 및 \"cloud_enchant\" 함수에서 반복되는 코드를 리팩토링하여 중복을 줄이십시오.\n4. 구름 위치에 대해 두 개의 별도의 큐를 사용하는 대신, 현재 위치와 다음 위치를 모두 포함하는 구조체의 단일 큐를 사용하는 것이 좋습니다.\n5. \"info_cloud\"에 대해 배열 대신 벡터를 사용하여 동적 크기 조정이 가능하도록 고려하십시오.\n6. 변수의 의도치 않은 수정을 방지하기 위해 \"const\"를 적절하게 사용하십시오.\n7. \"cloud_move\"에서 여러 if 문 대신 switch 문을 사용하여 가독성을 향상시키는 것이 좋습니다.\n8. 코드 가독성과 유지 보수성을 향상시키기 위해 더 구체적인 함수 이름을 사용하십시오.\n9. 메모리 사용량을 줄이기 위해 \"post_cloud\" 배열에 대해 불리언 배열과 같은 더 효율적인 데이터 구조를 사용하는 것이 좋습니다.\n10. 코드 전체에서 일관된 서식을 사용하여 가독성을 향상시키십시오.',90),
(208,48536946,6,'O(M log M)','알고리즘은 각각의 문자열 가격에 따라 M개의 브랜드를 정렬하는 것을 포함하며, 이는 O(M log M) 시간이 소요됩니다. 그런 다음, 알고리즘은 정렬된 브랜드를 반복하고 각 브랜드에서 N개의 문자열을 구매하는 비용을 계산하여 최소 비용을 선택합니다. 이 작업은 O(M) 시간이 소요됩니다. 따라서 전체 시간 복잡도는 O(M log M + M)이며, 이는 O(M log M)으로 단순화됩니다.',100,'이 코드는 문제를 해결하기 위해 간단하고 직관적인 방법을 사용합니다.','없습니다.','1. 모든 M 브랜드를 반복하여 최소 패키지 및 개별 가격을 찾는 대신, 최소 가격을 추적하기 위해 min-heap을 사용하십시오. 이렇게하면 최소 가격을 찾는 데 필요한 시간 복잡도가 O(log M)으로 줄어들고 전체 시간 복잡도가 O(M log M)이 됩니다.\n2. 이제 적어도 N 개의 기타 줄을 구매하는 데 필요한 최소 금액을 찾기 위해 이진 검색을 사용하십시오. 이렇게하면 시간 복잡도가 O(M log N)으로 줄어듭니다.','O(M)','알고리즘은 M개의 브랜드 가격만 저장하면 되므로, O(M) 공간이 소요됩니다. 따라서 공간 복잡도는 O(M)입니다.',100,'이 코드는 문제를 해결하기 위해 최소한의 공간을 사용합니다.','없습니다.','이 코드의 공간 복잡도는 이미 최적입니다.',70,'1. \"st\"와 \"qt\"와 같은 약어 대신 더 구체적인 변수 이름을 사용하세요.\n2. 벡터를 반복하는 두 개의 for 루프를 하나로 결합하여 코드 반복을 줄이세요.\n3. 알고리즘 라이브러리에서 min_element 함수를 사용하여 벡터를 수동으로 반복하는 대신 st와 qt의 최소값을 찾으세요.\n4. 결과와 결과1을 비교하는 if-else 문을 간단하게 만들기 위해 삼항 연산자를 사용하세요.\n5. 성능을 높이기 위해 패키지 가격과 개별 가격을 저장하는 데 벡터 대신 우선순위 큐를 사용하는 것이 좋습니다.',90),
(209,48395207,6,'O(NlogN)','사용자의 코드는 우선순위 큐를 사용하여 입력 배열 A를 원소 값에 따라 내림차순으로 정렬합니다. 우선순위 큐는 삽입 및 삭제 작업에 대해 O(NlogN)의 시간 복잡도를 가집니다. 코드는 N개의 삽입 및 N개의 삭제를 수행하므로 전체 시간 복잡도는 O(NlogN)입니다.',100,'사용자의 코드는 우선순위 큐를 사용하여 입력 배열 A를 원소 값에 따라 내림차순으로 정렬합니다. 이는 배열을 정렬하는 효율적인 방법입니다.','없습니다.','1. 우선순위 큐 대신 퀵소트나 머지소트와 같은 정렬 알고리즘을 사용하여 입력 배열 A를 비내림차순으로 정렬할 수 있습니다. 이렇게 하면 문제에서 요구하는 O(NlogN)의 시간 복잡도를 얻을 수 있습니다.\n2. C++의 내장 정렬 함수를 사용하여 입력 배열 A를 비내림차순으로 정렬할 수도 있습니다. 이렇게 하면 문제에서 요구하는 O(NlogN)의 시간 복잡도를 얻을 수 있습니다.','O(N)','사용자의 코드는 출력 배열 P를 저장하기 위해 크기 N의 배열을 사용합니다. 또한 입력 배열 A를 저장하기 위해 크기 N의 우선순위 큐를 사용합니다. 따라서 코드의 공간 복잡도는 O(N)입니다.',100,'사용자의 코드는 입력 및 출력 배열을 저장하기 위해 최소한의 공간을 사용합니다.','없습니다.','사용자의 코드는 이미 공간 복잡도 면에서 최적화되어 있습니다. 더 이상 개선할 수 없습니다.',70,'1. 변수 이름이 명확하지 않은 것은 피하세요. 예를 들어, 코드에서 \"num1\" 대신 \"current_index\"와 같이 더 구체적인 이름을 사용하세요.\n2. 결과 배열을 1001의 고정 크기로 초기화하는 대신 입력 배열 N의 크기로 초기화하세요. 이렇게 하면 코드가 더 유연해지고 불필요한 메모리 할당을 피할 수 있습니다.\n3. 우선순위 큐 대신 내장된 정렬 함수를 사용하여 입력 배열을 비내림차순으로 정렬하는 것을 고려하세요. 이렇게 하면 코드가 단순화되고 성능이 향상됩니다.\n4. 결과 배열을 반복하는 두 개의 for 루프를 하나로 결합하여 코드를 반복하지 않도록 하세요.\n5. Node 구조체 멤버에 대해 더 구체적인 변수 이름을 사용하는 것을 고려하세요. 예를 들어, \"num\" 대신 \"value\"와 \"index\" 대신 \"position\"을 사용하세요.\n6. 프로그램 실행 중 변경되지 않는 값에 대해 const 변수를 사용하는 것을 고려하세요. 예를 들어, 결과 배열의 크기와 같은 것입니다.\n7. cmp 구조체에 대해 \"NodeComparator\"와 같이 더 구체적인 이름을 사용하는 것을 고려하세요.\n8. 코드의 목적과 논리를 설명하는 주석을 추가하는 것을 고려하세요. 이렇게 하면 코드의 가독성과 유지보수성이 향상됩니다.\n9. main 함수에 대해 \"sortArray\"와 같이 더 구체적인 이름을 사용하는 것을 고려하세요.\n10. 입력 변수 N에 대해 \"arraySize\"와 같이 더 구체적인 이름을 사용하는 것을 고려하세요.',90),
(210,60617442,6,'O(1)','시간 복잡도는 입력의 크기에 의존하지 않는 간단하고 고정된 작업인 \"Hello World!\" 출력 작업 때문에 상수입니다. 코드에는 루프나 재귀 호출이 없으며 출력 작업은 상수 시간이 걸리는 단일 문장입니다.',100,'입력 크기에 관계없이 실행 시간이 일정한 상수 시간을 가지므로 코드의 시간 복잡도가 매우 우수합니다.','코드와 관련된 시간 복잡도에 대한 나쁜 점은 없습니다.','이 코드의 시간 복잡도는 이미 최적화되어 더 개선될 수 없습니다.','O(1)','출력되는 HTML 태그 <p>에는 \"Hello World!\" 텍스트가 고정 크기로 포함되어 있으며 입력 크기에 의존하지 않기 때문에 공간 복잡도는 상수입니다. 코드는 출력에 필요한 고정 크기 이외의 추가 메모리를 사용하지 않습니다.',93,'이 코드는 입력 크기와 관계없이 일정한 양의 메모리를 사용하기 때문에 매우 좋은 공간 복잡도를 가지고 있습니다.','코드의 공간 복잡도와 관련된 나쁜 점은 없습니다.','코드의 공간 복잡도는 이미 최적화되어 더 개선될 수 없습니다.',90,'1. \"using namespace std\" 줄을 제거하고 대신 namespace 오염을 피하기 위해 std::cout 및 std::endl을 사용합니다.\n2. 입력이 필요하지 않으므로 첫 번째 줄 \"problem_input = ...\"을(를) 제거합니다. 이는 불필요합니다.\n3. 코드의 목적과 복잡한 로직을 설명하는 주석을 추가합니다.\n4. 코드를 캡슐화하고 모듈성을 향상시키기 위해 함수를 사용하는 것을 고려합니다.\n5. \"cout\" 대신 더 구체적인 변수 이름을 사용하는 것을 고려합니다.\n6. \"main\" 대신 더 구체적인 함수 이름을 사용하는 것을 고려합니다.\n7. \"Hello World!\" 대신 더 구체적인 출력 메시지를 사용하는 것을 고려합니다.',94),
(211,54903147,6,'O(N^2M^2)','알고리즘은 지도에 건설될 수 있는 3개의 벽의 모든 가능한 조합을 반복해야합니다. 이는 O(NM choose 3) 또는 O(N^2M^2)입니다. 각 조합마다 BFS 알고리즘이 실행되어 안전 지역의 크기를 찾아야하며, 이는 O(NM) 시간이 소요됩니다. 따라서 전체 시간 복잡도는 O(N^2M^2)입니다.',100,'이 코드는 안전 지역의 크기를 찾기 위해 효율적인 BFS 알고리즘을 사용합니다.','이 코드는 3개의 벽의 모든 가능한 조합을 반복하는 무차별 대입 방식을 사용합니다. 이는 큰 입력에 대해서는 시간이 많이 소요될 수 있습니다.','1. 3개의 벽의 모든 가능한 조합을 반복하는 대신, 코드는 백트래킹 접근 방식을 사용하여 유효한 벽 조합만 고려할 수 있습니다. 이렇게 하면 반복 횟수를 줄이고 시간 복잡도를 개선할 수 있습니다.\n2. 코드는 메모이제이션을 사용하여 동일한 벽 조합에 대한 안전 영역의 크기를 다시 계산하지 않도록 할 수 있습니다. 이렇게 하면 시간 복잡도를 더욱 개선할 수 있습니다.','O(NM)','알고리즘은 O(NM) 공간을 차지하는 맵을 저장해야 합니다. 또한 BFS 알고리즘은 방문할 셀들의 큐를 저장해야 하는데, 모든 셀이 안전 지역의 일부인 경우 최악의 경우 O(NM) 공간을 차지할 수 있습니다. 따라서 전체 공간 복잡도는 O(NM)입니다.',100,'이 코드는 BFS를 위한 맵과 큐를 저장하는 데 최적의 공간을 사용합니다.','없습니다.','코드는 이미 공간 복잡도에 대해 최적화되어 있습니다. 추가 개선이 필요하지 않습니다.',70,'1. 약어 대신 더 구체적인 변수 이름을 사용하세요. 예를 들어 \'arr\' 대신 \'map\' 또는 \'grid\'를 사용하세요.\n2. 사용되지 않는 \'de\'와 \'mxscore\'와 같은 불필요한 변수를 제거하세요.\n3. \'visited\'와 \'nzerosub\'와 같은 전역 변수를 사용하지 마세요. 대신, 해당 변수를 사용하는 함수에 매개 변수로 전달하세요.\n4. 초기화 후 수정되지 않는 변수에 대해서는 \'const\' 키워드를 사용하세요.\n5. 명시적으로 유형을 지정하는 대신 \'auto\' 키워드를 사용하여 유형 추론을 하세요.\n6. 불필요한 복사를 피하기 위해 큐에 요소를 삽입할 때 \'push\' 대신 \'emplace\' 함수를 사용하세요.\n7. 벡터에 대해 메모리를 미리 할당하기 위해 \'reserve\' 함수를 사용하여 성능을 향상시키세요.\n8. 크기 또는 인덱스를 나타내는 변수에 대해서는 \'int\' 대신 \'size_t\'를 사용하세요.\n9. 컴파일 시간에 알려진 변수에 대해서는 \'constexpr\'를 사용하세요.\n10. 가능한 경우 인덱스 대신 \'range-based for\' 루프를 사용하여 가독성을 향상시키세요.\n11. 루프 내에서 \'continue\' 문을 사용하지 마세요. 코드를 읽기 어렵게 만들 수 있습니다. 대신, 불필요한 반복을 건너 뛰기 위해 \'if\' 문을 사용하세요.\n12. 타입 안전성과 경계 검사를 위해 C 스타일 배열 대신 \'std::array\'를 사용하세요.\n13. 동적 배열에 대해서는 C 스타일 배열 대신 \'std::vector\'를 사용하세요.\n14. 사용자 정의 \'coord\' 구조체 대신 \'std::pair\'를 사용하세요.\n15. 사용자 정의 함수 포인터를 정의하는 대신 \'std::function\'을 사용하세요.\n16. 불필요한 복사를 피하기 위해 매개 변수를 참조로 전달하기 위해 \'const auto&\'를 사용하세요.\n17. 2D 배열을 함수에 전달하기 위해 \'int arr[10][10]\' 대신 \'const std::vector<std::vector<int>>&\'를 사용하세요.\n18. 배열 크기를 하드 코딩하는 대신 \'std::size\' 함수를 사용하세요.\n19. 최대 값을 찾기 위해 \'if\' 문 대신 \'std::max\' 함수를 사용하세요.\n20. 컨테이너의 요소를 수동으로 합산하는 대신 \'std::accumulate\' 함수를 사용하세요.',90),
(212,54860348,6,'O(NM)','프로그램은 N개의 행과 M개의 열로 표현되는 방의 각 위치를 반복합니다. 로봇 청소기는 각 위치를 최대 한 번씩 방문할 수 있으며, 프로그램의 시간 복잡도는 방의 위치 수에 따라 결정되며, 이는 O(NM)입니다.',100,'프로그램은 로봇 청소기의 움직임을 모방하기 위해 재귀 함수를 사용하며, 이는 문제를 해결하는 효율적인 방법입니다.','없습니다.','사용자의 코드는 이미 최적화되어 있으며 시간 복잡도를 개선할 제안이 없습니다.','O(NM)','프로그램은 방의 각 위치의 상태를 저장해야 합니다. 이는 N개의 행과 M개의 열로 표현됩니다. 따라서 공간 복잡도는 O(NM)입니다. 또한, 프로그램은 로봇 청소기의 현재 위치와 방향을 저장해야 합니다. 이는 상수 공간을 필요로 합니다.',100,'프로그램은 방 상태와 로봇 청소기의 위치와 방향을 저장하는 데 필요한 공간을 제외하고 최소한의 추가 공간을 사용합니다.','없습니다.','사용자의 코드는 이미 최적화되어 있으며, 공간 복잡도를 개선할 제안이 없습니다.',70,'1. 약어 대신 더 구체적인 변수 이름을 사용하세요. 예를 들어, \"rbx\"와 \"rby\" 대신 \"robotX\"와 \"robotY\"를 사용하세요.\n2. 코드에 가치를 더하지 않는 불필요한 주석을 제거하세요.\n3. 방의 크기에 대한 하드코딩된 값을 대신하여 상수 변수를 사용하세요. 이렇게 하면 코드가 더 유연해지고 나중에 수정하기 쉬워집니다.\n4. 방의 행과 열을 반복할 때 일반적인 for 루프 대신 for-each 루프를 사용하세요. 이렇게 하면 코드가 더 간결해지고 읽기 쉬워집니다.\n5. \"robot_clean\" 함수에서 \"work\" 플래그를 나타내는 정수 변수 대신 부울 변수를 사용하세요. 이렇게 하면 코드가 더 읽기 쉽고 이해하기 쉬워집니다.\n6. 로봇을 회전할 때 if-else 문 대신 switch 문을 사용하세요. 이렇게 하면 코드가 더 간결해지고 읽기 쉬워집니다.\n7. 로봇의 방향을 저장하기 위해 배열 대신 벡터를 사용하세요. 이렇게 하면 코드가 더 유연해지고 나중에 수정하기 쉬워집니다.\n8. 같은 코드를 반복하지 않고 위치가 유효한지 확인하기 위해 함수를 사용하세요. 이렇게 하면 코드가 더 간결해지고 읽기 쉬워집니다.\n9. 방향의 수에 대한 하드코딩된 값을 대신하여 상수 변수를 사용하세요. 이렇게 하면 코드가 더 유연해지고 나중에 수정하기 쉬워집니다.\n10. \"rotate\" 변수의 초기값에 대한 하드코딩된 값을 대신하여 상수 변수를 사용하세요. 이렇게 하면 코드가 더 유연해지고 나중에 수정하기 쉬워집니다.',90),
(213,55367223,6,'O(N^3)','코드에는 지도의 각 행과 열을 반복하는 두 개의 중첩 루프가 있으며, 이로 인해 시간 복잡도는 O(N^2)가 됩니다. 이 중첩 루프 내에서는 행 또는 열의 각 셀을 반복하는 또 다른 루프가 있으며, 이로 인해 시간 복잡도는 O(N)이 됩니다. 따라서 코드의 전체 시간 복잡도는 O(N^2 * N) = O(N^3)입니다.',100,'이 코드는 지도의 각 행과 열을 반복하고 길이 L의 경사를 확인하여 통과 가능한 도로를 효율적으로 확인합니다.','코드에는 중첩된 루프 내에 각 행 또는 열의 각 셀을 반복하는 추가 루프가 있어 필요 이상으로 높은 시간 복잡도를 가지고 있습니다.','1. 각 행 또는 열의 셀을 반복하는 대신, 코드는 기울기의 길이와 이전 셀의 높이를 추적할 수 있습니다. 이렇게 하면 추가적인 루프가 필요하지 않으며 시간 복잡도가 O(N^2)로 감소합니다.\n2. 코드는 동적 프로그래밍을 사용하여 각 행과 열의 통과 가능한 도로 수를 저장할 수 있습니다. 이렇게 하면 중복 계산이 제거되고 시간 복잡도가 O(N^2)로 감소합니다.\n3. 코드는 이미 배치된 기울기를 저장하기 위해 해시 테이블을 사용할 수 있습니다. 이렇게 하면 중복 기울기를 확인하는 데 필요한 작업이 제거되고 시간 복잡도가 O(N^2)로 감소합니다.','O(1)','이 코드는 맵의 각 셀의 높이를 저장하기 위해 일정한 양의 공간만 사용하므로, 공간 복잡도는 O(1)입니다.',100,'코드는 필요한 정보만 저장하여 공간을 효율적으로 사용합니다.','없습니다.','이 코드의 공간 복잡도는 이미 최적화되었습니다.',70,'1. \'N\', \'L\', 및 \'arr\'과 같은 전역 변수 사용을 피하십시오. 대신 필요한 함수에 매개 변수로 전달하십시오.\n2. \'n\', \'m\', \'upflag\', 및 \'downflag\' 대신 더 구체적인 변수 이름을 사용하십시오. 이렇게하면 코드가 더 읽기 쉽고 이해하기 쉬워집니다.\n3. \'check\' 함수를 리팩토링하여 코드 반복을 줄이십시오. 각 행과 열을 확인하는 논리를 처리하는 별도의 함수를 만들고 코드를 복제하는 대신 두 번 호출하십시오.\n4. 배열을 반복하는 전통적인 for 루프 대신 범위 기반 for 루프를 사용하는 것이 좋습니다. 이렇게하면 코드가 더 간결하고 읽기 쉬워집니다.\n5. \'101\' 및 \'10\'과 같은 하드 코딩 된 값 대신 상수를 사용하십시오. 이렇게하면 코드가 더 유지 관리 가능하고 미래에 수정하기 쉬워집니다.\n6. 배열 대신 STL 컨테이너 인 벡터를 사용하는 것이 좋습니다. 이렇게하면 코드가 더 단순해지고 유연성이 높아집니다.\n7. \'check\' 대신 더 구체적인 함수 이름을 사용하십시오. 이렇게하면 함수가 무엇을하는지 한눈에 이해하기 쉬워집니다.\n8. 중첩된 if 문 대신 일찍 반환을 사용하여 \'check\' 함수를 리팩토링하십시오. 이렇게하면 코드가 더 읽기 쉽고 이해하기 쉬워집니다.\n9. 도로가 통과 가능한지 여부를 확인하는 논리를 처리하는 별도의 함수를 사용하는 것이 좋습니다. 이렇게하면 코드가 더 모듈화되고 테스트하기 쉬워집니다.\n10. 코드의 가독성을 향상시키기 위해 더 많은 공백을 사용하십시오. 논리적인 코드 블록 사이에 빈 줄을 추가하고 일관된 들여쓰기를 사용하십시오.',90),
(214,60938752,4,'O(n^2)','프로그램은 각 전화번호의 접두사를 확인하기 위해 두 개의 중첩된 루프를 사용합니다. 바깥쪽 루프는 각 전화번호를 반복하고, 안쪽 루프는 각 전화번호의 문자를 반복합니다. 따라서 시간 복잡도는 O(n^2)입니다.',79,'없습니다.','프로그램의 시간 복잡도는 O(n^2)이며, 이는 O(nlogn)의 예상 시간 복잡도보다 나쁩니다.','1. 전화번호를 저장하기 위해 Trie 데이터 구조를 사용하세요. 이렇게 하면 이 문제의 예상 시간 복잡도인 O(nlogn)으로 시간 복잡도를 줄일 수 있습니다.\n2. 접두사를 확인하기 전에 전화번호를 정렬하세요. 이렇게 하면 시간 복잡도를 O(nlogn)으로 줄일 수 있습니다.\n3. 각 전화번호의 접두사를 저장하기 위해 HashSet을 사용하세요. 이렇게 하면 시간 복잡도를 O(n)으로 줄일 수 있지만, 공간 복잡도는 O(n^2)로 증가합니다.\n4. 이진 검색을 사용하여 전화번호가 다른 전화번호의 접두사인지 확인하세요. 이렇게 하면 시간 복잡도를 O(nlogn)으로 줄일 수 있지만, 전화번호를 먼저 정렬해야 합니다.\n5. 전화번호를 저장하기 위해 접미사 트리를 사용하세요. 이렇게 하면 시간 복잡도를 O(n)으로 줄일 수 있지만, 공간 복잡도는 O(n^2)로 증가합니다.','O(n)','프로그램은 전화번호를 배열과 HashSet에 저장합니다. 배열의 크기는 n이며, HashSet의 크기는 최대 n입니다. 따라서 공간 복잡도는 O(n)입니다.',60,'이 프로그램은 O(n)의 공간 복잡도를 가지며, 이 문제에 대한 예상 공간 복잡도입니다.','없습니다.','1. 전화번호를 저장하기 위해 Trie 데이터 구조를 사용하세요. 이렇게 하면 공간 복잡도가 O(nlogn)으로 줄어들지만, 시간 복잡도는 O(nlogn)으로 증가합니다.\n2. 전화번호를 저장하기 위해 접미사 트리를 사용하세요. 이렇게 하면 공간 복잡도가 O(n)으로 줄어들지만, 시간 복잡도는 O(n)으로 증가합니다.',70,'1. 약어 대신 더 구체적인 변수 이름을 사용하세요. 예를 들어, \"tc\" 대신 \"testCases\"를 사용하세요.\n2. 바깥쪽 루프에 레이블을 사용하는 대신 필요할 때 루프를 중단하기 위해 부울 플래그를 사용하세요.\n3. 전화번호를 저장하기 위해 별도의 배열을 만드는 대신 직접 HashSet에 추가할 수 있습니다.\n4. 루프에서 문자열을 연결하는 대신 StringBuilder를 사용하여 성능을 개선하세요.\n5. HashSet 대신 TreeSet을 사용하여 전화번호를 자동으로 정렬하고 가독성을 개선하세요.\n6. BufferedReader를 수동으로 finally 블록에서 닫는 대신 try-with-resources를 사용하여 자동으로 닫으세요.\n7. 전화번호가 일관성이 있는지 확인하는 논리를 별도의 메서드로 추출하여 가독성과 유지 관리성을 개선하세요.\n8. HashSet 및 TreeSet에 대해 \"phoneNumbers\" 및 \"sortedPhoneNumbers\"와 같은 의미 있는 변수 이름을 사용하세요.\n9. 코드의 목적과 복잡한 논리를 설명하는 주석을 추가하는 것이 좋습니다.\n10. 일관된 들여쓰기와 서식을 사용하여 코드의 가독성을 개선하세요.',69),
(215,49888093,7,'O(N^6)','이 코드는 깊이 우선 탐색 알고리즘을 사용하여 그리드를 탐색하며, 각 셀마다 세 가지 가능한 방향을 시도하고 파이프가 해당 방향으로 이동할 수 있는지 확인합니다. 이로 인해 시간 복잡도는 O(3^(N^2))이며, 그리드 크기가 N x N이므로 O(N^6)으로 단순화될 수 있습니다.',90,'이 코드는 그리드를 탐색하고 (1,1)에서 (N,N)으로 파이프를 이동하는 방법의 수를 찾기 위해 깊이 우선 탐색 알고리즘을 올바르게 구현합니다.','코드는 각 셀에 대해 세 가지 가능한 방향을 시도하며, 이로 인해 시간 복잡도가 높아지며 개선할 수 있습니다.','1. 그리드의 각 셀에 도달하는 방법의 수를 저장하기 위해 동적 프로그래밍을 사용하십시오. 이렇게하면 재귀 호출 수가 줄어들고 시간 복잡도가 O(N^2)로 개선됩니다.\n2. 이전 재귀 호출의 결과를 저장하고 중복 계산을 피하기 위해 메모이제이션을 사용하십시오. 이렇게하면 시간 복잡도가 더욱 개선됩니다.\n3. 그리드를 탐색하기 위해 깊이 우선 탐색 대신 너비 우선 탐색을 사용하십시오. 이렇게하면 재귀 호출 수가 줄어들고 시간 복잡도가 O(N^2)로 개선됩니다.','O(N^2)','이 코드는 그리드의 상태를 저장하기 위해 크기가 N x N인 2D 배열과 현재 위치와 파이프의 방향을 저장하기 위해 Pipe 객체를 사용합니다. 이로 인해 공간 복잡도는 O(N^2)가 됩니다.',100,'이 코드는 그리드의 상태를 저장하기 위해 2D 배열을 올바르게 사용하며, 현재 파이프의 위치와 방향을 저장하기 위해 Pipe 객체를 사용합니다.','공간 복잡도는 이미 최적화되어 더 개선될 수 없습니다.','없습니다.',70,'1. 약어 대신 더 구체적인 변수 이름을 사용하세요. 예를 들어, \"r\" 대신 \"row\"를 사용하고, \"c\" 대신 \"column\"을 사용하세요.\n2. 코드에 가치를 추가하지 않는 불필요한 주석을 제거하세요.\n3. BufferedReader를 수동으로 닫는 대신 try-with-resources 문을 사용하여 자동으로 닫으세요.\n4. 값 999에 대한 매직 넘버 대신 상수 변수를 사용하세요.\n5. dfs 메소드 내의 for 루프 안의 코드를 중복을 줄이고 가독성을 높이기 위해 별도의 메소드로 추출하세요.\n6. 입력 배열을 수정하는 대신 방문한 셀을 추적하기 위해 Set을 사용하세요.\n7. ndir의 값을 할당하기 위해 여러 if-else 문 대신 switch 문을 사용하세요.\n8. dfs 메소드의 목적을 나타내는 더 구체적인 이름을 사용하세요.\n9. Pipe 클래스의 목적을 나타내는 더 구체적인 이름을 사용하세요.\n10. 결과 변수가 나타내는 것을 나타내는 더 구체적인 이름을 사용하세요.',86),
(216,47557778,9,'O(2^9)','이 코드는 주어진 아홉 개의 숫자에서 일곱 개의 가능한 모든 조합을 확인하기 위해 무차별 대입 알고리즘을 사용합니다. 아홉 개의 숫자 중에서 일곱 개를 선택할 수 있으므로 가능한 조합의 수는 9개 중 7개를 선택하는 경우의 수인 84개입니다. 따라서 코드의 시간 복잡도는 모든 가능한 조합을 확인하기 때문에 O(2^9)입니다.',95,'이 코드는 100을 더하면 7개의 숫자를 정확하게 찾습니다.','코드의 시간 복잡도는 지수적이며, 더 큰 입력에 대해서는 문제가 될 수 있습니다.','1. 7개 숫자의 모든 가능한 조합을 확인하는 대신, 100을 더하는 일곱 개의 숫자를 찾기 위해 더 효율적인 알고리즘을 사용할 수 있습니다. 그 중 하나는 Two-Pointer 알고리즘으로, 시간 복잡도는 O(n)입니다.\n2. 이 문제를 해결하기 위해 동적 프로그래밍을 사용할 수도 있습니다. 100x9 크기의 표를 만들고 불리언 값으로 채울 수 있습니다. 그런 다음 동적 프로그래밍을 사용하여 100을 더하는 일곱 개의 숫자를 찾을 수 있습니다. 이 알고리즘의 시간 복잡도는 O(900)입니다.\n3. 주어진 아홉 개의 숫자를 오름차순으로 정렬한 다음, 이진 검색 알고리즘을 사용하여 100을 더하는 일곱 개의 숫자를 찾을 수 있습니다. 이 알고리즘의 시간 복잡도는 O(nlogn)입니다.\n4. 해시 테이블을 사용하여 주어진 아홉 개의 숫자를 저장한 다음, 루프를 사용하여 100을 더하는 일곱 개의 숫자를 찾을 수 있습니다. 이 알고리즘의 시간 복잡도는 O(n)입니다.\n5. Meet-in-the-middle 알고리즘을 사용하여 100을 더하는 일곱 개의 숫자를 찾을 수 있습니다. 이 알고리즘의 시간 복잡도는 O(2^(n/2))입니다.\n6. Subset Sum 알고리즘을 사용하여 100을 더하는 일곱 개의 숫자를 찾을 수 있습니다. 이 알고리즘의 시간 복잡도는 O(n*sum)입니다. 여기서 sum은 주어진 모든 숫자의 합입니다.\n7. Branch and Bound 알고리즘을 사용하여 100을 더하는 일곱 개의 숫자를 찾을 수 있습니다. 이 알고리즘의 시간 복잡도는 O(2^n)입니다.\n8. Knapsack 알고리즘을 사용하여 100을 더하는 일곱 개의 숫자를 찾을 수 있습니다. 이 알고리즘의 시간 복잡도는 O(n*sum)입니다. 여기서 sum은 주어진 모든 숫자의 합입니다.\n9. Backtracking 알고리즘을 사용하여 100을 더하는 일곱 개의 숫자를 찾을 수 있습니다. 이 알고리즘의 시간 복잡도는 O(2^n)입니다.\n10. Greedy 알고리즘을 사용하여 100을 더하는 일곱 개의 숫자를 찾을 수 있습니다. 이 알고리즘의 시간 복잡도는 O(nlogn)입니다.','O(1)','이 코드는 주어진 아홉 개의 숫자, 일시적인 일곱 개의 숫자 배열, 일곱 개의 숫자로 이루어진 답변 배열 및 방문한 부울 값 배열을 저장하기 위해 고정된 양의 공간을 사용합니다. 따라서 코드의 공간 복잡도는 O(1)입니다.',100,'이 코드는 문제를 해결하기 위해 고정된 공간을 사용합니다.','없습니다. 코드의 공간 복잡도는 최적입니다.','코드의 공간 복잡도는 이미 최적화되어 있습니다. 더 이상 개선할 수 없습니다.',70,'1. ori, tmp, cnt, sum과 같은 약어 대신 더 구체적인 변수 이름을 사용하세요. 이렇게 하면 코드를 더 읽기 쉽고 이해하기 쉬워집니다.\n2. \"return\"과 같은 불필요한 주석은 dfs 함수의 끝에서 제거하세요. 이는 필요하지 않습니다.\n3. 방문한 요소를 추적하기 위해 boolean 배열을 사용하는 대신, HashSet 또는 Set 데이터 구조를 사용하여 성능을 향상시키고 코드를 단순화하세요.\n4. BufferedReader를 수동으로 닫는 대신 try-with-resources 문을 사용하여 자동으로 닫으세요.\n5. dfs 함수를 더 작고 관리하기 쉬운 함수로 분할하여 가독성과 유지 관리성을 향상시키세요.\n6. i, j, k와 같은 루프 카운터에 의미 있는 변수 이름을 사용하여 코드를 더 읽기 쉽게 만드세요.\n7. 성능을 향상시키기 위해 백트래킹 또는 동적 프로그래밍과 같은 더 효율적인 알고리즘을 사용하는 것을 고려하세요.',88),
(217,60940802,7,'O(M*N*H)','알고리즘은 상자의 각 셀을 한 번씩 방문해야 하며, 최악의 경우 모든 셀이 덜 익은 토마토이므로 알고리즘은 각 상자의 각 셀을 H번씩 방문해야 합니다. 따라서 시간 복잡도는 O(M*N*H)입니다.',100,'이 코드는 미숙한 토마토에서 익은 토마토까지의 최단 경로를 찾기 위해 너비 우선 탐색을 사용하며, 이 문제에 대한 효율적인 알고리즘입니다.','코드의 시간 복잡도와 관련된 주요한 문제점은 없습니다.','1. 큐의 시간 복잡도를 줄이기 위해 우선순위 큐와 같은 더 효율적인 데이터 구조를 사용하여 코드를 최적화할 수 있습니다.\n2. 최단 경로를 찾는 데 더 나은 최악 시간 복잡도를 가진 Dijkstra 알고리즘과 같은 더 효율적인 알고리즘을 사용하여 코드를 최적화할 수 있습니다.\n3. 검색 프로세스를 병렬화하기 위해 멀티 스레딩을 사용하여 작업 부하를 여러 스레드로 분할하여 시간 복잡도를 줄일 수 있습니다.','O(M*N*H)','알고리즘은 상자의 각 셀의 상태를 저장해야 하므로 M*N*H 공간이 필요합니다. 따라서 공간 복잡도는 O(M*N*H)입니다.',100,'이 코드는 문제를 해결하기 위해 각 셀의 상태를 저장하는 데 최소한의 공간을 사용합니다.','코드의 공간 복잡도와 관련된 주요한 문제점은 없습니다.','1. 각 셀의 상태를 저장하는 더 효율적인 데이터 구조인 비트 배열을 사용하여 코드를 최적화할 수 있습니다. 이렇게 하면 각 셀의 상태를 저장하는 데 사용되는 메모리를 줄이므로 공간 복잡도를 줄일 수 있습니다.\n2. A* 검색과 같은 더 효율적인 최단 경로 알고리즘을 사용하여 코드를 최적화할 수 있습니다. 이렇게 하면 검색 트리를 저장하는 데 사용되는 메모리를 줄이므로 공간 복잡도를 줄일 수 있습니다.',70,'1. 단일 문자 변수 대신 더 구체적인 변수 이름을 사용하십시오. 예를 들어, \'C\', \'R\', \'H\' 대신 각각 \'numHorizontalCells\', \'numVerticalCells\', \'numBoxesStacked\'를 사용하십시오.\n2. \'dr\', \'dc\', \'dh\' 배열의 값을 하드코딩하는 대신, 코드를 더 읽기 쉽게하기 위해 상수 또는 열거형을 사용하십시오.\n3. BFS 알고리즘을 메인 메소드에 포함시키는 대신 별도의 메소드를 사용하십시오. 이렇게 하면 코드가 모듈화되어 읽기 쉬워집니다.\n4. 모든 토마토가 익었는지 확인하는 별도의 메소드를 사용하십시오. 이렇게 하면 코드가 모듈화되어 읽기 쉬워집니다.\n5. BufferedReader를 수동으로 닫는 대신 try-with-resources를 사용하십시오.\n6. \'queue\' 변수에 대해 \'tomatoQueue\'와 같은 더 구체적인 이름을 사용하십시오.\n7. \'map\' 변수에 대해 \'tomatoBox\'와 같은 더 구체적인 이름을 사용하십시오.\n8. \'visited\' 변수에 대해 \'isVisited\'와 같은 더 구체적인 이름을 사용하십시오.\n9. \'cur\' 변수에 대해 \'currentTomato\'와 같은 더 구체적인 이름을 사용하십시오.\n10. for 루프에서 \'d\' 변수에 대해 \'direction\'과 같은 더 구체적인 이름을 사용하십시오.\n11. \'check\' 메소드에서 \'result\' 변수에 대해 \'maxRipeningDays\'와 같은 더 구체적인 이름을 사용하십시오.\n12. for 루프에서 \'h\' 변수에 대해 \'boxHeight\'와 같은 더 구체적인 이름을 사용하십시오.\n13. for 루프에서 \'r\' 변수에 대해 \'rowIndex\'와 같은 더 구체적인 이름을 사용하십시오.\n14. for 루프에서 \'c\' 변수에 대해 \'columnIndex\'와 같은 더 구체적인 이름을 사용하십시오.\n15. \'st\' 변수에 대해 \'tokenizer\'와 같은 더 구체적인 이름을 사용하십시오.\n16. \'nr\' 및 \'nc\' 변수에 대해 각각 \'nextRow\' 및 \'nextColumn\'과 같은 더 구체적인 이름을 사용하십시오.\n17. \'nh\' 변수에 대해 \'nextBoxHeight\'와 같은 더 구체적인 이름을 사용하십시오.\n18. \'visited\' 배열에 대해 boolean[][][] 배열 대신 boolean 배열과 같은 더 효율적인 데이터 구조를 사용하십시오.\n19. \'map\' 배열에 대해 int[][][] 배열 대신 List<List<List<Integer>>>와 같은 더 효율적인 데이터 구조를 사용하십시오.\n20. \'tomatoQueue\' 변수에 대해 Queue<int[]> 대신 LinkedList<int[]>와 같은 더 효율적인 데이터 구조를 사용하십시오.\n21. \'tomatoQueue\' 변수를 초기화하는 더 효율적인 방법으로, \'map\' 배열 전체를 반복하는 대신 익은 토마토로 초기화하십시오.',90);
/*!40000 ALTER TABLE `gpt_solution` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `problem`
--

DROP TABLE IF EXISTS `problem`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `problem` (
  `problem_id` bigint(20) NOT NULL AUTO_INCREMENT,
  `problem_title` text DEFAULT NULL,
  `problem_level` bigint(20) DEFAULT NULL,
  `problem_desc` text DEFAULT NULL,
  `problem_input` text DEFAULT NULL,
  `problem_output` text DEFAULT NULL,
  `problem_tag` text DEFAULT NULL,
  `problem_limit` text DEFAULT NULL,
  `problem_time_limit` text DEFAULT NULL,
  `problem_space_limit` text DEFAULT NULL,
  PRIMARY KEY (`problem_id`)
) ENGINE=InnoDB AUTO_INCREMENT=25315 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `problem`
--

LOCK TABLES `problem` WRITE;
/*!40000 ALTER TABLE `problem` DISABLE KEYS */;
INSERT INTO `problem` VALUES
(1000,'A+B',1,'<p>두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오.</p>','<p>첫째 줄에 A와 B가 주어진다. (0 < A, B < 10)</p>','<p>첫째 줄에 A+B를 출력한다.</p>','[\"수학\", \"구현\", \"사칙연산\"]','[]','2 초','128 MB'),
(1001,'A-B',1,'<p>두 정수 A와 B를 입력받은 다음, A-B를 출력하는 프로그램을 작성하시오.</p>','<p>첫째 줄에 A와 B가 주어진다. (0 < A, B < 10)</p>','<p>첫째 줄에 A-B를 출력한다.</p>','[\"수학\", \"구현\", \"사칙연산\"]','[]','2 초 ','128 MB'),
(1002,'터렛',8,'<p>조규현과 백승환은 터렛에 근무하는 직원이다. 하지만 워낙 존재감이 없어서 인구수는 차지하지 않는다. 다음은 조규현과 백승환의 사진이다.</p>\n\n<p style=\"text-align: center;\"><img alt=\"\" src=\"\" style=\"height: 135px; width: 136px;\"></p>\n\n<p>이석원은 조규현과 백승환에게 상대편 마린(류재명)의 위치를 계산하라는 명령을 내렸다. 조규현과 백승환은 각각 자신의 터렛 위치에서 현재 적까지의 거리를 계산했다.</p>\n\n<p>조규현의 좌표 (x<sub>1</sub>, y<sub>1</sub>)와 백승환의 좌표 (x<sub>2</sub>, y<sub>2</sub>)가 주어지고, 조규현이 계산한 류재명과의 거리 r<sub>1</sub>과 백승환이 계산한 류재명과의 거리 r<sub>2</sub>가 주어졌을 때, 류재명이 있을 수 있는 좌표의 수를 출력하는 프로그램을 작성하시오.</p>','<p>첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 다음과 같이 이루어져 있다.</p>\n\n<p>한 줄에 x<sub>1</sub>, y<sub>1</sub>, r<sub>1</sub>, x<sub>2</sub>, y<sub>2</sub>, r<sub>2</sub>가 주어진다. x<sub>1</sub>, y<sub>1</sub>, x<sub>2</sub>, y<sub>2</sub>는 -10,000보다 크거나 같고, 10,000보다 작거나 같은 정수이고, r<sub>1</sub>, r<sub>2</sub>는 10,000보다 작거나 같은 음이 아닌 정수이다.</p>','<p>각 테스트 케이스마다 류재명이 있을 수 있는 위치의 수를 출력한다. 만약 류재명이 있을 수 있는 위치의 개수가 무한대일 경우에는 -1을 출력한다.</p>','[\"수학\", \"기하학\", \"많은 조건 분기\"]','[]','2 초','128 MB'),
(1003,'피보나치 함수',8,'<p>다음 소스는 N번째 피보나치 수를 구하는 C++ 함수이다.</p>\n\n<pre>int fibonacci(int n) {\n    if (n == 0) {\n        printf(\"0\");\n        return 0;\n    } else if (n == 1) {\n        printf(\"1\");\n        return 1;\n    } else {\n        return fibonacci(n‐1) + fibonacci(n‐2);\n    }\n}\n</pre>\n\n<p><code>fibonacci(3)</code>을 호출하면 다음과 같은 일이 일어난다.</p>\n\n<ul>\n	<li><code>fibonacci(3)</code>은 <code>fibonacci(2)</code>와 <code>fibonacci(1)</code> (첫 번째 호출)을 호출한다.</li>\n	<li><code>fibonacci(2)</code>는 <code>fibonacci(1)</code> (두 번째 호출)과 <code>fibonacci(0)</code>을 호출한다.</li>\n	<li>두 번째 호출한 <code>fibonacci(1)</code>은 1을 출력하고 1을 리턴한다.</li>\n	<li><code>fibonacci(0)</code>은 0을 출력하고, 0을 리턴한다.</li>\n	<li><code>fibonacci(2)</code>는 <code>fibonacci(1)</code>과 <code>fibonacci(0)</code>의 결과를 얻고, 1을 리턴한다.</li>\n	<li>첫 번째 호출한 <code>fibonacci(1)</code>은 1을 출력하고, 1을 리턴한다.</li>\n	<li><code>fibonacci(3)</code>은 <code>fibonacci(2)</code>와 <code>fibonacci(1)</code>의 결과를 얻고, 2를 리턴한다.</li>\n</ul>\n\n<p>1은 2번 출력되고, 0은 1번 출력된다. N이 주어졌을 때, <code>fibonacci(N)</code>을 호출했을 때, 0과 1이 각각 몇 번 출력되는지 구하는 프로그램을 작성하시오.</p>','<p>첫째 줄에 테스트 케이스의 개수 T가 주어진다.</p>\n\n<p>각 테스트 케이스는 한 줄로 이루어져 있고, N이 주어진다. N은 40보다 작거나 같은 자연수 또는 0이다.</p>','<p>각 테스트 케이스마다 0이 출력되는 횟수와 1이 출력되는 횟수를 공백으로 구분해서 출력한다.</p>','[\"다이나믹 프로그래밍\"]','[]','0.25 초 (추가 시간 없음) ','128 MB'),
(1008,'A/B',1,'<p>두 정수 A와 B를 입력받은 다음, A/B를 출력하는 프로그램을 작성하시오.</p>','<p>첫째 줄에 A와 B가 주어진다. (0 < A, B < 10)</p>','<p>첫째 줄에 A/B를 출력한다. 실제 정답과 출력값의 절대오차 또는 상대오차가 10<sup>-9</sup> 이하이면 정답이다.</p>','[\"수학\", \"구현\", \"사칙연산\"]','[]','2 초','128 MB'),
(1012,'유기농 배추',9,'<p>차세대 영농인 한나는 강원도 고랭지에서 유기농 배추를 재배하기로 하였다. 농약을 쓰지 않고 배추를 재배하려면 배추를 해충으로부터 보호하는 것이 중요하기 때문에, 한나는 해충 방지에 효과적인 배추흰지렁이를 구입하기로 결심한다. 이 지렁이는 배추근처에 서식하며 해충을 잡아 먹음으로써 배추를 보호한다. 특히, 어떤 배추에 배추흰지렁이가 한 마리라도 살고 있으면 이 지렁이는 인접한 다른 배추로 이동할 수 있어, 그 배추들 역시 해충으로부터 보호받을 수 있다. 한 배추의 상하좌우 네 방향에 다른 배추가 위치한 경우에 서로 인접해있는 것이다.</p>\n\n<p>한나가 배추를 재배하는 땅은 고르지 못해서 배추를 군데군데 심어 놓았다. 배추들이 모여있는 곳에는 배추흰지렁이가 한 마리만 있으면 되므로 서로 인접해있는 배추들이 몇 군데에 퍼져있는지 조사하면 총 몇 마리의 지렁이가 필요한지 알 수 있다. 예를 들어 배추밭이 아래와 같이 구성되어 있으면 최소 5마리의 배추흰지렁이가 필요하다. 0은 배추가 심어져 있지 않은 땅이고, 1은 배추가 심어져 있는 땅을 나타낸다.</p>\n\n<table class=\"table table-bordered\" style=\"width:40%\">\n	<tbody>\n		<tr>\n			<td style=\"text-align:center; width:4%\"><strong>1</strong></td>\n			<td style=\"text-align:center; width:4%\"><strong>1</strong></td>\n			<td style=\"text-align:center; width:4%\">0</td>\n			<td style=\"text-align:center; width:4%\">0</td>\n			<td style=\"text-align:center; width:4%\">0</td>\n			<td style=\"text-align:center; width:4%\">0</td>\n			<td style=\"text-align:center; width:4%\">0</td>\n			<td style=\"text-align:center; width:4%\">0</td>\n			<td style=\"text-align:center; width:4%\">0</td>\n			<td style=\"text-align:center; width:4%\">0</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center; width:4%\">0</td>\n			<td style=\"text-align:center; width:4%\"><strong>1</strong></td>\n			<td style=\"text-align:center; width:4%\">0</td>\n			<td style=\"text-align:center; width:4%\">0</td>\n			<td style=\"text-align:center; width:4%\">0</td>\n			<td style=\"text-align:center; width:4%\">0</td>\n			<td style=\"text-align:center; width:4%\">0</td>\n			<td style=\"text-align:center; width:4%\">0</td>\n			<td style=\"text-align:center; width:4%\">0</td>\n			<td style=\"text-align:center; width:4%\">0</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center; width:4%\">0</td>\n			<td style=\"text-align:center; width:4%\">0</td>\n			<td style=\"text-align:center; width:4%\">0</td>\n			<td style=\"text-align:center; width:4%\">0</td>\n			<td style=\"text-align:center; width:4%\"><strong>1</strong></td>\n			<td style=\"text-align:center; width:4%\">0</td>\n			<td style=\"text-align:center; width:4%\">0</td>\n			<td style=\"text-align:center; width:4%\">0</td>\n			<td style=\"text-align:center; width:4%\">0</td>\n			<td style=\"text-align:center; width:4%\">0</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center; width:4%\">0</td>\n			<td style=\"text-align:center; width:4%\">0</td>\n			<td style=\"text-align:center; width:4%\">0</td>\n			<td style=\"text-align:center; width:4%\">0</td>\n			<td style=\"text-align:center; width:4%\"><strong>1</strong></td>\n			<td style=\"text-align:center; width:4%\">0</td>\n			<td style=\"text-align:center; width:4%\">0</td>\n			<td style=\"text-align:center; width:4%\">0</td>\n			<td style=\"text-align:center; width:4%\">0</td>\n			<td style=\"text-align:center; width:4%\">0</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center; width:4%\">0</td>\n			<td style=\"text-align:center; width:4%\">0</td>\n			<td style=\"text-align:center; width:4%\"><strong>1</strong></td>\n			<td style=\"text-align:center; width:4%\"><strong>1</strong></td>\n			<td style=\"text-align:center; width:4%\">0</td>\n			<td style=\"text-align:center; width:4%\">0</td>\n			<td style=\"text-align:center; width:4%\">0</td>\n			<td style=\"text-align:center; width:4%\"><strong>1</strong></td>\n			<td style=\"text-align:center; width:4%\"><strong>1</strong></td>\n			<td style=\"text-align:center; width:4%\"><strong>1</strong></td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center; width:4%\">0</td>\n			<td style=\"text-align:center; width:4%\">0</td>\n			<td style=\"text-align:center; width:4%\">0</td>\n			<td style=\"text-align:center; width:4%\">0</td>\n			<td style=\"text-align:center; width:4%\"><strong>1</strong></td>\n			<td style=\"text-align:center; width:4%\">0</td>\n			<td style=\"text-align:center; width:4%\">0</td>\n			<td style=\"text-align:center; width:4%\"><strong>1</strong></td>\n			<td style=\"text-align:center; width:4%\"><strong>1</strong></td>\n			<td style=\"text-align:center; width:4%\"><strong>1</strong></td>\n		</tr>\n	</tbody>\n</table>','<p>입력의 첫 줄에는 테스트 케이스의 개수 T가 주어진다. 그 다음 줄부터 각각의 테스트 케이스에 대해 첫째 줄에는 배추를 심은 배추밭의 가로길이 M(1 ≤ M ≤ 50)과 세로길이 N(1 ≤ N ≤ 50), 그리고 배추가 심어져 있는 위치의 개수 K(1 ≤ K ≤ 2500)이 주어진다. 그 다음 K줄에는 배추의 위치 X(0 ≤ X ≤ M-1), Y(0 ≤ Y ≤ N-1)가 주어진다. 두 배추의 위치가 같은 경우는 없다.</p>','<p>각 테스트 케이스에 대해 필요한 최소의 배추흰지렁이 마리 수를 출력한다.</p>','[\"그래프 이론\", \"그래프 탐색\", \"너비 우선 탐색\", \"깊이 우선 탐색\"]','[]','1 초','512 MB'),
(1015,'수열 정렬',7,'<p>P[0], P[1], ...., P[N-1]은 0부터 N-1까지(포함)의 수를 한 번씩 포함하고 있는 수열이다. 수열 P를 길이가 N인 배열 A에 적용하면 길이가 N인 배열 B가 된다. 적용하는 방법은 B[P[i]] = A[i]이다.</p>\n\n<p>배열 A가 주어졌을 때, 수열 P를 적용한 결과가 비내림차순이 되는 수열을 찾는 프로그램을 작성하시오. 비내림차순이란, 각각의 원소가 바로 앞에 있는 원소보다 크거나 같을 경우를 말한다. 만약 그러한 수열이 여러개라면 사전순으로 앞서는 것을 출력한다.</p>','<p>첫째 줄에 배열 A의 크기 N이 주어진다. 둘째 줄에는 배열 A의 원소가 0번부터 차례대로 주어진다. N은 50보다 작거나 같은 자연수이고, 배열의 원소는 1,000보다 작거나 같은 자연수이다.</p>','<p>첫째 줄에 비내림차순으로 만드는 수열 P를 출력한다.</p>','[\"정렬\"]','[]','2 초','128 MB'),
(1049,'기타줄',7,'<p>Day Of Mourning의 기타리스트 강토가 사용하는 기타에서 N개의 줄이 끊어졌다. 따라서 새로운 줄을 사거나 교체해야 한다. 강토는 되도록이면 돈을 적게 쓰려고 한다. 6줄 패키지를 살 수도 있고, 1개 또는 그 이상의 줄을 낱개로 살 수도 있다.</p>\n\n<p>끊어진 기타줄의 개수 N과 기타줄 브랜드 M개가 주어지고, 각각의 브랜드에서 파는 기타줄 6개가 들어있는 패키지의 가격, 낱개로 살 때의 가격이 주어질 때, 적어도 N개를 사기 위해 필요한 돈의 수를 최소로 하는 프로그램을 작성하시오.</p>','<p>첫째 줄에 N과 M이 주어진다. N은 100보다 작거나 같은 자연수이고, M은 50보다 작거나 같은 자연수이다. 둘째 줄부터 M개의 줄에는 각 브랜드의 패키지 가격과 낱개의 가격이 공백으로 구분하여 주어진다. 가격은 0보다 크거나 같고, 1,000보다 작거나 같은 정수이다.</p>','<p>첫째 줄에 기타줄을 적어도 N개 사기 위해 필요한 돈의 최솟값을 출력한다.</p>','[\"수학\", \"그리디 알고리즘\"]','[]','2 초','128 MB'),
(1111,'IQ Test',13,'<p>IQ Test의 문제 중에는 공통된 패턴을 찾는 문제가 있다. 수열이 주어졌을 때, 다음 수를 찾는 문제이다.</p>\n\n<p>예를 들어, 1, 2, 3, 4, 5가 주어졌다. 다음 수는 무엇인가? 당연히 답은 6이다. 약간 더 어려운 문제를 보면, 3, 6, 12, 24, 48이 주어졌을 때, 다음 수는 무엇인가? 역시 답은 96이다.</p>\n\n<p>이제 제일 어려운 문제를 보자.</p>\n\n<p>1, 4, 13, 40이 주어졌을 때, 다음 수는 무엇일까? 답은 121이다. 그 이유는 항상 다음 수는 앞 수*3+1이기 때문이다.</p>\n\n<p>은진이는 위의 3문제를 모두 풀지 못했으므로, 자동으로 풀어주는 프로그램을 작성하기로 했다. 항상 모든 답은 구하는 규칙은 앞 수*a + b이다. 그리고, a와 b는 정수이다.</p>\n\n<p>수 N개가 주어졌을 때, 규칙에 맞는 다음 수를 구하는 프로그램을 작성하시오.</p>','<p>첫째 줄에 N이 주어진다. N은 50보다 작거나 같은 자연수이다. 둘째 줄에는 N개의 수가 주어진다. 이 수는 모두 절댓값이 100보다 작거나 같은 정수이다.</p>','<p>다음 수를 출력한다. 만약 다음 수가 여러 개일 경우에는 A를 출력하고, 다음 수를 구할 수 없는 경우에는 B를 출력한다.</p>','[\"수학\", \"구현\", \"브루트포스 알고리즘\", \"많은 조건 분기\"]','[]','2 초 ','128 MB'),
(1157,'단어 공부',5,'<p>알파벳 대소문자로 된 단어가 주어지면, 이 단어에서 가장 많이 사용된 알파벳이 무엇인지 알아내는 프로그램을 작성하시오. 단, 대문자와 소문자를 구분하지 않는다.</p>','<p>첫째 줄에 알파벳 대소문자로 이루어진 단어가 주어진다. 주어지는 단어의 길이는 1,000,000을 넘지 않는다.</p>','<p>첫째 줄에 이 단어에서 가장 많이 사용된 알파벳을 대문자로 출력한다. 단, 가장 많이 사용된 알파벳이 여러 개 존재하는 경우에는 ?를 출력한다.</p>','[\"구현\", \"문자열\"]','[]','2 초','128 MB'),
(1520,'내리막 길',13,'<p>여행을 떠난 세준이는 지도를 하나 구하였다. 이 지도는 아래 그림과 같이 직사각형 모양이며 여러 칸으로 나뉘어져 있다. 한 칸은 한 지점을 나타내는데 각 칸에는 그 지점의 높이가 쓰여 있으며, 각 지점 사이의 이동은 지도에서 상하좌우 이웃한 곳끼리만 가능하다.</p>\n\n<p style=\"text-align: center;\"><img alt=\"\" src=\"https://upload.acmicpc.net/0e11f3db-35d2-4b01-9aa0-9a39252f05be/-/preview/\" style=\"width: 151px; height: 122px;\"></p>\n\n<p>현재 제일 왼쪽 위 칸이 나타내는 지점에 있는 세준이는 제일 오른쪽 아래 칸이 나타내는 지점으로 가려고 한다. 그런데 가능한 힘을 적게 들이고 싶어 항상 높이가 더 낮은 지점으로만 이동하여 목표 지점까지 가고자 한다. 위와 같은 지도에서는 다음과 같은 세 가지 경로가 가능하다.</p>\n\n<p style=\"text-align: center;\"><img alt=\"\" src=\"\" style=\"width: 151px; height: 123px;\"> <img alt=\"\" src=\"https://upload.acmicpc.net/1ed5b78d-a4a1-49c0-8c23-12a12e2937e1/-/preview/\" style=\"width: 151px; height: 121px;\"> <img alt=\"\" src=\"\" style=\"width: 151px; height: 121px;\"></p>\n\n<p>지도가 주어질 때 이와 같이 제일 왼쪽 위 지점에서 출발하여 제일 오른쪽 아래 지점까지 항상 내리막길로만 이동하는 경로의 개수를 구하는 프로그램을 작성하시오.</p>','<p>첫째 줄에는 지도의 세로의 크기 M과 가로의 크기 N이 빈칸을 사이에 두고 주어진다. 이어 다음 M개 줄에 걸쳐 한 줄에 N개씩 위에서부터 차례로 각 지점의 높이가 빈 칸을 사이에 두고 주어진다. M과 N은 각각 500이하의 자연수이고, 각 지점의 높이는 10000이하의 자연수이다.</p>','<p>첫째 줄에 이동 가능한 경로의 수 H를 출력한다. 모든 입력에 대하여 H는 10억 이하의 음이 아닌 정수이다.</p>','[\"다이나믹 프로그래밍\", \"그래프 이론\", \"그래프 탐색\", \"깊이 우선 탐색\"]','[]','2 초','128 MB'),
(1806,'부분합',12,'<p>10,000 이하의 자연수로 이루어진 길이 N짜리 수열이 주어진다. 이 수열에서 연속된 수들의 부분합 중에 그 합이 S 이상이 되는 것 중, 가장 짧은 것의 길이를 구하는 프로그램을 작성하시오.</p>','<p>첫째 줄에 N (10 ≤ N < 100,000)과 S (0 < S ≤ 100,000,000)가 주어진다. 둘째 줄에는 수열이 주어진다. 수열의 각 원소는 공백으로 구분되어져 있으며, 10,000이하의 자연수이다.</p>','<p>첫째 줄에 구하고자 하는 최소의 길이를 출력한다. 만일 그러한 합을 만드는 것이 불가능하다면 0을 출력하면 된다.</p>','[\"누적 합\", \"두 포인터\"]','[]','0.5 초 (하단 참고)','128 MB'),
(2110,'공유기 설치',12,'<p>도현이의 집 N개가 수직선 위에 있다. 각각의 집의 좌표는 x<sub>1</sub>, ..., x<sub>N</sub>이고, 집 여러개가 같은 좌표를 가지는 일은 없다.</p>\n\n<p>도현이는 언제 어디서나 와이파이를 즐기기 위해서 집에 공유기 C개를 설치하려고 한다. 최대한 많은 곳에서 와이파이를 사용하려고 하기 때문에, 한 집에는 공유기를 하나만 설치할 수 있고, 가장 인접한 두 공유기 사이의 거리를 가능한 크게 하여 설치하려고 한다.</p>\n\n<p>C개의 공유기를 N개의 집에 적당히 설치해서, 가장 인접한 두 공유기 사이의 거리를 최대로 하는 프로그램을 작성하시오.</p>','<p>첫째 줄에 집의 개수 N (2 ≤ N ≤ 200,000)과 공유기의 개수 C (2 ≤ C ≤ N)이 하나 이상의 빈 칸을 사이에 두고 주어진다. 둘째 줄부터 N개의 줄에는 집의 좌표를 나타내는 x<sub>i</sub> (0 ≤ x<sub>i</sub> ≤ 1,000,000,000)가 한 줄에 하나씩 주어진다.</p>','<p>첫째 줄에 가장 인접한 두 공유기 사이의 최대 거리를 출력한다.</p>','[\"이분 탐색\", \"매개 변수 탐색\"]','[]','2 초','128 MB'),
(2557,'Hello World',1,'<p>\n	Hello World!를 출력하시오.</p>','<p>\n	없음</p>','<p>\n	Hello World!를 출력하시오.</p>','[\"구현\"]','[]','1 초','128 MB'),
(3040,'백설 공주와 일곱 난쟁이',4,'<p>매일 매일 일곱 난쟁이는 광산으로 일을 하러 간다. 난쟁이가 일을 하는 동안 백설공주는 그들을 위해 저녁 식사를 준비한다. 백설공주는 의자 일곱개, 접시 일곱개, 나이프 일곱개를 준비한다.</p>\n\n<p>어느 날 광산에서 아홉 난쟁이가 돌아왔다. (왜 그리고 어떻게 아홉 난쟁이가 돌아왔는지는 아무도 모른다) 아홉 난쟁이는 각각 자신이 백설공주의 일곱 난쟁이라고 우기고 있다.</p>\n\n<p>백설공주는 이런 일이 생길 것을 대비해서, 난쟁이가 쓰고 다니는 모자에 100보다 작은 양의 정수를 적어 놓았다. 사실 백설 공주는 공주가 되기 전에 매우 유명한 수학자였다. 따라서, 일곱 난쟁이의 모자에 쓰여 있는 숫자의 합이 100이 되도록 적어 놓았다.</p>\n\n<p>아홉 난쟁이의 모자에 쓰여 있는 수가 주어졌을 때, 일곱 난쟁이를 찾는 프로그램을 작성하시오. (아홉 개의 수 중 합이 100이 되는 일곱 개의 수를 찾으시오)</p>','<p>총 아홉개 줄에 1보다 크거나 같고 99보다 작거나 같은 자연수가 주어진다. 모든 숫자는 서로 다르다. 또, 항상 답이 유일한 경우만 입력으로 주어진다.</p>','<p>일곱 난쟁이가 쓴 모자에 쓰여 있는 수를 한 줄에 하나씩 출력한다.</p>','[\"브루트포스 알고리즘\"]','[]','1 초','128 MB'),
(3649,'로봇 프로젝트',11,'<p>상근이와 선영이는 학교 숙제로 로봇을 만들고 있다. 로봇을 만들던 중에 구멍을 막을 두 레고 조각이 필요하다는 것을 깨달았다.</p>\n\n<p>구멍의 너비는 x 센티미터이고, 구멍에 넣을 두 조각의 길이의 합은 구멍의 너비와 정확하게 일치해야 한다. 정확하게 일치하지 않으면, 프로젝트 시연을 할 때 로봇은 부수어질 것이고 상근이와 선영이는 F를 받게 된다. 구멍은 항상 두 조각으로 막아야 한다.</p>\n\n<p>지난밤, 상근이와 선영이는 물리 실험실에 들어가서 레고 조각의 크기를 모두 정확하게 재고 돌아왔다. 구멍을 완벽하게 막을 수 있는 두 조각을 구하는 프로그램을 작성하시오.</p>','<p>입력은 여러 개의 테스트 케이스로 이루어져 있다.</p>\n\n<p>각 테스트 케이스의 첫째 줄에는 구멍의 너비 x (1 ≤ x ≤ 20, x는 정수)가 주어진다. x의 단위는 센티미터이다.</p>\n\n<p>다음 줄에는 물리 실험실에 있는 레고 조각의 수 n이 주어진다. (0 ≤ n ≤ 1000000)</p>\n\n<p>다음 n개의 줄에는 레고 조각의 길이 ℓ이 주어진다. ℓ은 양의 정수이며, 단위는 나노미터이다. 블록의 길이는 10 센티미터 (100000000 나노미터)를 넘지 않는다.</p>','<p>각 테스트 케이스마다 한 줄에 하나씩, 구멍을 완벽하게 막을 수 있는 두 조각이 없다면 \'danger\'를 출력한다. 막을 수 있는 경우에는 \'yes ℓ<sub>1</sub> ℓ<sub>2</sub>\'를 출력한다. (ℓ<sub>1</sub> ≤ ℓ<sub>2</sub>)</p>\n\n<p>정답이 여러 개인 경우에는 |ℓ<sub>1</sub> - ℓ<sub>2</sub>|가 가장 큰 것을 출력한다.</p>','[\"정렬\", \"이분 탐색\", \"두 포인터\"]','[]','5 초','256 MB'),
(5052,'전화번호 목록',12,'<p>전화번호 목록이 주어진다. 이때, 이 목록이 일관성이 있는지 없는지를 구하는 프로그램을 작성하시오.</p>\n\n<p>전화번호 목록이 일관성을 유지하려면, 한 번호가 다른 번호의 접두어인 경우가 없어야 한다.</p>\n\n<p>예를 들어, 전화번호 목록이 아래와 같은 경우를 생각해보자</p>\n\n<ul>\n	<li>긴급전화: 911</li>\n	<li>상근: 97 625 999</li>\n	<li>선영: 91 12 54 26</li>\n</ul>\n\n<p>이 경우에 선영이에게 전화를 걸 수 있는 방법이 없다. 전화기를 들고 선영이 번호의 처음 세 자리를 누르는 순간 바로 긴급전화가 걸리기 때문이다. 따라서, 이 목록은 일관성이 없는 목록이다. </p>','<p>첫째 줄에 테스트 케이스의 개수 t가 주어진다. (1 ≤ t ≤ 50) 각 테스트 케이스의 첫째 줄에는 전화번호의 수 n이 주어진다. (1 ≤ n ≤ 10000) 다음 n개의 줄에는 목록에 포함되어 있는 전화번호가 하나씩 주어진다. 전화번호의 길이는 길어야 10자리이며, 목록에 있는 두 전화번호가 같은 경우는 없다.</p>','<p>각 테스트 케이스에 대해서, 일관성 있는 목록인 경우에는 YES, 아닌 경우에는 NO를 출력한다.</p>','[\"자료 구조\", \"문자열\", \"정렬\", \"트리\", \"트라이\"]','[]','1 초','256 MB'),
(7569,'토마토',11,'<p>철수의 토마토 농장에서는 토마토를 보관하는 큰 창고를 가지고 있다. 토마토는 아래의 그림과 같이 격자모양 상자의 칸에 하나씩 넣은 다음, 상자들을 수직으로 쌓아 올려서 창고에 보관한다.</p>\n\n<p style=\"text-align: center;\"></p>\n\n<p>창고에 보관되는 토마토들 중에는 잘 익은 것도 있지만, 아직 익지 않은 토마토들도 있을 수 있다. 보관 후 하루가 지나면, 익은 토마토들의 인접한 곳에 있는 익지 않은 토마토들은 익은 토마토의 영향을 받아 익게 된다. 하나의 토마토에 인접한 곳은 위, 아래, 왼쪽, 오른쪽, 앞, 뒤 여섯 방향에 있는 토마토를 의미한다. 대각선 방향에 있는 토마토들에게는 영향을 주지 못하며, 토마토가 혼자 저절로 익는 경우는 없다고 가정한다. 철수는 창고에 보관된 토마토들이 며칠이 지나면 다 익게 되는지 그 최소 일수를 알고 싶어 한다.</p>\n\n<p>토마토를 창고에 보관하는 격자모양의 상자들의 크기와 익은 토마토들과 익지 않은 토마토들의 정보가 주어졌을 때, 며칠이 지나면 토마토들이 모두 익는지, 그 최소 일수를 구하는 프로그램을 작성하라. 단, 상자의 일부 칸에는 토마토가 들어있지 않을 수도 있다.</p>','<p>첫 줄에는 상자의 크기를 나타내는 두 정수 M,N과 쌓아올려지는 상자의 수를 나타내는 H가 주어진다. M은 상자의 가로 칸의 수, N은 상자의 세로 칸의 수를 나타낸다. 단, 2 ≤ M ≤ 100, 2 ≤ N ≤ 100, 1 ≤ H ≤ 100 이다. 둘째 줄부터는 가장 밑의 상자부터 가장 위의 상자까지에 저장된 토마토들의 정보가 주어진다. 즉, 둘째 줄부터 N개의 줄에는 하나의 상자에 담긴 토마토의 정보가 주어진다. 각 줄에는 상자 가로줄에 들어있는 토마토들의 상태가 M개의 정수로 주어진다. 정수 1은 익은 토마토, 정수 0 은 익지 않은 토마토, 정수 -1은 토마토가 들어있지 않은 칸을 나타낸다. 이러한 N개의 줄이 H번 반복하여 주어진다.</p>\n\n<p>토마토가 하나 이상 있는 경우만 입력으로 주어진다.</p>','<p>여러분은 토마토가 모두 익을 때까지 최소 며칠이 걸리는지를 계산해서 출력해야 한다. 만약, 저장될 때부터 모든 토마토가 익어있는 상태이면 0을 출력해야 하고, 토마토가 모두 익지는 못하는 상황이면 -1을 출력해야 한다.</p>','[\"그래프 이론\", \"그래프 탐색\", \"너비 우선 탐색\"]','[]','1 초','256 MB'),
(10026,'적록색약',11,'<p>적록색약은 빨간색과 초록색의 차이를 거의 느끼지 못한다. 따라서, 적록색약인 사람이 보는 그림은 아닌 사람이 보는 그림과는 좀 다를 수 있다.</p>\n\n<p>크기가 N×N인 그리드의 각 칸에 R(빨강), G(초록), B(파랑) 중 하나를 색칠한 그림이 있다. 그림은 몇 개의 구역으로 나뉘어져 있는데, 구역은 같은 색으로 이루어져 있다. 또, 같은 색상이 상하좌우로 인접해 있는 경우에 두 글자는 같은 구역에 속한다. (색상의 차이를 거의 느끼지 못하는 경우도 같은 색상이라 한다)</p>\n\n<p>예를 들어, 그림이 아래와 같은 경우에</p>\n\n<pre>RRRBB\nGGBBB\nBBBRR\nBBRRR\nRRRRR</pre>\n\n<p>적록색약이 아닌 사람이 봤을 때 구역의 수는 총 4개이다. (빨강 2, 파랑 1, 초록 1) 하지만, 적록색약인 사람은 구역을 3개 볼 수 있다. (빨강-초록 2, 파랑 1)</p>\n\n<p>그림이 입력으로 주어졌을 때, 적록색약인 사람이 봤을 때와 아닌 사람이 봤을 때 구역의 수를 구하는 프로그램을 작성하시오.</p>','<p>첫째 줄에 N이 주어진다. (1 ≤ N ≤ 100)</p>\n\n<p>둘째 줄부터 N개 줄에는 그림이 주어진다.</p>','<p>적록색약이 아닌 사람이 봤을 때의 구역의 개수와 적록색약인 사람이 봤을 때의 구역의 수를 공백으로 구분해 출력한다.</p>','[\"그래프 이론\", \"그래프 탐색\", \"너비 우선 탐색\", \"깊이 우선 탐색\"]','[]','1 초','128 MB'),
(10950,'A+B - 3',1,'<p>두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오.</p>','<p>첫째 줄에 테스트 케이스의 개수 T가 주어진다.</p>\n\n<p>각 테스트 케이스는 한 줄로 이루어져 있으며, 각 줄에 A와 B가 주어진다. (0 < A, B < 10)</p>','<p>각 테스트 케이스마다 A+B를 출력한다.</p>','[\"수학\", \"구현\", \"사칙연산\"]','[]','1 초','256 MB'),
(14499,'주사위 굴리기',12,'<p>크기가 N×M인 지도가 존재한다. 지도의 오른쪽은 동쪽, 위쪽은 북쪽이다. 이 지도의 위에 주사위가 하나 놓여져 있으며, 주사위의 전개도는 아래와 같다. 지도의 좌표는 (r, c)로 나타내며, r는 북쪽으로부터 떨어진 칸의 개수, c는 서쪽으로부터 떨어진 칸의 개수이다. </p>\n\n<pre>  2\n4 1 3\n  5\n  6</pre>\n\n<p>주사위는 지도 위에 윗 면이 1이고, 동쪽을 바라보는 방향이 3인 상태로 놓여져 있으며, 놓여져 있는 곳의 좌표는 (x, y) 이다. 가장 처음에 주사위에는 모든 면에 0이 적혀져 있다.</p>\n\n<p>지도의 각 칸에는 정수가 하나씩 쓰여져 있다. 주사위를 굴렸을 때, 이동한 칸에 쓰여 있는 수가 0이면, 주사위의 바닥면에 쓰여 있는 수가 칸에 복사된다. 0이 아닌 경우에는 칸에 쓰여 있는 수가 주사위의 바닥면으로 복사되며, 칸에 쓰여 있는 수는 0이 된다.</p>\n\n<p>주사위를 놓은 곳의 좌표와 이동시키는 명령이 주어졌을 때, 주사위가 이동했을 때 마다 상단에 쓰여 있는 값을 구하는 프로그램을 작성하시오.</p>\n\n<p>주사위는 지도의 바깥으로 이동시킬 수 없다. 만약 바깥으로 이동시키려고 하는 경우에는 해당 명령을 무시해야 하며, 출력도 하면 안 된다.</p>','<p>첫째 줄에 지도의 세로 크기 N, 가로 크기 M (1 ≤ N, M ≤ 20), 주사위를 놓은 곳의 좌표 x, y(0 ≤ x ≤ N-1, 0 ≤ y ≤ M-1), 그리고 명령의 개수 K (1 ≤ K ≤ 1,000)가 주어진다.</p>\n\n<p>둘째 줄부터 N개의 줄에 지도에 쓰여 있는 수가 북쪽부터 남쪽으로, 각 줄은 서쪽부터 동쪽 순서대로 주어진다. 주사위를 놓은 칸에 쓰여 있는 수는 항상 0이다. 지도의 각 칸에 쓰여 있는 수는 10 미만의 자연수 또는 0이다.</p>\n\n<p>마지막 줄에는 이동하는 명령이 순서대로 주어진다. 동쪽은 1, 서쪽은 2, 북쪽은 3, 남쪽은 4로 주어진다.</p>','<p>이동할 때마다 주사위의 윗 면에 쓰여 있는 수를 출력한다. 만약 바깥으로 이동시키려고 하는 경우에는 해당 명령을 무시해야 하며, 출력도 하면 안 된다.</p>','[\"구현\", \"시뮬레이션\"]','[]','2 초','512 MB'),
(14500,'테트로미노',12,'<p>폴리오미노란 크기가 1×1인 정사각형을 여러 개 이어서 붙인 도형이며, 다음과 같은 조건을 만족해야 한다.</p>\n\n<ul>\n	<li>정사각형은 서로 겹치면 안 된다.</li>\n	<li>도형은 모두 연결되어 있어야 한다.</li>\n	<li>정사각형의 변끼리 연결되어 있어야 한다. 즉, 꼭짓점과 꼭짓점만 맞닿아 있으면 안 된다.</li>\n</ul>\n\n<p>정사각형 4개를 이어 붙인 폴리오미노는 테트로미노라고 하며, 다음과 같은 5가지가 있다.</p>\n\n<p style=\"text-align:center\"><a href=\"https://commons.wikimedia.org/wiki/File:All_5_free_tetrominoes.svg\"><img alt=\"\" src=\"\" style=\"height:167px; width:250px\"></a></p>\n\n<p>아름이는 크기가 N×M인 종이 위에 테트로미노 하나를 놓으려고 한다. 종이는 1×1 크기의 칸으로 나누어져 있으며, 각각의 칸에는 정수가 하나 쓰여 있다.</p>\n\n<p>테트로미노 하나를 적절히 놓아서 테트로미노가 놓인 칸에 쓰여 있는 수들의 합을 최대로 하는 프로그램을 작성하시오.</p>\n\n<p>테트로미노는 반드시 한 정사각형이 정확히 하나의 칸을 포함하도록 놓아야 하며, 회전이나 대칭을 시켜도 된다.</p>','<p>첫째 줄에 종이의 세로 크기 N과 가로 크기 M이 주어진다. (4 ≤ N, M ≤ 500)</p>\n\n<p>둘째 줄부터 N개의 줄에 종이에 쓰여 있는 수가 주어진다. i번째 줄의 j번째 수는 위에서부터 i번째 칸, 왼쪽에서부터 j번째 칸에 쓰여 있는 수이다. 입력으로 주어지는 수는 1,000을 넘지 않는 자연수이다.</p>','<p>첫째 줄에 테트로미노가 놓인 칸에 쓰인 수들의 합의 최댓값을 출력한다.</p>','[\"구현\", \"브루트포스 알고리즘\"]','[]','2 초 ','512 MB'),
(14502,'연구소',12,'<p>인체에 치명적인 바이러스를 연구하던 연구소에서 바이러스가 유출되었다. 다행히 바이러스는 아직 퍼지지 않았고, 바이러스의 확산을 막기 위해서 연구소에 벽을 세우려고 한다.</p>\n\n<p>연구소는 크기가 N×M인 직사각형으로 나타낼 수 있으며, 직사각형은 1×1 크기의 정사각형으로 나누어져 있다. 연구소는 빈 칸, 벽으로 이루어져 있으며, 벽은 칸 하나를 가득 차지한다. </p>\n\n<p>일부 칸은 바이러스가 존재하며, 이 바이러스는 상하좌우로 인접한 빈 칸으로 모두 퍼져나갈 수 있다. 새로 세울 수 있는 벽의 개수는 3개이며, 꼭 3개를 세워야 한다.</p>\n\n<p>예를 들어, 아래와 같이 연구소가 생긴 경우를 살펴보자.</p>\n\n<pre>2 0 0 0 1 1 0\n0 0 1 0 1 2 0\n0 1 1 0 1 0 0\n0 1 0 0 0 0 0\n0 0 0 0 0 1 1\n0 1 0 0 0 0 0\n0 1 0 0 0 0 0</pre>\n\n<p>이때, 0은 빈 칸, 1은 벽, 2는 바이러스가 있는 곳이다. 아무런 벽을 세우지 않는다면, 바이러스는 모든 빈 칸으로 퍼져나갈 수 있다.</p>\n\n<p>2행 1열, 1행 2열, 4행 6열에 벽을 세운다면 지도의 모양은 아래와 같아지게 된다.</p>\n\n<pre>2 1 0 0 1 1 0\n1 0 1 0 1 2 0\n0 1 1 0 1 0 0\n0 1 0 0 0 1 0\n0 0 0 0 0 1 1\n0 1 0 0 0 0 0\n0 1 0 0 0 0 0</pre>\n\n<p>바이러스가 퍼진 뒤의 모습은 아래와 같아진다.</p>\n\n<pre>2 1 0 0 1 1 2\n1 0 1 0 1 2 2\n0 1 1 0 1 2 2\n0 1 0 0 0 1 2\n0 0 0 0 0 1 1\n0 1 0 0 0 0 0\n0 1 0 0 0 0 0</pre>\n\n<p>벽을 3개 세운 뒤, 바이러스가 퍼질 수 없는 곳을 안전 영역이라고 한다. 위의 지도에서 안전 영역의 크기는 27이다.</p>\n\n<p>연구소의 지도가 주어졌을 때 얻을 수 있는 안전 영역 크기의 최댓값을 구하는 프로그램을 작성하시오.</p>','<p>첫째 줄에 지도의 세로 크기 N과 가로 크기 M이 주어진다. (3 ≤ N, M ≤ 8)</p>\n\n<p>둘째 줄부터 N개의 줄에 지도의 모양이 주어진다. 0은 빈 칸, 1은 벽, 2는 바이러스가 있는 위치이다. 2의 개수는 2보다 크거나 같고, 10보다 작거나 같은 자연수이다.</p>\n\n<p>빈 칸의 개수는 3개 이상이다.</p>','<p>첫째 줄에 얻을 수 있는 안전 영역의 최대 크기를 출력한다.</p>','[\"구현\", \"그래프 이론\", \"브루트포스 알고리즘\", \"그래프 탐색\", \"너비 우선 탐색\"]','[]','2 초','512 MB'),
(14503,'로봇 청소기',11,'<p>로봇 청소기와 방의 상태가 주어졌을 때, 청소하는 영역의 개수를 구하는 프로그램을 작성하시오.</p>\n\n<p>로봇 청소기가 있는 방은 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D441 TEX-I\"></mjx-c></mjx-mi><mjx-mo class=\"mjx-n\" space=\"3\"><mjx-c class=\"mjx-cD7\"></mjx-c></mjx-mo><mjx-mi class=\"mjx-i\" space=\"3\"><mjx-c class=\"mjx-c1D440 TEX-I\"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>N</mi><mo>×</mo><mi>M</mi></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$N \\times M$</span></mjx-container> 크기의 직사각형으로 나타낼 수 있으며, <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mn class=\"mjx-n\"><mjx-c class=\"mjx-c31\"></mjx-c></mjx-mn><mjx-mo class=\"mjx-n\" space=\"3\"><mjx-c class=\"mjx-cD7\"></mjx-c></mjx-mo><mjx-mn class=\"mjx-n\" space=\"3\"><mjx-c class=\"mjx-c31\"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mn>1</mn><mo>×</mo><mn>1</mn></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$1 \\times 1$</span></mjx-container> 크기의 정사각형 칸으로 나누어져 있다. 각각의 칸은 벽 또는 빈 칸이다. 청소기는 바라보는 방향이 있으며, 이 방향은 동, 서, 남, 북 중 하나이다. 방의 각 칸은 좌표 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mo class=\"mjx-n\"><mjx-c class=\"mjx-c28\"></mjx-c></mjx-mo><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D45F TEX-I\"></mjx-c></mjx-mi><mjx-mo class=\"mjx-n\"><mjx-c class=\"mjx-c2C\"></mjx-c></mjx-mo><mjx-mi class=\"mjx-i\" space=\"2\"><mjx-c class=\"mjx-c1D450 TEX-I\"></mjx-c></mjx-mi><mjx-mo class=\"mjx-n\"><mjx-c class=\"mjx-c29\"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mo stretchy=\"false\">(</mo><mi>r</mi><mo>,</mo><mi>c</mi><mo stretchy=\"false\">)</mo></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$(r, c)$</span></mjx-container>로 나타낼 수 있고, 가장 북쪽 줄의 가장 서쪽 칸의 좌표가 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mo class=\"mjx-n\"><mjx-c class=\"mjx-c28\"></mjx-c></mjx-mo><mjx-mn class=\"mjx-n\"><mjx-c class=\"mjx-c30\"></mjx-c></mjx-mn><mjx-mo class=\"mjx-n\"><mjx-c class=\"mjx-c2C\"></mjx-c></mjx-mo><mjx-mn class=\"mjx-n\" space=\"2\"><mjx-c class=\"mjx-c30\"></mjx-c></mjx-mn><mjx-mo class=\"mjx-n\"><mjx-c class=\"mjx-c29\"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mo stretchy=\"false\">(</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo stretchy=\"false\">)</mo></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$(0, 0)$</span></mjx-container>, 가장 남쪽 줄의 가장 동쪽 칸의 좌표가 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mo class=\"mjx-n\"><mjx-c class=\"mjx-c28\"></mjx-c></mjx-mo><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D441 TEX-I\"></mjx-c></mjx-mi><mjx-mo class=\"mjx-n\" space=\"3\"><mjx-c class=\"mjx-c2212\"></mjx-c></mjx-mo><mjx-mn class=\"mjx-n\" space=\"3\"><mjx-c class=\"mjx-c31\"></mjx-c></mjx-mn><mjx-mo class=\"mjx-n\"><mjx-c class=\"mjx-c2C\"></mjx-c></mjx-mo><mjx-mi class=\"mjx-i\" space=\"2\"><mjx-c class=\"mjx-c1D440 TEX-I\"></mjx-c></mjx-mi><mjx-mo class=\"mjx-n\" space=\"3\"><mjx-c class=\"mjx-c2212\"></mjx-c></mjx-mo><mjx-mn class=\"mjx-n\" space=\"3\"><mjx-c class=\"mjx-c31\"></mjx-c></mjx-mn><mjx-mo class=\"mjx-n\"><mjx-c class=\"mjx-c29\"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mo stretchy=\"false\">(</mo><mi>N</mi><mo>−</mo><mn>1</mn><mo>,</mo><mi>M</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$(N-1, M-1)$</span></mjx-container>이다. 즉, 좌표 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mo class=\"mjx-n\"><mjx-c class=\"mjx-c28\"></mjx-c></mjx-mo><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D45F TEX-I\"></mjx-c></mjx-mi><mjx-mo class=\"mjx-n\"><mjx-c class=\"mjx-c2C\"></mjx-c></mjx-mo><mjx-mi class=\"mjx-i\" space=\"2\"><mjx-c class=\"mjx-c1D450 TEX-I\"></mjx-c></mjx-mi><mjx-mo class=\"mjx-n\"><mjx-c class=\"mjx-c29\"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mo stretchy=\"false\">(</mo><mi>r</mi><mo>,</mo><mi>c</mi><mo stretchy=\"false\">)</mo></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$(r, c)$</span></mjx-container>는 북쪽에서 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mo class=\"mjx-n\"><mjx-c class=\"mjx-c28\"></mjx-c></mjx-mo><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D45F TEX-I\"></mjx-c></mjx-mi><mjx-mo class=\"mjx-n\" space=\"3\"><mjx-c class=\"mjx-c2B\"></mjx-c></mjx-mo><mjx-mn class=\"mjx-n\" space=\"3\"><mjx-c class=\"mjx-c31\"></mjx-c></mjx-mn><mjx-mo class=\"mjx-n\"><mjx-c class=\"mjx-c29\"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mo stretchy=\"false\">(</mo><mi>r</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$(r+1)$</span></mjx-container>번째에 있는 줄의 서쪽에서 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mo class=\"mjx-n\"><mjx-c class=\"mjx-c28\"></mjx-c></mjx-mo><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D450 TEX-I\"></mjx-c></mjx-mi><mjx-mo class=\"mjx-n\" space=\"3\"><mjx-c class=\"mjx-c2B\"></mjx-c></mjx-mo><mjx-mn class=\"mjx-n\" space=\"3\"><mjx-c class=\"mjx-c31\"></mjx-c></mjx-mn><mjx-mo class=\"mjx-n\"><mjx-c class=\"mjx-c29\"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mo stretchy=\"false\">(</mo><mi>c</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$(c+1)$</span></mjx-container>번째 칸을 가리킨다. 처음에 빈 칸은 전부 청소되지 않은 상태이다.</p>\n\n<p>로봇 청소기는 다음과 같이 작동한다.</p>\n\n<ol>\n	<li>현재 칸이 아직 청소되지 않은 경우, 현재 칸을 청소한다.</li>\n	<li>현재 칸의 주변 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mn class=\"mjx-n\"><mjx-c class=\"mjx-c34\"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mn>4</mn></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$4$</span></mjx-container>칸 중 청소되지 않은 빈 칸이 없는 경우,\n	<ol>\n		<li>바라보는 방향을 유지한 채로 한 칸 후진할 수 있다면 한 칸 후진하고 1번으로 돌아간다.</li>\n		<li>바라보는 방향의 뒤쪽 칸이 벽이라 후진할 수 없다면 작동을 멈춘다.</li>\n	</ol>\n	</li>\n	<li>현재 칸의 주변 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mn class=\"mjx-n\"><mjx-c class=\"mjx-c34\"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mn>4</mn></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$4$</span></mjx-container>칸 중 청소되지 않은 빈 칸이 있는 경우,\n	<ol>\n		<li>반시계 방향으로 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-msup><mjx-mn class=\"mjx-n\"><mjx-c class=\"mjx-c39\"></mjx-c><mjx-c class=\"mjx-c30\"></mjx-c></mjx-mn><mjx-script style=\"vertical-align: 0.393em;\"><mjx-mo class=\"mjx-n\" size=\"s\"><mjx-c class=\"mjx-c2218\"></mjx-c></mjx-mo></mjx-script></mjx-msup></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msup><mn>90</mn><mo>∘</mo></msup></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$90^\\circ$</span></mjx-container> 회전한다.</li>\n		<li>바라보는 방향을 기준으로 앞쪽 칸이 청소되지 않은 빈 칸인 경우 한 칸 전진한다.</li>\n		<li>1번으로 돌아간다.</li>\n	</ol>\n	</li>\n</ol>','<p>첫째 줄에 방의 크기 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D441 TEX-I\"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>N</mi></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$N$</span></mjx-container>과 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D440 TEX-I\"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>M</mi></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$M$</span></mjx-container>이 입력된다. <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mo class=\"mjx-n\"><mjx-c class=\"mjx-c28\"></mjx-c></mjx-mo><mjx-mn class=\"mjx-n\"><mjx-c class=\"mjx-c33\"></mjx-c></mjx-mn><mjx-mo class=\"mjx-n\" space=\"4\"><mjx-c class=\"mjx-c2264\"></mjx-c></mjx-mo><mjx-mi class=\"mjx-i\" space=\"4\"><mjx-c class=\"mjx-c1D441 TEX-I\"></mjx-c></mjx-mi><mjx-mo class=\"mjx-n\"><mjx-c class=\"mjx-c2C\"></mjx-c></mjx-mo><mjx-mi class=\"mjx-i\" space=\"2\"><mjx-c class=\"mjx-c1D440 TEX-I\"></mjx-c></mjx-mi><mjx-mo class=\"mjx-n\" space=\"4\"><mjx-c class=\"mjx-c2264\"></mjx-c></mjx-mo><mjx-mn class=\"mjx-n\" space=\"4\"><mjx-c class=\"mjx-c35\"></mjx-c><mjx-c class=\"mjx-c30\"></mjx-c></mjx-mn><mjx-mo class=\"mjx-n\"><mjx-c class=\"mjx-c29\"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mo stretchy=\"false\">(</mo><mn>3</mn><mo>≤</mo><mi>N</mi><mo>,</mo><mi>M</mi><mo>≤</mo><mn>50</mn><mo stretchy=\"false\">)</mo></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$(3 \\le N, M \\le 50)$</span></mjx-container>  둘째 줄에 처음에 로봇 청소기가 있는 칸의 좌표 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mo class=\"mjx-n\"><mjx-c class=\"mjx-c28\"></mjx-c></mjx-mo><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D45F TEX-I\"></mjx-c></mjx-mi><mjx-mo class=\"mjx-n\"><mjx-c class=\"mjx-c2C\"></mjx-c></mjx-mo><mjx-mi class=\"mjx-i\" space=\"2\"><mjx-c class=\"mjx-c1D450 TEX-I\"></mjx-c></mjx-mi><mjx-mo class=\"mjx-n\"><mjx-c class=\"mjx-c29\"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mo stretchy=\"false\">(</mo><mi>r</mi><mo>,</mo><mi>c</mi><mo stretchy=\"false\">)</mo></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$(r, c)$</span></mjx-container>와 처음에 로봇 청소기가 바라보는 방향 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D451 TEX-I\"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>d</mi></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$d$</span></mjx-container>가 입력된다. <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D451 TEX-I\"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>d</mi></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$d$</span></mjx-container>가 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mn class=\"mjx-n\"><mjx-c class=\"mjx-c30\"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mn>0</mn></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$0$</span></mjx-container>인 경우 북쪽, <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mn class=\"mjx-n\"><mjx-c class=\"mjx-c31\"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mn>1</mn></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$1$</span></mjx-container>인 경우 동쪽, <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mn class=\"mjx-n\"><mjx-c class=\"mjx-c32\"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mn>2</mn></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$2$</span></mjx-container>인 경우 남쪽, <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mn class=\"mjx-n\"><mjx-c class=\"mjx-c33\"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mn>3</mn></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$3$</span></mjx-container>인 경우 서쪽을 바라보고 있는 것이다.</p>\n\n<p>셋째 줄부터 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D441 TEX-I\"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>N</mi></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$N$</span></mjx-container>개의 줄에 각 장소의 상태를 나타내는 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D441 TEX-I\"></mjx-c></mjx-mi><mjx-mo class=\"mjx-n\" space=\"3\"><mjx-c class=\"mjx-cD7\"></mjx-c></mjx-mo><mjx-mi class=\"mjx-i\" space=\"3\"><mjx-c class=\"mjx-c1D440 TEX-I\"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>N</mi><mo>×</mo><mi>M</mi></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$N \\times M$</span></mjx-container>개의 값이 한 줄에 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D440 TEX-I\"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>M</mi></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$M$</span></mjx-container>개씩 입력된다. <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D456 TEX-I\"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>i</mi></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$i$</span></mjx-container>번째 줄의 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D457 TEX-I\"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>j</mi></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$j$</span></mjx-container>번째 값은 칸 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mo class=\"mjx-n\"><mjx-c class=\"mjx-c28\"></mjx-c></mjx-mo><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D456 TEX-I\"></mjx-c></mjx-mi><mjx-mo class=\"mjx-n\"><mjx-c class=\"mjx-c2C\"></mjx-c></mjx-mo><mjx-mi class=\"mjx-i\" space=\"2\"><mjx-c class=\"mjx-c1D457 TEX-I\"></mjx-c></mjx-mi><mjx-mo class=\"mjx-n\"><mjx-c class=\"mjx-c29\"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mo stretchy=\"false\">(</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo stretchy=\"false\">)</mo></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$(i, j)$</span></mjx-container>의 상태를 나타내며, 이 값이 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mn class=\"mjx-n\"><mjx-c class=\"mjx-c30\"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mn>0</mn></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$0$</span></mjx-container>인 경우 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mo class=\"mjx-n\"><mjx-c class=\"mjx-c28\"></mjx-c></mjx-mo><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D456 TEX-I\"></mjx-c></mjx-mi><mjx-mo class=\"mjx-n\"><mjx-c class=\"mjx-c2C\"></mjx-c></mjx-mo><mjx-mi class=\"mjx-i\" space=\"2\"><mjx-c class=\"mjx-c1D457 TEX-I\"></mjx-c></mjx-mi><mjx-mo class=\"mjx-n\"><mjx-c class=\"mjx-c29\"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mo stretchy=\"false\">(</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo stretchy=\"false\">)</mo></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$(i, j)$</span></mjx-container>가 청소되지 않은 빈 칸이고, <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mn class=\"mjx-n\"><mjx-c class=\"mjx-c31\"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mn>1</mn></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$1$</span></mjx-container>인 경우 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mo class=\"mjx-n\"><mjx-c class=\"mjx-c28\"></mjx-c></mjx-mo><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D456 TEX-I\"></mjx-c></mjx-mi><mjx-mo class=\"mjx-n\"><mjx-c class=\"mjx-c2C\"></mjx-c></mjx-mo><mjx-mi class=\"mjx-i\" space=\"2\"><mjx-c class=\"mjx-c1D457 TEX-I\"></mjx-c></mjx-mi><mjx-mo class=\"mjx-n\"><mjx-c class=\"mjx-c29\"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mo stretchy=\"false\">(</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo stretchy=\"false\">)</mo></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$(i, j)$</span></mjx-container>에 벽이 있는 것이다. 방의 가장 북쪽, 가장 남쪽, 가장 서쪽, 가장 동쪽 줄 중 하나 이상에 위치한 모든 칸에는 벽이 있다. 로봇 청소기가 있는 칸은 항상 빈 칸이다.</p>','<p>로봇 청소기가 작동을 시작한 후 작동을 멈출 때까지 청소하는 칸의 개수를 출력한다.</p>','[\"구현\", \"시뮬레이션\"]','[]','2 초','512 MB'),
(14890,'경사로',13,'<p>크기가 N×N인 지도가 있다. 지도의 각 칸에는 그 곳의 높이가 적혀져 있다. </p>\n\n<p>오늘은 이 지도에서 지나갈 수 있는 길이 몇 개 있는지 알아보려고 한다. 길이란 한 행 또는 한 열 전부를 나타내며, 한쪽 끝에서 다른쪽 끝까지 지나가는 것이다. </p>\n\n<p>다음과 같은 N=6인 경우 지도를 살펴보자.</p>\n\n<p style=\"text-align:center\"><img alt=\"\" src=\"https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14890/1.png\" style=\"height:250px; width:250px\"></p>\n\n<p>이때, 길은 총 2N개가 있으며, 아래와 같다.</p>\n\n<p style=\"text-align:center\"><img alt=\"\" src=\"https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14890/2.png\" style=\"height:290px; width:290px\"></p>\n\n<p>길을 지나갈 수 있으려면 길에 속한 모든 칸의 높이가 모두 같아야 한다. 또는, 경사로를 놓아서 지나갈 수 있는 길을 만들 수 있다. 경사로는 높이가 항상 1이며, 길이는 L이다. 또, 개수는 매우 많아 부족할 일이 없다. 경사로는 낮은 칸과 높은 칸을 연결하며, 아래와 같은 조건을 만족해야한다.</p>\n\n<ul>\n	<li>경사로는 낮은 칸에 놓으며, L개의 연속된 칸에 경사로의 바닥이 모두 접해야 한다.</li>\n	<li>낮은 칸과 높은 칸의 높이 차이는 1이어야 한다.</li>\n	<li>경사로를 놓을 낮은 칸의 높이는 모두 같아야 하고, L개의 칸이 연속되어 있어야 한다.</li>\n</ul>\n\n<p>아래와 같은 경우에는 경사로를 놓을 수 없다.</p>\n\n<ul>\n	<li>경사로를 놓은 곳에 또 경사로를 놓는 경우</li>\n	<li>낮은 칸과 높은 칸의 높이 차이가 1이 아닌 경우</li>\n	<li>낮은 지점의 칸의 높이가 모두 같지 않거나, L개가 연속되지 않은 경우</li>\n	<li>경사로를 놓다가 범위를 벗어나는 경우</li>\n</ul>\n\n<p>L = 2인 경우에 경사로를 놓을 수 있는 경우를 그림으로 나타내면 아래와 같다.</p>\n\n<p style=\"text-align:center\"><img alt=\"\" src=\"https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14890/3.png\" style=\"height:107px; width:687px\"></p>\n\n<p>경사로를 놓을 수 없는 경우는 아래와 같다.</p>\n\n<p style=\"text-align:center\"><img alt=\"\" src=\"https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14890/4.png\" style=\"height:158px; width:1023px\"></p>\n\n<p>위의 그림의 가장 왼쪽부터 1번, 2번, 3번, 4번 예제라고 했을 때, 1번은 높이 차이가 1이 아니라서, 2번은 경사로를 바닥과 접하게 놓지 않아서, 3번은 겹쳐서 놓아서, 4번은 기울이게 놓아서 불가능한 경우이다.</p>\n\n<p>가장 위에 주어진 그림 예의 경우에 지나갈 수 있는 길은 파란색으로, 지나갈 수 없는 길은 빨간색으로 표시되어 있으며, 아래와 같다. 경사로의 길이 L = 2이다.</p>\n\n<p style=\"text-align:center\"><img alt=\"\" src=\"https://upload.acmicpc.net/255e47cf-0988-4b7f-b81c-2742f010a4c5/-/preview/\" style=\"width: 338px; height: 338px;\"></p>\n\n<p>지도가 주어졌을 때, 지나갈 수 있는 길의 개수를 구하는 프로그램을 작성하시오.</p>','<p>첫째 줄에 N (2 ≤ N ≤ 100)과 L (1 ≤ L ≤ N)이 주어진다. 둘째 줄부터 N개의 줄에 지도가 주어진다. 각 칸의 높이는 10보다 작거나 같은 자연수이다.</p>','<p>첫째 줄에 지나갈 수 있는 길의 개수를 출력한다.</p>','[\"구현\"]','[]','2 초','512 MB'),
(15652,'N과 M (4)',8,'<p>자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.</p>\n\n<ul>\n	<li>1부터 N까지 자연수 중에서 M개를 고른 수열</li>\n	<li>같은 수를 여러 번 골라도 된다.</li>\n	<li>고른 수열은 비내림차순이어야 한다.\n	<ul>\n		<li>길이가 K인 수열 A가 A<sub>1</sub> ≤ A<sub>2</sub> ≤ ... ≤ A<sub>K-1</sub> ≤ A<sub>K</sub>를 만족하면, 비내림차순이라고 한다.</li>\n	</ul>\n	</li>\n</ul>','<p>첫째 줄에 자연수 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 8)</p>','<p>한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다. 중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다.</p>\n\n<p>수열은 사전 순으로 증가하는 순서로 출력해야 한다.</p>','[\"백트래킹\"]','[]','1 초','512 MB'),
(16139,'인간-컴퓨터 상호작용',10,'<p>승재는 인간-컴퓨터 상호작용에서 생체공학 설계를 공부하다가 키보드 자판이 실용적인지 궁금해졌다. 이를 알아보기 위해 승재는 다음과 같은 생각을 했다. </p>\n\n<p>\'문자열에서 특정 알파벳이 몇 번 나타나는지 알아봐서 자주 나타나는 알파벳이 중지나 검지 위치에 오는 알파벳인지 확인하면 실용적인지 확인할 수 있을 것이다.\'</p>\n\n<p>승재를 도와 특정 문자열 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D446 TEX-I\"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>S</mi></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$S$</span></mjx-container>, 특정 알파벳 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D6FC TEX-I\"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>α</mi></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$\\alpha$</span></mjx-container>와 문자열의 구간 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mo class=\"mjx-n\"><mjx-c class=\"mjx-c5B\"></mjx-c></mjx-mo><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D459 TEX-I\"></mjx-c></mjx-mi><mjx-mo class=\"mjx-n\"><mjx-c class=\"mjx-c2C\"></mjx-c></mjx-mo><mjx-mi class=\"mjx-i\" space=\"2\"><mjx-c class=\"mjx-c1D45F TEX-I\"></mjx-c></mjx-mi><mjx-mo class=\"mjx-n\"><mjx-c class=\"mjx-c5D\"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mo stretchy=\"false\">[</mo><mi>l</mi><mo>,</mo><mi>r</mi><mo stretchy=\"false\">]</mo></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$[l,r]$</span></mjx-container>이 주어지면 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D446 TEX-I\"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>S</mi></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$S$</span></mjx-container>의 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D459 TEX-I\"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>l</mi></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$l$</span></mjx-container>번째 문자부터 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D45F TEX-I\"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>r</mi></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$r$</span></mjx-container>번째 문자 사이에 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D6FC TEX-I\"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>α</mi></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$\\alpha$</span></mjx-container>가 몇 번 나타나는지 구하는 프로그램을 작성하여라. 승재는 문자열의 문자는 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mn class=\"mjx-n\"><mjx-c class=\"mjx-c30\"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mn>0</mn></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$0$</span></mjx-container>번째부터 세며, <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D459 TEX-I\"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>l</mi></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$l$</span></mjx-container>번째와 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D45F TEX-I\"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>r</mi></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$r$</span></mjx-container>번째 문자를 포함해서 생각한다. 주의할 점은 승재는 호기심이 많기에 (통계적으로 크게 무의미하지만) 같은 문자열을 두고 질문을 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D45E TEX-I\"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>q</mi></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$q$</span></mjx-container>번 할 것이다.</p>','<p>첫 줄에 문자열 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D446 TEX-I\"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>S</mi></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$S$</span></mjx-container>가 주어진다. 문자열의 길이는 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mn class=\"mjx-n\"><mjx-c class=\"mjx-c32\"></mjx-c><mjx-c class=\"mjx-c30\"></mjx-c><mjx-c class=\"mjx-c30\"></mjx-c></mjx-mn><mjx-mo class=\"mjx-n\"><mjx-c class=\"mjx-c2C\"></mjx-c></mjx-mo><mjx-mn class=\"mjx-n\" space=\"2\"><mjx-c class=\"mjx-c30\"></mjx-c><mjx-c class=\"mjx-c30\"></mjx-c><mjx-c class=\"mjx-c30\"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mn>200</mn><mo>,</mo><mn>000</mn></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$200,000$</span></mjx-container>자 이하이며 알파벳 소문자로만 구성되었다. 두 번째 줄에는 질문의 수 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D45E TEX-I\"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>q</mi></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$q$</span></mjx-container>가 주어지며, 문제의 수는 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mn class=\"mjx-n\"><mjx-c class=\"mjx-c31\"></mjx-c></mjx-mn><mjx-mo class=\"mjx-n\" space=\"4\"><mjx-c class=\"mjx-c2264\"></mjx-c></mjx-mo><mjx-mi class=\"mjx-i\" space=\"4\"><mjx-c class=\"mjx-c1D45E TEX-I\"></mjx-c></mjx-mi><mjx-mo class=\"mjx-n\" space=\"4\"><mjx-c class=\"mjx-c2264\"></mjx-c></mjx-mo><mjx-mn class=\"mjx-n\" space=\"4\"><mjx-c class=\"mjx-c32\"></mjx-c><mjx-c class=\"mjx-c30\"></mjx-c><mjx-c class=\"mjx-c30\"></mjx-c></mjx-mn><mjx-mo class=\"mjx-n\"><mjx-c class=\"mjx-c2C\"></mjx-c></mjx-mo><mjx-mn class=\"mjx-n\" space=\"2\"><mjx-c class=\"mjx-c30\"></mjx-c><mjx-c class=\"mjx-c30\"></mjx-c><mjx-c class=\"mjx-c30\"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mn>1</mn><mo>≤</mo><mi>q</mi><mo>≤</mo><mn>200</mn><mo>,</mo><mn>000</mn></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$1\\leq q\\leq 200,000$</span></mjx-container>을 만족한다. 세 번째 줄부터 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mo class=\"mjx-n\"><mjx-c class=\"mjx-c28\"></mjx-c></mjx-mo><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D45E TEX-I\"></mjx-c></mjx-mi><mjx-mo class=\"mjx-n\" space=\"3\"><mjx-c class=\"mjx-c2B\"></mjx-c></mjx-mo><mjx-mn class=\"mjx-n\" space=\"3\"><mjx-c class=\"mjx-c32\"></mjx-c></mjx-mn><mjx-mo class=\"mjx-n\"><mjx-c class=\"mjx-c29\"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mo stretchy=\"false\">(</mo><mi>q</mi><mo>+</mo><mn>2</mn><mo stretchy=\"false\">)</mo></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$(q+2)$</span></mjx-container>번째 줄에는 질문이 주어진다. 각 질문은 알파벳 소문자 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-msub><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D6FC TEX-I\"></mjx-c></mjx-mi><mjx-script style=\"vertical-align: -0.15em;\"><mjx-mi class=\"mjx-i\" size=\"s\"><mjx-c class=\"mjx-c1D456 TEX-I\"></mjx-c></mjx-mi></mjx-script></mjx-msub></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>α</mi><mi>i</mi></msub></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$\\alpha_i$</span></mjx-container>와 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mn class=\"mjx-n\"><mjx-c class=\"mjx-c30\"></mjx-c></mjx-mn><mjx-mo class=\"mjx-n\" space=\"4\"><mjx-c class=\"mjx-c2264\"></mjx-c></mjx-mo><mjx-msub space=\"4\"><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D459 TEX-I\"></mjx-c></mjx-mi><mjx-script style=\"vertical-align: -0.15em;\"><mjx-mi class=\"mjx-i\" size=\"s\"><mjx-c class=\"mjx-c1D456 TEX-I\"></mjx-c></mjx-mi></mjx-script></mjx-msub><mjx-mo class=\"mjx-n\" space=\"4\"><mjx-c class=\"mjx-c2264\"></mjx-c></mjx-mo><mjx-msub space=\"4\"><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D45F TEX-I\"></mjx-c></mjx-mi><mjx-script style=\"vertical-align: -0.15em;\"><mjx-mi class=\"mjx-i\" size=\"s\"><mjx-c class=\"mjx-c1D456 TEX-I\"></mjx-c></mjx-mi></mjx-script></mjx-msub><mjx-mo class=\"mjx-n\" space=\"4\"><mjx-c class=\"mjx-c3C\"></mjx-c></mjx-mo><mjx-texatom space=\"4\" texclass=\"ORD\"><mjx-mo class=\"mjx-n\"><mjx-c class=\"mjx-c7C\"></mjx-c></mjx-mo></mjx-texatom><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D446 TEX-I\"></mjx-c></mjx-mi><mjx-mo class=\"mjx-n\"><mjx-c class=\"mjx-c7C\"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mn>0</mn><mo>≤</mo><msub><mi>l</mi><mi>i</mi></msub><mo>≤</mo><msub><mi>r</mi><mi>i</mi></msub><mo><</mo><mrow data-mjx-texclass=\"ORD\"><mo stretchy=\"false\">|</mo></mrow><mi>S</mi><mo stretchy=\"false\">|</mo></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$0\\leq l_i\\leq r_i<|S|$</span></mjx-container>를 만족하는 정수 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-msub><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D459 TEX-I\"></mjx-c></mjx-mi><mjx-script style=\"vertical-align: -0.15em;\"><mjx-mi class=\"mjx-i\" size=\"s\"><mjx-c class=\"mjx-c1D456 TEX-I\"></mjx-c></mjx-mi></mjx-script></mjx-msub><mjx-mo class=\"mjx-n\"><mjx-c class=\"mjx-c2C\"></mjx-c></mjx-mo><mjx-msub space=\"2\"><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D45F TEX-I\"></mjx-c></mjx-mi><mjx-script style=\"vertical-align: -0.15em;\"><mjx-mi class=\"mjx-i\" size=\"s\"><mjx-c class=\"mjx-c1D456 TEX-I\"></mjx-c></mjx-mi></mjx-script></mjx-msub></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>l</mi><mi>i</mi></msub><mo>,</mo><msub><mi>r</mi><mi>i</mi></msub></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$l_i,r_i$</span></mjx-container>가 공백으로 구분되어 주어진다.</p>','<p>각 질문마다 줄을 구분해 순서대로 답변한다. <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D456 TEX-I\"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>i</mi></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$i$</span></mjx-container>번째 줄에 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D446 TEX-I\"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>S</mi></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$S$</span></mjx-container>의 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-msub><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D459 TEX-I\"></mjx-c></mjx-mi><mjx-script style=\"vertical-align: -0.15em;\"><mjx-mi class=\"mjx-i\" size=\"s\"><mjx-c class=\"mjx-c1D456 TEX-I\"></mjx-c></mjx-mi></mjx-script></mjx-msub></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>l</mi><mi>i</mi></msub></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$l_i$</span></mjx-container>번째 문자부터 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-msub><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D45F TEX-I\"></mjx-c></mjx-mi><mjx-script style=\"vertical-align: -0.15em;\"><mjx-mi class=\"mjx-i\" size=\"s\"><mjx-c class=\"mjx-c1D456 TEX-I\"></mjx-c></mjx-mi></mjx-script></mjx-msub></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>r</mi><mi>i</mi></msub></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$r_i$</span></mjx-container>번째 문자 사이에 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-msub><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D6FC TEX-I\"></mjx-c></mjx-mi><mjx-script style=\"vertical-align: -0.15em;\"><mjx-mi class=\"mjx-i\" size=\"s\"><mjx-c class=\"mjx-c1D456 TEX-I\"></mjx-c></mjx-mi></mjx-script></mjx-msub></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>α</mi><mi>i</mi></msub></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$\\alpha_i$</span></mjx-container>가 나타나는 횟수를 출력한다.</p>','[\"누적 합\"]','[]','1 초 (추가 시간 없음)','256 MB'),
(16935,'배열 돌리기 3',10,'<p>크기가 N×M인 배열이 있을 때, 배열에 연산을 R번 적용하려고 한다. 연산은 총 6가지가 있다.</p>\n\n<p>1번 연산은 배열을 상하 반전시키는 연산이다.</p>\n\n<pre>1 6 2 9 8 4 → 4 2 9 3 1 8\n7 2 6 9 8 2 → 9 2 3 6 1 5\n1 8 3 4 2 9 → 7 4 6 2 3 1\n7 4 6 2 3 1 → 1 8 3 4 2 9\n9 2 3 6 1 5 → 7 2 6 9 8 2\n4 2 9 3 1 8 → 1 6 2 9 8 4\n   <배열>       <연산 결과>\n</pre>\n\n<p>2번 연산은 배열을 좌우 반전시키는 연산이다.</p>\n\n<pre>1 6 2 9 8 4 → 4 8 9 2 6 1\n7 2 6 9 8 2 → 2 8 9 6 2 7\n1 8 3 4 2 9 → 9 2 4 3 8 1\n7 4 6 2 3 1 → 1 3 2 6 4 7\n9 2 3 6 1 5 → 5 1 6 3 2 9\n4 2 9 3 1 8 → 8 1 3 9 2 4\n   <배열>       <연산 결과>\n</pre>\n\n<p>3번 연산은 오른쪽으로 90도 회전시키는 연산이다.</p>\n\n<pre>1 6 2 9 8 4 → 4 9 7 1 7 1\n7 2 6 9 8 2 → 2 2 4 8 2 6\n1 8 3 4 2 9 → 9 3 6 3 6 2\n7 4 6 2 3 1 → 3 6 2 4 9 9\n9 2 3 6 1 5 → 1 1 3 2 8 8\n4 2 9 3 1 8 → 8 5 1 9 2 4\n   <배열>       <연산 결과>\n</pre>\n\n<p>4번 연산은 왼쪽으로 90도 회전시키는 연산이다.</p>\n\n<pre>1 6 2 9 8 4 → 4 2 9 1 5 8\n7 2 6 9 8 2 → 8 8 2 3 1 1\n1 8 3 4 2 9 → 9 9 4 2 6 3\n7 4 6 2 3 1 → 2 6 3 6 3 9\n9 2 3 6 1 5 → 6 2 8 4 2 2\n4 2 9 3 1 8 → 1 7 1 7 9 4\n   <배열>       <연산 결과>\n</pre>\n\n<p>5, 6번 연산을 수행하려면 배열을 크기가 N/2×M/2인 4개의 부분 배열로 나눠야 한다. 아래 그림은 크기가 6×8인 배열을 4개의 그룹으로 나눈 것이고, 1부터 4까지의 수로 나타냈다.</p>\n\n<pre>1 1 1 1 2 2 2 2\n1 1 1 1 2 2 2 2\n1 1 1 1 2 2 2 2\n4 4 4 4 3 3 3 3\n4 4 4 4 3 3 3 3\n4 4 4 4 3 3 3 3</pre>\n\n<p>5번 연산은 1번 그룹의 부분 배열을 2번 그룹 위치로, 2번을 3번으로, 3번을 4번으로, 4번을 1번으로 이동시키는 연산이다.</p>\n\n<pre>3 2 6 3 1 2 9 7 → 2 1 3 8 3 2 6 3\n9 7 8 2 1 4 5 3 → 1 3 2 8 9 7 8 2\n5 9 2 1 9 6 1 8 → 4 5 1 9 5 9 2 1\n2 1 3 8 6 3 9 2 → 6 3 9 2 1 2 9 7\n1 3 2 8 7 9 2 1 → 7 9 2 1 1 4 5 3\n4 5 1 9 8 2 1 3 → 8 2 1 3 9 6 1 8\n     <배열>            <연산 결과>\n</pre>\n\n<p>6번 연산은 1번 그룹의 부분 배열을 4번 그룹 위치로, 4번을 3번으로, 3번을 2번으로, 2번을 1번으로 이동시키는 연산이다.</p>\n\n<pre>3 2 6 3 1 2 9 7 → 1 2 9 7 6 3 9 2\n9 7 8 2 1 4 5 3 → 1 4 5 3 7 9 2 1\n5 9 2 1 9 6 1 8 → 9 6 1 8 8 2 1 3\n2 1 3 8 6 3 9 2 → 3 2 6 3 2 1 3 8\n1 3 2 8 7 9 2 1 → 9 7 8 2 1 3 2 8\n4 5 1 9 8 2 1 3 → 5 9 2 1 4 5 1 9\n     <배열>            <연산 결과>\n</pre>','<p>첫째 줄에 배열의 크기 N, M과 수행해야 하는 연산의 수 R이 주어진다.</p>\n\n<p>둘째 줄부터 N개의 줄에 배열 A의 원소 A<sub>ij</sub>가 주어진다.</p>\n\n<p>마지막 줄에는 수행해야 하는 연산이 주어진다. 연산은 공백으로 구분되어져 있고, 문제에서 설명한 연산 번호이며, 순서대로 적용시켜야 한다.</p>','<p>입력으로 주어진 배열에 R개의 연산을 순서대로 수행한 결과를 출력한다.</p>','[\"구현\"]','[\"2 ≤ N, M ≤ 100\", \"1 ≤ R ≤ 1,000\", \"N, M은 짝수\", \"1 ≤ A<sub>ij</sub> ≤ 10<sup>8</sup>\"]','2 초','512 MB'),
(17070,'파이프 옮기기 1',11,'<p>유현이가 새 집으로 이사했다. 새 집의 크기는 N×N의 격자판으로 나타낼 수 있고, 1×1크기의 정사각형 칸으로 나누어져 있다. 각각의 칸은 (r, c)로 나타낼 수 있다. 여기서 r은 행의 번호, c는 열의 번호이고, 행과 열의 번호는 1부터 시작한다. 각각의 칸은 빈 칸이거나 벽이다.</p>\n\n<p>오늘은 집 수리를 위해서 파이프 하나를 옮기려고 한다. 파이프는 아래와 같은 형태이고, 2개의 연속된 칸을 차지하는 크기이다.</p>\n\n<p style=\"text-align: center;\"><img alt=\"\" src=\"https://upload.acmicpc.net/3ceac594-87df-487d-9152-c532f7136e1e/-/preview/\" style=\"width: 138px; height: 70px;\"></p>\n\n<p>파이프는 회전시킬 수 있으며, 아래와 같이 3가지 방향이 가능하다.</p>\n\n<p style=\"text-align: center;\"><img alt=\"\" src=\"https://upload.acmicpc.net/b29efafa-dbae-4522-809c-76d5c184a231/-/preview/\" style=\"width: 427px; height: 136px;\"></p>\n\n<p>파이프는 매우 무겁기 때문에, 유현이는 파이프를 밀어서 이동시키려고 한다. 벽에는 새로운 벽지를 발랐기 때문에, 파이프가 벽을 긁으면 안 된다. 즉, 파이프는 항상 빈 칸만 차지해야 한다.</p>\n\n<p>파이프를 밀 수 있는 방향은 총 3가지가 있으며, →, ↘, ↓ 방향이다. 파이프는 밀면서 회전시킬 수 있다. 회전은 45도만 회전시킬 수 있으며, 미는 방향은 오른쪽, 아래, 또는 오른쪽 아래 대각선 방향이어야 한다.</p>\n\n<p>파이프가 가로로 놓여진 경우에 가능한 이동 방법은 총 2가지, 세로로 놓여진 경우에는 2가지, 대각선 방향으로 놓여진 경우에는 3가지가 있다.</p>\n\n<p>아래 그림은 파이프가 놓여진 방향에 따라서 이동할 수 있는 방법을 모두 나타낸 것이고, 꼭 빈 칸이어야 하는 곳은 색으로 표시되어져 있다.</p>\n\n<p style=\"text-align: center;\"><img alt=\"\" src=\"https://upload.acmicpc.net/0f445b26-4e5b-4169-8a1a-89c9e115907e/-/preview/\" style=\"width: 578px; height: 203px;\"></p>\n\n<p style=\"text-align: center;\">가로</p>\n\n<p style=\"text-align: center;\"><img alt=\"\" src=\"https://upload.acmicpc.net/045d071f-0ea2-4ab5-a8db-61c215e7e7b7/-/preview/\" style=\"width: 579px; height: 203px;\"></p>\n\n<p style=\"text-align: center;\">세로</p>\n\n<p style=\"text-align: center;\"><img alt=\"\" src=\"https://upload.acmicpc.net/ace5e982-6a52-4982-b51d-6c33c6b742bf/-/preview/\" style=\"width: 886px; height: 203px;\"></p>\n\n<p style=\"text-align: center;\">대각선</p>\n\n<p>가장 처음에 파이프는 (1, 1)와 (1, 2)를 차지하고 있고, 방향은 가로이다. 파이프의 한쪽 끝을 (N, N)로 이동시키는 방법의 개수를 구해보자.</p>','<p>첫째 줄에 집의 크기 N(3 ≤ N ≤ 16)이 주어진다. 둘째 줄부터 N개의 줄에는 집의 상태가 주어진다. 빈 칸은 0, 벽은 1로 주어진다. (1, 1)과 (1, 2)는 항상 빈 칸이다.</p>','<p>첫째 줄에 파이프의 한쪽 끝을 (N, N)으로 이동시키는 방법의 수를 출력한다. 이동시킬 수 없는 경우에는 0을 출력한다. 방법의 수는 항상 1,000,000보다 작거나 같다.</p>','[\"다이나믹 프로그래밍\", \"그래프 이론\", \"그래프 탐색\"]','[]','1 초 (추가 시간 없음)','512 MB'),
(17081,'RPG Extreme',19,'<p style=\"text-align: center;\"><img alt=\"\" src=\"\" style=\"height: 240px; width: 150px;\"></p>\n\n<p>요즘 택희는 RPG 게임을 하고 있다. 던전을 헤쳐나가며 몬스터를 물리치고, 아이템을 모으고, 레벨 업을 하여 보스 몬스터를 물리치는 전형적인 RPG 게임이다.</p>\n\n<p>이 게임은 <em>N</em>×<em>M</em> 2차원 그리드 위에서 진행되며, 그리드의 각 칸에는 아래와 같은 것들이 있을 수 있다.</p>\n\n<ul>\n	<li>빈 칸(.) : 자유롭게 입장할 수 있는 칸이다. 주인공(@)은 처음에 빈 칸에서 시작한다.</li>\n	<li>벽(#) : 막힌 칸이다. 이 칸으로는 움직일 수 없다.</li>\n	<li>아이템 상자(B)\n	<ul>\n		<li>아이템 상자에는 장비 중 한 가지가 들어 있다.</li>\n		<li>장비는 무기(W), 갑옷(A), 장신구(O) 3가지로 구분되며, 알파벳 대문자는 해당 타입의 이름이다.</li>\n		<li>아이템 상자를 열어서 아이템을 얻었을 경우, 무기 / 방어구는 얻은 장비로 교체되고, 장신구의 경우엔 착용할 수 있는 칸이 남았을 경우, 그리고 동일한 효과의 장신구를 착용하지 않고 있을 경우에만 얻은 장신구를 착용한다. 장신구에 대한 설명은 아래의 주인공에 대한 설명에서 자세히 다룬다.</li>\n		<li>아이템 상자가 열리고 나면, 해당 칸은 빈 칸이 된다. 주인공은 아이템 상자를 연 이후, 아이템 상자가 있던 칸으로 이동하게 된다.</li>\n	</ul>\n	</li>\n	<li>가시 함정(^)\n	<ul>\n		<li>가시 함정은 밟았을 때 5의 데미지를 입으며, 이 데미지로 인해 사망할 수도 있다.</li>\n		<li>함정은 밟더라도 사라지지 않는다.</li>\n		<li>만약 함정 위에서 입력받은 커맨드 방향으로 움직일 수 없어 제자리에 멈추는 경우, 해당 함정을 또 밟은 것이 된다.</li>\n	</ul>\n	</li>\n	<li>몬스터(&)\n	<ul>\n		<li>몬스터는 알파벳 대소문자 문자열로 된 이름, 정수로 표시되는 공격력, 방어력, 체력, 쓰러뜨렸을 때 얻을 수 있는 경험치 값을 갖고 있다.</li>\n		<li>몬스터가 있는 칸에 입장할 경우, 몬스터와의 전투가 벌어진다. 항상 주인공 캐릭터가 선공을 하며, 한 번씩 번갈아가며 공격하여 각자 <em>max</em>(1, 내 공격력 - 상대의 방어력) 만큼의 데미지를 서로에게 한 번씩 입힌다. 한 쪽의 체력이 0 이하가 될 경우 전투는 즉시 종료된다.</li>\n		<li>몬스터가 사망할 경우, 그 자리는 빈 칸이 된다. 주인공은 승리했을 경우 이 칸으로 이동한다.</li>\n		<li>전투가 시작되고, 캐릭터 혹은 몬스터가 죽을 때 까지의 모든 과정은 한 턴 내에 이루어진다.</li>\n	</ul>\n	</li>\n	<li>보스 몬스터(M)\n	<ul>\n		<li>몬스터와 동일하다. 게임의 목표는 보스 몬스터를 처치하는 것이다.</li>\n	</ul>\n	</li>\n</ul>\n\n<p>주인공은 처음에 빈 칸 하나에서 시작한다. 주인공 캐릭터에 대한 정보는 아래와 같다.</p>\n\n<ul>\n	<li>체력, 공격력, 방어력 : 정수로 표시된다. 초기 값은 체력 20, 공격력 2, 방어력 2이다.</li>\n	<li>경험치 : 처음엔 레벨 1이며, 레벨 <em>N</em>에서 <em>N</em>+1이 되기 위한 필요 경험치는 5×<em>N</em>이다.\n	<ul>\n		<li>레벨이 오를 경우, 최대 HP가 5, 공격력과 방어력이 2씩 상승한 뒤 HP가 모두 회복된다.</li>\n		<li>경험치를 얻어 레벨이 오르게 되면, 남는 경험치는 버려진다. 예를 들어, 다음 레벨까지 필요한 경험치가 3인 상태에서 5의 경험치를 얻는다면, 레벨이 오른 다음, 남은 2의 경험치는 버려지고 0의 경험치를 갖고 있는 상태가 된다.</li>\n	</ul>\n	</li>\n	<li>무기 : 한 개만 착용할 수 있다. 각 무기는 공격력 값을 가지며, 이 값이 주인공의 공격력에 더해진다.\n	<ul>\n		<li>무기로 인한 공격력은 다른 모든 공격력 상승 효과보다 먼저 적용된다. 즉, 모든 다른 공격력 상승 효과는 무기의 공격력까지 같이 상승시킨다.</li>\n	</ul>\n	</li>\n	<li>방어구 : 한 개만 착용할 수 있다. 각 방어구는 방어력 값을 가지며, 이 값이 주인공의 방어력에 더해진다.</li>\n	<li>장신구 : 최대 4개까지 착용할 수 있으나, 동일한 효과의 장신구는 최대 하나까지만 착용 가능하다. 각 장신구에는 여러 효과가 있으며, 목록은 아래와 같다.\n	<ul>\n		<li>HP Regeneration(HR) : 전투에서 승리할 때마다 체력을 3 회복한다. 체력은 최대 체력 수치까지만 회복된다.</li>\n		<li>Reincarnation(RE) : 주인공이 사망했을 때 소멸하며, 주인공을 최대 체력으로 부활시켜 준 뒤, 주인공을 첫 시작 위치로 돌려보낸다. 레벨이나 장비 등의 다른 정보는 변함이 없다. 전투 중이던 몬스터가 있다면 해당 몬스터의 체력도 최대치로 회복된다. 소멸한 뒤에 다시 이 장신구를 얻는다면 또 착용한다.</li>\n		<li>Courage(CO) : 모든 전투에서, 첫 번째 공격에서 주인공의 공격력(무기 합산)이 두 배로 적용된다. 즉, 모든 첫 공격에서 몬스터에게 <em>max</em>(1, 공격력×2 – 몬스터의 방어력)만큼의 데미지를 입힌다.</li>\n		<li>Experience(EX) : 얻는 경험치가 1.2배가 된다. 소수점 아래는 버린다.</li>\n		<li>Dexterity(DX) : 가시 함정에 입는 데미지가 1로 고정되며, Courage 장신구와 함께 착용할 경우, Courage의 공격력 효과가 두 배로 적용되는 대신 세 배로 적용된다.</li>\n		<li>Hunter(HU) : 보스 몬스터와 전투에 돌입하는 순간 체력을 최대치까지 회복하고, 보스 몬스터의 첫 공격에 0의 데미지를 입는다.</li>\n		<li>Cursed(CU) : 아무 능력이 없으며, 그냥 장신구 한 자리를 차지한다.</li>\n	</ul>\n	</li>\n</ul>\n\n<p>주인공의 한 턴은 다음과 같은 순서대로 이루어진다.</p>\n\n<ul>\n	<li>주인공이 상하좌우로 한 칸 이동한다.</li>\n	<li>그 칸이 빈칸이라면 아무 일도 없이 지나가고, 아이템 상자, 가시 함정, 몬스터, 보스몬스터가 있을 경우 위에서 기술한 대로 각 칸에 대한 행동을 한다.</li>\n</ul>\n\n<p>주인공은 상하좌우로 한 칸씩 이동할 수 있으며, 주인공의 이동은 <em>L</em>, <em>R</em>, <em>U</em>, <em>D</em>로 이루어진 문자열 하나로 미리 모두 주어진다. <em>L</em>은 왼쪽, <em>R</em>은 오른쪽, <em>U</em>는 위, <em>D</em>는 아래를 의미한다. 움직일 수 없는 명령(벽으로 들어가거나, 그리드 밖으로 나가는 등)이 주어질 수도 있는데, 이 경우 제자리에서 이동하지 않는다.</p>\n\n<p>게임은 보스 몬스터를 처치하거나, 주인공이 (전투 또는 가시 함정에 의해) HP가 0 이하가 되어 죽거나, 입력된 문자열에 해당하는 모든 커맨드를 마쳤을 때 끝난다. 보스 몬스터를 처치해서 게임이 끝날 경우, 보스 몬스터의 경험치를 획득하고, 필요하다면 레벨 업이나 장신구 효과 등도 모두 진행한 뒤 게임이 끝나게 된다. 만약 입력이 끝나지 않았으나 게임이 끝났을 경우, 남은 입력은 모두 무시한다. 게임이 끝난 이후에는 아래와 같은 순서대로 게임의 결과를 출력해야 한다. <, > 안에 표시된 단어는 <, > 내부의 내용을 적절히 대체하고, <, >를 제거하여 출력한다.</p>\n\n<ul>\n	<li>그리드의 상태 : <em>N</em>개의 줄에 <em>M</em>개의 문자로 출력한다.\n\n	<ul>\n		<li>주인공 : @ \n		<ul>\n			<li>주인공이 있는 칸은 그 칸에 무엇이 있든(함정 등) @으로 출력한다.</li>\n			<li>만약 사망하였을 경우, 주인공은 그리드에서 사라진다. 즉, 패배한 게임에서는 @의 출력이 없다.</li>\n		</ul>\n		</li>\n		<li>빈 칸 : .</li>\n		<li>벽 : #</li>\n		<li>보스가 아닌 몬스터 : & (살아있을 경우)</li>\n		<li>보스 몬스터 : M (살아있을 경우)</li>\n		<li>가시 함정 : ^</li>\n		<li>아이템 상자 : B (열리지 않았을 경우)</li>\n	</ul>\n	</li>\n	<li>진행된 턴 수 <em>T</em>에 대해, 아래의 문자열\n	<ul>\n		<li>Passed Turns : <em>T</em></li>\n		<li>게임은 0턴에서 시작한다. 즉, 첫 이동을 마친 뒤 게임이 끝난다면 1턴이 지난 것이다.</li>\n	</ul>\n	</li>\n	<li>종료 시점의 주인공의 정보에 대해, 아래의 문자열\n	<ul>\n		<li>LV : <<em>N</em>>\n		<ul>\n			<li><em>N</em>은 주인공의 현재 레벨이다.</li>\n		</ul>\n		</li>\n		<li>HP : <<em>REM</em>>/<<em>CUR</em>>\n		<ul>\n			<li><em>REM</em>은 현재 남은 체력, <em>CUR</em>는 최대 체력이다.</li>\n			<li>만약 남은 체력이 0 미만일 경우, <em>REM</em>은 0이다.</li>\n		</ul>\n		</li>\n		<li>ATT : <<em>N</em>>+<<em>W</em>>\n		<ul>\n			<li><em>N</em>은 무기가 적용되지 않은 주인공의 공격력 값이다.</li>\n			<li><em>W</em>는 착용 중인 무기의 공격력이다. 무기가 없다면 이 값은 0이다.</li>\n		</ul>\n		</li>\n		<li>DEF : <<em>N</em>>+<<em>A</em>>\n		<ul>\n			<li><em>N</em>은 방어구가 적용되지 않은 주인공의 방어력 값이다.</li>\n			<li><em>A</em>는 착용 중인 방어구의 방어력이다. 방어구가 없다면 이 값은 0이다.</li>\n		</ul>\n		</li>\n		<li>EXP : <<em>CUR</em>>/<<em>MAX</em>>\n		<ul>\n			<li><em>CUR</em>은 현재 경험치량, <em>MAX</em>는 다음 레벨이 되는 데에 필요한 총 경험치량이다.</li>\n		</ul>\n		</li>\n	</ul>\n	</li>\n	<li>게임의 결과\n	<ul>\n		<li>보스 몬스터를 처치했을 경우 : YOU WIN!</li>\n		<li>죽었을 경우 : YOU HAVE BEEN KILLED BY <<em>S</em>>..\n		<ul>\n			<li>전투의 결과로 사망했을 경우 <em>S</em>는 몬스터의 이름, 가시 함정에 의해 사망했을 경우 <em>S</em>는 “SPIKE TRAP” 이 된다.</li>\n		</ul>\n		</li>\n		<li>입력이 끝났을 경우 : Press any key to continue.</li>\n	</ul>\n	</li>\n</ul>\n\n<p>출력 예제를 참고하면 더 쉽게 알 수 있다. 각 아이템 상자의 내용물이나, 몬스터의 정보 등은 입력으로 모두 주어지며, 입력 형식은 설명을 참조한다.</p>\n\n<p>여기까지 읽었다면 무엇을 해야 할 지 파악했을 것이다. 최선을 다해보도록 하자!</p>','<p>첫 줄에 그리드의 크기 <em>N</em>과 <em>M</em>이 주어진다. (1 ≤ <em>N</em>, <em>M</em> ≤ 100, 2 ≤ <em>N</em>×<em>M</em>)</p>\n\n<p>다음 줄부터 <em>N</em>개의 줄에 걸쳐 <em>M</em>개의 문자로 그리드의 상태가 주어진다. 주어지는 문자는 모두 본문에 설명된 것 중 하나이다.</p>\n\n<p>보스 몬스터에 해당하는 ‘M’과, 주인공에 해당하는 ‘@’은 정확히 한 개씩 있다.</p>\n\n<p>그 다음 줄에는 <em>L</em>, <em>R</em>, <em>U</em>, <em>D</em>로 이루어진 문자열 S가 주어진다. (1 ≤ |<em>S</em>| ≤ 5,000) 주인공은 문자열 <em>S</em>의 첫 글자부터 순서대로 실행한다.</p>\n\n<p>이 그리드에 있는 몬스터의 수(보스 몬스터 포함)를 <em>K</em>라 하자. 이제 <em>K</em>줄에 걸쳐 각 몬스터의 정보가 아래와 같이 주어진다.</p>\n\n<ul>\n	<li><em>R C S W A H E</em> (1 ≤ <em>R</em> ≤ <em>N</em>, 1 ≤ <em>C</em> ≤ <em>M</em>, 1 ≤ |<em>S</em>| ≤ 10, 1 ≤ <i>W</i>, <i>A</i>, <em>H</em>, <em>E</em> ≤ 20)\n\n	<ul>\n		<li>위에서부터 <em>R</em>번째 줄, 왼쪽에서부터 <em>C</em>번째 열에 있는 몬스터에 대한 정보이다. 이 칸에는 몬스터가 있음이 보장된다.</li>\n		<li><em>S</em>는 몬스터의 이름으로, 알파벳 대소문자로만 이루어진 1글자 이상, 10글자 이하의 문자열이다.\n		<ul>\n			<li>보스 몬스터를 포함해 모든 몬스터의 이름은 서로 다르다.</li>\n		</ul>\n		</li>\n		<li><i>W</i>는 몬스터의 공격력 값이다.</li>\n		<li><i>A</i>는 몬스터의 방어력 값이다.</li>\n		<li><em>H</em>는 몬스터의 최대 체력이다.</li>\n		<li><em>E</em>는 몬스터를 쓰러뜨렸을 때 얻을 수 있는 경험치이다.</li>\n	</ul>\n	</li>\n	<li>모든 몬스터에 대한 정보는 정확히 한 번씩 주어진다.</li>\n</ul>\n\n<p>이후, 그리드에 있는 아이템 상자의 수를 <em>L</em>이라 할 때, <em>L</em>줄에 걸쳐 각 상자의 정보가 아래와 같이 주어진다.</p>\n\n<ul>\n	<li><em>R C T</em> <<em>S</em>> (1 <= <em>R</em> <= <em>N</em>, 1 <= <em>C</em> <= <em>M</em>, <em>T</em> ∈ { \'W\', ‘A’, ‘O’ })</li>\n	<li>위에서부터 <em>R</em>번째 줄, 왼쪽에서부터 <em>C</em>번째 열에 있는 아이템 상자에 대한 정보이다. 이 칸에는 아이템 상자가 있음이 보장된다.</li>\n	<li><em>T</em> = \'W\', \'A\'일 경우\n	<ul>\n		<li><<em>S</em>> = <em>N</em> (1 ≤ <em>N</em> ≤ 10)</li>\n		<li><em>T</em> = \'W\'일 경우 공격력이 <em>N</em>인 무기를, <em>T </em>= \'A\'일 경우 방어력이<em> N</em>인 방어구를 의미한다.</li>\n	</ul>\n	</li>\n	<li><em>T</em> = \'O\'일 경우\n	<ul>\n		<li><<em>S</em>> ∈ { \"HR\", \"RE\", \"CO\", \"EX\", \"DX\", \"HU\", \"CU\" }</li>\n		<li>각 효과를 가진 장신구임을 의미한다. 자세한 내용은 본문을 참조한다.</li>\n	</ul>\n	</li>\n	<li>모든 아이템 상자에 대한 정보가 정확히 한 번씩 주어진다.</li>\n</ul>','<p><em>N</em>개의 줄에 <em>M</em>개의 문자로 게임이 끝난 시점의 그리드의 최종 상태를 출력한다.</p>\n\n<p><em>N</em>+1번째 줄에 진행된 턴 수를 Passed Turns : <em>T</em> 의 형태로 출력한다.</p>\n\n<p><em>N</em>+2번째 줄부터 <em>N</em>+6번째 줄까지, 주인공의 상태를 출력 예제의 형식대로 출력한다. 각 값의 의미는 본문을 참조한다.</p>\n\n<p><em>N</em>+7번째 줄에, 게임의 결과를 본문에 설명한 형식대로 출력한다.</p>\n\n<p>아래 예제 중 첫 세 개는 가능한 세 가지 게임 결과에 대한 출력 형식을 모두 담고 있으므로 참고하면 좋을 것이다.</p>','[\"구현\", \"시뮬레이션\"]','[]','5 초 ','1024 MB'),
(17144,'미세먼지 안녕!',12,'<p>미세먼지를 제거하기 위해 구사과는 공기청정기를 설치하려고 한다. 공기청정기의 성능을 테스트하기 위해 구사과는 집을 크기가 R×C인 격자판으로 나타냈고, 1×1 크기의 칸으로 나눴다. 구사과는 뛰어난 코딩 실력을 이용해 각 칸 (r, c)에 있는 미세먼지의 양을 실시간으로 모니터링하는 시스템을 개발했다. (r, c)는 r행 c열을 의미한다.</p>\n\n<p style=\"text-align: center;\"><img alt=\"\" src=\"\" style=\"width: 335px; height: 300px;\"></p>\n\n<p>공기청정기는 항상 1번 열에 설치되어 있고, 크기는 두 행을 차지한다. 공기청정기가 설치되어 있지 않은 칸에는 미세먼지가 있고, (r, c)에 있는 미세먼지의 양은 A<sub>r,c</sub>이다.</p>\n\n<p>1초 동안 아래 적힌 일이 순서대로 일어난다.</p>\n\n<ol>\n	<li>미세먼지가 확산된다. 확산은 미세먼지가 있는 모든 칸에서 동시에 일어난다.\n	<ul>\n		<li>(r, c)에 있는 미세먼지는 인접한 네 방향으로 확산된다.</li>\n		<li>인접한 방향에 공기청정기가 있거나, 칸이 없으면 그 방향으로는 확산이 일어나지 않는다.</li>\n		<li>확산되는 양은 A<sub>r,c</sub>/5이고 소수점은 버린다.</li>\n		<li>(r, c)에 남은 미세먼지의 양은 A<sub>r,c</sub> - (A<sub>r,c</sub>/5)×(확산된 방향의 개수) 이다.</li>\n	</ul>\n	</li>\n	<li>공기청정기가 작동한다.\n	<ul>\n		<li>공기청정기에서는 바람이 나온다.</li>\n		<li>위쪽 공기청정기의 바람은 반시계방향으로 순환하고, 아래쪽 공기청정기의 바람은 시계방향으로 순환한다.</li>\n		<li>바람이 불면 미세먼지가 바람의 방향대로 모두 한 칸씩 이동한다.</li>\n		<li>공기청정기에서 부는 바람은 미세먼지가 없는 바람이고, 공기청정기로 들어간 미세먼지는 모두 정화된다.</li>\n	</ul>\n	</li>\n</ol>\n\n<p>다음은 확산의 예시이다.</p>\n\n<p style=\"text-align: center;\"><img alt=\"\" src=\"\" style=\"width: 268px; height: 100px;\"></p>\n\n<p style=\"text-align: center;\">왼쪽과 오른쪽에 칸이 없기 때문에, 두 방향으로만 확산이 일어났다.</p>\n\n<p style=\"text-align: center;\"><img alt=\"\" src=\"\" style=\"width: 268px; height: 100px;\"></p>\n\n<p style=\"text-align: center;\">인접한 네 방향으로 모두 확산이 일어난다.</p>\n\n<p style=\"text-align: center;\"><img alt=\"\" src=\"\" style=\"width: 268px; height: 100px;\"></p>\n\n<p style=\"text-align: center;\">공기청정기가 있는 칸으로는 확산이 일어나지 않는다.</p>\n\n<p>공기청정기의 바람은 다음과 같은 방향으로 순환한다.</p>\n\n<p style=\"text-align: center;\"><img alt=\"\" src=\"\" style=\"width: 332px; height: 300px;\"></p>\n\n<p>방의 정보가 주어졌을 때, T초가 지난 후 구사과의 방에 남아있는 미세먼지의 양을 구해보자.</p>','<p>첫째 줄에 R, C, T (6 ≤ R, C ≤ 50, 1 ≤ T ≤ 1,000) 가 주어진다.</p>\n\n<p>둘째 줄부터 R개의 줄에 A<sub>r,c</sub> (-1 ≤ A<sub>r,c</sub> ≤ 1,000)가 주어진다. 공기청정기가 설치된 곳은 A<sub>r,c</sub>가 -1이고, 나머지 값은 미세먼지의 양이다. -1은 2번 위아래로 붙어져 있고, 가장 윗 행, 아랫 행과 두 칸이상 떨어져 있다.</p>','<p>첫째 줄에 T초가 지난 후 구사과 방에 남아있는 미세먼지의 양을 출력한다.</p>','[\"구현\", \"시뮬레이션\"]','[]','1 초','512 MB'),
(17406,'배열 돌리기 4',12,'<p>크기가 N×M 크기인 배열 A가 있을때, 배열 A의 값은 각 행에 있는 모든 수의 합 중 최솟값을 의미한다. 배열 A가 아래와 같은 경우 1행의 합은 6, 2행의 합은 4, 3행의 합은 15이다. 따라서, 배열 A의 값은 4이다.</p>\n\n<pre>1 2 3\n2 1 1\n4 5 6\n</pre>\n\n<p>배열은 회전 연산을 수행할 수 있다. 회전 연산은 세 정수 (r, c, s)로 이루어져 있고, 가장 왼쪽 윗 칸이 (r-s, c-s), 가장 오른쪽 아랫 칸이 (r+s, c+s)인 정사각형을 시계 방향으로 한 칸씩 돌린다는 의미이다. 배열의 칸 (r, c)는 r행 c열을 의미한다.</p>\n\n<p>예를 들어, 배열 A의 크기가 6×6이고, 회전 연산이 (3, 4, 2)인 경우에는 아래 그림과 같이 회전하게 된다.</p>\n\n<pre>A[1][1]   <span style=\"color:#2980b9;\">A[1][2] → A[1][3] → A[1][4] → A[1][5] → A[1][6]</span>\n<span style=\"color:#2980b9;\">             ↑                                       ↓</span>\nA[2][1]   <span style=\"color:#2980b9;\">A[2][2]   A[2][3] → A[2][4] → A[2][5]   A[2][6]</span>\n<span style=\"color:#2980b9;\">             ↑         ↑                   ↓         ↓</span>\nA[3][1]   <span style=\"color:#2980b9;\">A[3][2]   A[3][3]   A[3][4]   A[3][5]   A[3][6]</span>\n<span style=\"color:#2980b9;\">             ↑         ↑                   ↓         ↓</span>\nA[4][1]   <span style=\"color:#2980b9;\">A[4][2]   A[4][3] ← A[4][4] ← A[4][5]   A[4][6]</span>\n<span style=\"color:#2980b9;\">             ↑                                       ↓</span>\nA[5][1]   <span style=\"color:#2980b9;\">A[5][2] ← A[5][3] ← A[5][4] ← A[5][5] ← A[5][6]</span>\n\nA[6][1]   A[6][2]   A[6][3]   A[6][4]   A[6][5]   A[6][6]\n</pre>\n\n<p>회전 연산이 두 개 이상이면, 연산을 수행한 순서에 따라 최종 배열이 다르다.</p>\n\n<p>다음은 배열 A의 크기가 5×6이고, 회전 연산이 (3, 4, 2), (4, 2, 1)인 경우의 예시이다.</p>\n\n<table class=\"table table-bordered\" style=\"width: 100%;\">\n	<tbody>\n		<tr>\n			<td style=\"text-align: center; width: 33%;\">\n			<pre>1 2 3 2 5 6\n3 8 7 2 1 3\n8 2 3 1 4 5\n3 4 5 1 1 1\n9 3 2 1 4 3</pre>\n			</td>\n			<td style=\"text-align: center; width: 34%;\">\n			<pre>1 <span style=\"color:#2980b9;\">8 2 3 2 5</span>\n3 <span style=\"color:#2980b9;\">2 3 7 2 6</span>\n8 <span style=\"color:#2980b9;\">4 5 1 1 3</span>\n3 <span style=\"color:#2980b9;\">3 1 1 4 5</span>\n9 <span style=\"color:#2980b9;\">2 1 4 3 1</span></pre>\n			</td>\n			<td style=\"text-align: center; width: 33%;\">\n			<pre>1 8 2 3 2 5\n3 2 3 7 2 6\n<span style=\"color:#2980b9;\">3 8 4</span> 1 1 3\n<span style=\"color:#2980b9;\">9 3 5</span> 1 4 5\n<span style=\"color:#2980b9;\">2 1 1</span> 4 3 1</pre>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"text-align: center; width: 33%;\">배열 A</td>\n			<td style=\"text-align: center; width: 34%;\">(3, 4, 2) 연산 수행 후</td>\n			<td style=\"text-align: center; width: 33%;\">(4, 2, 1) 연산 수행 후</td>\n		</tr>\n		<tr>\n			<td style=\"text-align: center; width: 33%;\">\n			<pre>1 2 3 2 5 6\n3 8 7 2 1 3\n8 2 3 1 4 5\n3 4 5 1 1 1\n9 3 2 1 4 3</pre>\n			</td>\n			<td style=\"text-align: center; width: 34%;\">\n			<pre>1 2 3 2 5 6\n3 8 7 2 1 3\n<span style=\"color:#2980b9;\">3 8 2</span> 1 4 5\n<span style=\"color:#2980b9;\">9 4 3</span> 1 1 1\n<span style=\"color:#2980b9;\">3 2 5</span> 1 4 3</pre>\n			</td>\n			<td style=\"text-align: center; width: 33%;\">\n			<pre>1 <span style=\"color:#2980b9;\">8 2 3 2 5</span>\n3 <span style=\"color:#2980b9;\">8 2 7 2 6</span>\n3 <span style=\"color:#2980b9;\">4 3 1 1 3</span>\n9 <span style=\"color:#2980b9;\">2 1 1 4 5</span>\n3 <span style=\"color:#2980b9;\">5 1 4 3 1</span></pre>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"text-align: center; width: 33%;\">배열 A</td>\n			<td style=\"text-align: center; width: 34%;\">(4, 2, 1) 연산 수행 후</td>\n			<td style=\"text-align: center; width: 33%;\">(3, 4, 2) 연산 수행 후</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>배열 A에 (3, 4, 2), (4, 2, 1) 순서로 연산을 수행하면 배열 A의 값은 12, (4, 2, 1), (3, 4, 2) 순서로 연산을 수행하면 15 이다.</p>\n\n<p>배열 A와 사용 가능한 회전 연산이 주어졌을 때, 배열 A의 값의 최솟값을 구해보자. 회전 연산은 모두 한 번씩 사용해야 하며, 순서는 임의로 정해도 된다.</p>','<p>첫째 줄에 배열 A의 크기 N, M, 회전 연산의 개수 K가 주어진다.</p>\n\n<p>둘째 줄부터 N개의 줄에 배열 A에 들어있는 수 A[i][j]가 주어지고, 다음 K개의 줄에 회전 연산의 정보 r, c, s가 주어진다.</p>','<p>배열 A의 값의 최솟값을 출력한다.</p>','[\"구현\", \"브루트포스 알고리즘\", \"백트래킹\"]','[\"3 ≤ N, M ≤ 50\", \"1 ≤ K ≤ 6\", \"1 ≤ A[i][j] ≤ 100\", \"1 ≤ s\", \"1 ≤ r-s < r < r+s ≤ N\", \"1 ≤ c-s < c < c+s ≤ M\"]','1 초','512 MB'),
(17485,'진우의 달 여행 (Large)',11,'<p>우주비행이 꿈이였던 진우는 음식점 \'매일매일싱싱\'에서 열심히 일한 결과 달 여행에 필요한 자금을 모두 마련하였다! 지구와 우주사이는 N X M 행렬로 나타낼 수 있으며 각 원소의 값은 우주선이 그 공간을 지날 때 소모되는 연료의 양이다.</p>\n\n<p style=\"text-align: center;\">[예시]</p>\n\n<p style=\"text-align: center;\"><img alt=\"\" src=\"https://upload.acmicpc.net/9e155c65-43ea-492b-af73-d3f9f9c9dc44/-/preview/\" style=\"height: 353px; width: 150px;\"></p>\n\n<p>진우는 여행경비를 아끼기 위해 조금 특이한 우주선을 선택하였다. 진우가 선택한 우주선의 특징은 아래와 같다.</p>\n\n<p><strong>1. 지구 -> 달로 가는 경우 우주선이 움직일 수 있는 방향은 아래와 같다.</strong></p>\n\n<p><img alt=\"\" src=\"https://upload.acmicpc.net/8f6fc516-9870-4ef6-8474-b5d82f7b6f21/-/preview/\" style=\"width: 200px; height: 200px;\"><img alt=\"\" src=\"https://upload.acmicpc.net/eb6f87f0-f4d0-43cc-8e9d-5d94bfc41936/-/preview/\" style=\"width: 200px; height: 200px;\"><img alt=\"\" src=\"https://upload.acmicpc.net/e7b501aa-c92c-4a17-aed7-c7868b89af7a/-/preview/\" style=\"width: 200px; height: 200px;\"></p>\n\n<p><strong>2. 우주선은 전에 움직인 방향으로 움직일 수 없다. 즉, 같은 방향으로 두번 연속으로 움직일 수 없다.</strong></p>\n\n<p>진우의 목표는 <strong>연료를 최대한 아끼며 지구의 어느위치에서든 출발하여 달의 어느위치든 착륙하는 것</strong>이다.</p>\n\n<p>최대한 돈을 아끼고 살아서 달에 도착하고 싶은 진우를 위해 달에 도달하기 위해 필요한 연료의 최소값을 계산해 주자.</p>','<p>첫줄에 지구와 달 사이 공간을 나타내는 행렬의 크기를 나타내는 <strong>N, M (2 ≤ N, M ≤ 1000)</strong>이 주어진다.</p>\n\n<p>다음 N줄 동안 각 행렬의 원소 값이 주어진다. 각 행렬의 원소값은 100 이하의 자연수이다.</p>','<p>달 여행에 필요한 최소 연료의 값을 출력한다.</p>','[\"다이나믹 프로그래밍\"]','[]','1 초','256 MB'),
(21610,'마법사 상어와 비바라기',11,'<p>마법사 상어는 <a href=\"/problem/20056\">파이어볼</a>, <a href=\"/problem/20057\">토네이도</a>, <a href=\"/problem/20058\">파이어스톰</a>, 물복사버그 마법을 할 수 있다. 오늘 새로 배운 마법은 비바라기이다. 비바라기를 시전하면 하늘에 비구름을 만들 수 있다. 오늘은 비바라기를 크기가 N×N인 격자에서 연습하려고 한다. 격자의 각 칸에는 바구니가 하나 있고, 바구니는 칸 전체를 차지한다. 바구니에 저장할 수 있는 물의 양에는 제한이 없다. (r, c)는 격자의 r행 c열에 있는 바구니를 의미하고, A[r][c]는 (r, c)에 있는 바구니에 저장되어 있는 물의 양을 의미한다.</p>\n\n<p>격자의 가장 왼쪽 윗 칸은 (1, 1)이고, 가장 오른쪽 아랫 칸은 (N, N)이다. 마법사 상어는 연습을 위해 1번 행과 N번 행을 연결했고, 1번 열과 N번 열도 연결했다. 즉, N번 행의 아래에는 1번 행이, 1번 행의 위에는 N번 행이 있고, 1번 열의 왼쪽에는 N번 열이, N번 열의 오른쪽에는 1번 열이 있다.</p>\n\n<p>비바라기를 시전하면 (N, 1), (N, 2), (N-1, 1), (N-1, 2)에 비구름이 생긴다. 구름은 칸 전체를 차지한다. 이제 구름에 이동을 M번 명령하려고 한다. i번째 이동 명령은 방향 d<sub>i</sub>과 거리 s<sub>i</sub>로 이루어져 있다. 방향은 총 8개의 방향이 있으며, 8개의 정수로 표현한다. 1부터 순서대로 ←, ↖, ↑, ↗, →, ↘, ↓, ↙ 이다. 이동을 명령하면 다음이 순서대로 진행된다.</p>\n\n<ol>\n	<li>모든 구름이 d<sub>i</sub> 방향으로 s<sub>i</sub>칸 이동한다.</li>\n	<li>각 구름에서 비가 내려 구름이 있는 칸의 바구니에 저장된 물의 양이 1 증가한다.</li>\n	<li>구름이 모두 사라진다.</li>\n	<li>2에서 물이 증가한 칸 (r, c)에 물복사버그 마법을 시전한다. 물복사버그 마법을 사용하면, 대각선 방향으로 거리가 1인 칸에 물이 있는 바구니의 수만큼 (r, c)에 있는 바구니의 물이 양이 증가한다.\n	<ul>\n		<li>이때는 이동과 다르게 경계를 넘어가는 칸은 대각선 방향으로 거리가 1인 칸이 아니다.</li>\n		<li>예를 들어, (N, 2)에서 인접한 대각선 칸은 (N-1, 1), (N-1, 3)이고, (N, N)에서 인접한 대각선 칸은 (N-1, N-1)뿐이다.</li>\n	</ul>\n	</li>\n	<li>바구니에 저장된 물의 양이 2 이상인 모든 칸에 구름이 생기고, 물의 양이 2 줄어든다. 이때 구름이 생기는 칸은 3에서 구름이 사라진 칸이 아니어야 한다.</li>\n</ol>\n\n<p>M번의 이동이 모두 끝난 후 바구니에 들어있는 물의 양의 합을 구해보자.</p>','<p>첫째 줄에 N, M이 주어진다.</p>\n\n<p>둘째 줄부터 N개의 줄에는 N개의 정수가 주어진다. r번째 행의 c번째 정수는 A[r][c]를 의미한다.</p>\n\n<p>다음 M개의 줄에는 이동의 정보 d<sub>i</sub>, s<sub>i</sub>가 순서대로 한 줄에 하나씩 주어진다.</p>','<p>첫째 줄에 M번의 이동이 모두 끝난 후 바구니에 들어있는 물의 양의 합을 출력한다.</p>','[\"구현\", \"시뮬레이션\"]','[\"2 ≤ N ≤ 50\", \"1 ≤ M ≤ 100\", \"0 ≤ A[r][c] ≤ 100\", \"1 ≤ d<sub>i</sub> ≤ 8\", \"1 ≤ s<sub>i</sub><sub> </sub>≤ 50\"]','1 초 (추가 시간 없음)','1024 MB'),
(24727,'인지융~',13,'<p>연세대학교는 2022년부터 인공지능융합대학이라는 단과대를 새로 만들고, 기존 공과대학 소속이었던 컴퓨터과학과를 해당 단과대로 보내버렸다. 하지만 아직 인공지능융합대학 건물이 지어지지 않았기 때문에, 학생들은 여전히 공학관을 사용하고 있다.</p>\n\n<p>이에 공과대학의 다른 학과 학생들이 컴퓨터과학과 학생들을 놀리기 시작했다!</p>\n\n<p>화가 난 컴퓨터과학과 학생들은 바리케이드를 쳐 다른 공과대학 학생들이 접근하지 못하게 하였다. 하지만 실수로 다른 학과의 공간을 침범해 버려, 성난 학생들과 교수님들이 바리케이드를 부숴버렸다!</p>\n\n<p>결국 긴 시간의 협상 끝에, 공과대학 측이 필요한 공간의 크기와 컴퓨터과학과가 필요한 공간의 크기를 미리 제출한 후, 각각 크기를 보장하면서 바리케이드를 치기로 합의하였다.</p>\n\n<p>공학관은 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D441 TEX-I\"></mjx-c></mjx-mi><mjx-mo class=\"mjx-n\" space=\"3\"><mjx-c class=\"mjx-cD7\"></mjx-c></mjx-mo><mjx-mi class=\"mjx-i\" space=\"3\"><mjx-c class=\"mjx-c1D441 TEX-I\"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>N</mi><mo>×</mo><mi>N</mi></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$N \\times N$</span></mjx-container> 크기의 정사각형 모양이고, 바리케이드를 친 이후 컴퓨터과학과의 공간과 공과대학 측의 공간은 연결되어 있지 않아야 하나, 각자의 공간은 모두 연결되어 있어야 한다.</p>\n\n<p>여기서 \"연결\"이라 함은, 어떤 공간이 상하좌우로 인접해 있는 것을 말한다.</p>\n\n<p>예를 들어, 다음 그림에서 왼쪽의 경우 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D434 TEX-I\"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>A</mi></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$A$</span></mjx-container>공간과 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D435 TEX-I\"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>B</mi></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$B$</span></mjx-container>공간은 연결되어 있지 않다고 볼 수 있으며, 오른쪽의 경우 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D434 TEX-I\"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>A</mi></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$A$</span></mjx-container>공간과 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D435 TEX-I\"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>B</mi></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$B$</span></mjx-container>공간이 연결되었다고 볼 수 있다.</p>\n\n\n<p style=\"text-align: center;\"><img alt=\"\" src=\"https://upload.acmicpc.net/131c5e52-3ae0-4cb0-ab1b-8188f3684a6a/-/preview/\" width=\"650px\"></p>\n\n<p>또한, 싸움이 나는 것을 방지하기 위해 정확히 제출한 크기만큼의 공간만 제공되어야 한다.</p>\n\n<p>공학관의 크기와 컴퓨터과학과, 공과대학 측이 제출한 공간의 크기가 주어졌을 때, 어떤 식으로 공간을 나눠야 할지 구해보자.</p>','<p>첫 줄에는 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D441 TEX-I\"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>N</mi></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$N$</span></mjx-container> 이 주어진다. <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mo class=\"mjx-n\"><mjx-c class=\"mjx-c28\"></mjx-c></mjx-mo><mjx-mn class=\"mjx-n\"><mjx-c class=\"mjx-c31\"></mjx-c></mjx-mn><mjx-mo class=\"mjx-n\" space=\"4\"><mjx-c class=\"mjx-c2264\"></mjx-c></mjx-mo><mjx-mi class=\"mjx-i\" space=\"4\"><mjx-c class=\"mjx-c1D441 TEX-I\"></mjx-c></mjx-mi><mjx-mo class=\"mjx-n\" space=\"4\"><mjx-c class=\"mjx-c2264\"></mjx-c></mjx-mo><mjx-mn class=\"mjx-n\" space=\"4\"><mjx-c class=\"mjx-c31\"></mjx-c><mjx-c class=\"mjx-c30\"></mjx-c><mjx-c class=\"mjx-c30\"></mjx-c></mjx-mn><mjx-mo class=\"mjx-n\"><mjx-c class=\"mjx-c29\"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mo stretchy=\"false\">(</mo><mn>1</mn><mo>≤</mo><mi>N</mi><mo>≤</mo><mn>100</mn><mo stretchy=\"false\">)</mo></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$(1 \\le N \\le 100)$</span> </mjx-container></p>\n\n<p>두 번째 줄에는 컴퓨터과학과가 필요한 공간의 크기 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D436 TEX-I\"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>C</mi></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$C$</span></mjx-container>, 다른 공과대학 학과들이 필요한 공간의 크기 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D438 TEX-I\"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>E</mi></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$E$</span></mjx-container>가 주어진다. <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mo class=\"mjx-n\"><mjx-c class=\"mjx-c28\"></mjx-c></mjx-mo><mjx-mn class=\"mjx-n\"><mjx-c class=\"mjx-c31\"></mjx-c></mjx-mn><mjx-mo class=\"mjx-n\" space=\"4\"><mjx-c class=\"mjx-c2264\"></mjx-c></mjx-mo><mjx-mi class=\"mjx-i\" space=\"4\"><mjx-c class=\"mjx-c1D436 TEX-I\"></mjx-c></mjx-mi><mjx-mo class=\"mjx-n\"><mjx-c class=\"mjx-c2C\"></mjx-c></mjx-mo><mjx-mi class=\"mjx-i\" space=\"2\"><mjx-c class=\"mjx-c1D438 TEX-I\"></mjx-c></mjx-mi><mjx-mo class=\"mjx-n\" space=\"4\"><mjx-c class=\"mjx-c2264\"></mjx-c></mjx-mo><mjx-msup space=\"4\"><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D441 TEX-I\"></mjx-c></mjx-mi><mjx-script style=\"vertical-align: 0.363em; margin-left: 0.054em;\"><mjx-mn class=\"mjx-n\" size=\"s\"><mjx-c class=\"mjx-c32\"></mjx-c></mjx-mn></mjx-script></mjx-msup><mjx-mo class=\"mjx-n\"><mjx-c class=\"mjx-c29\"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mo stretchy=\"false\">(</mo><mn>1</mn><mo>≤</mo><mi>C</mi><mo>,</mo><mi>E</mi><mo>≤</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$(1 \\le C, E \\le N ^ 2)$</span> </mjx-container></p>','<p>주어진 조건을 맞춰 공간을 나눌 수 없다면 <span style=\"color:#e74c3c;\"><code>-1</code></span>을 출력한다.</p>\n\n<p>주어진 조건을 맞춰 공간을 분할할 수 있다면, 첫 줄에 <span style=\"color:#e74c3c;\"><code>1</code></span>을 출력한다. 또한, 두 번째 줄부터 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D441 TEX-I\"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>N</mi></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$N$</span></mjx-container>줄에 걸쳐 공간을 나눈 결과를 출력한다. 여기서 <span style=\"color:#e74c3c;\"><code>1</code></span>은 컴퓨터과학과의 공간, <span style=\"color:#e74c3c;\"><code>2</code></span>는 공과대학의 공간이며, <code><span style=\"color:#e74c3c;\">0</span></code>은 바리케이드다.</p>','[\"애드 혹\", \"해 구성하기\"]','[]','1 초 (추가 시간 없음)','1024 MB (추가 메모리 없음)'),
(25314,'코딩은 체육과목 입니다',1,'<p style=\"margin-bottom: 15px;\"><img alt=\"\" src=\"\" style=\"display: block; margin-left: auto; margin-right: auto; width: 100%; max-width: 400px;\"></p>\n\n<p>오늘은 혜아의 면접 날이다. 면접 준비를 열심히 해서 앞선 질문들을 잘 대답한 혜아는 이제 마지막으로 칠판에 직접 코딩하는 문제를 받았다. 혜아가 받은 문제는 두 수를 더하는 문제였다. C++ 책을 열심히 읽었던 혜아는 간단히 두 수를 더하는 코드를 칠판에 적었다. 코드를 본 면접관은 다음 질문을 했다. “만약, 입출력이 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D441 TEX-I\"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>N</mi></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$N$</span></mjx-container>바이트 크기의 정수라면 프로그램을 어떻게 구현해야 할까요?”</p>\n\n<p>혜아는 책에 있는 정수 자료형과 관련된 내용을 기억해 냈다. 책에는 <span style=\"color:#e74c3c;\"><code>long int</code></span>는 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mn class=\"mjx-n\"><mjx-c class=\"mjx-c34\"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mn>4</mn></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$4$</span></mjx-container>바이트 정수까지 저장할 수 있는 정수 자료형이고 <span style=\"color:#e74c3c;\"><code>long long int</code></span>는 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mn class=\"mjx-n\"><mjx-c class=\"mjx-c38\"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mn>8</mn></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$8$</span></mjx-container>바이트 정수까지 저장할 수 있는 정수 자료형이라고 적혀 있었다. 혜아는 이런 생각이 들었다. “<span style=\"color:#e74c3c;\"><code>int</code></span> 앞에 <span style=\"color:#e74c3c;\"><code>long</code></span>을 하나씩 더 붙일 때마다 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mn class=\"mjx-n\"><mjx-c class=\"mjx-c34\"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mn>4</mn></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$4$</span></mjx-container>바이트씩 저장할 수 있는 공간이 늘어나는 걸까? 분명 <span style=\"color:#e74c3c;\"><code>long long long int</code></span>는 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mn class=\"mjx-n\"><mjx-c class=\"mjx-c31\"></mjx-c><mjx-c class=\"mjx-c32\"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mn>12</mn></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$12$</span></mjx-container>바이트, <span style=\"color:#e74c3c;\"><code>long long long long int</code></span>는 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mn class=\"mjx-n\"><mjx-c class=\"mjx-c31\"></mjx-c><mjx-c class=\"mjx-c36\"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mn>16</mn></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$16$</span></mjx-container>바이트까지 저장할 수 있는 정수 자료형일 거야!” 그렇게 혜아는 당황하는 면접관의 얼굴을 뒤로한 채 칠판에 정수 자료형을 써 내려가기 시작했다.</p>\n\n<p>혜아가 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D441 TEX-I\"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>N</mi></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$N$</span></mjx-container>바이트 정수까지 저장할 수 있다고 생각해서 칠판에 쓴 정수 자료형의 이름은 무엇일까?</p>','<p>첫 번째 줄에는 문제의 정수 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D441 TEX-I\"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>N</mi></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$N$</span></mjx-container>이 주어진다. <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mo class=\"mjx-n\"><mjx-c class=\"mjx-c28\"></mjx-c></mjx-mo><mjx-mn class=\"mjx-n\"><mjx-c class=\"mjx-c34\"></mjx-c></mjx-mn><mjx-mo class=\"mjx-n\" space=\"4\"><mjx-c class=\"mjx-c2264\"></mjx-c></mjx-mo><mjx-mi class=\"mjx-i\" space=\"4\"><mjx-c class=\"mjx-c1D441 TEX-I\"></mjx-c></mjx-mi><mjx-mo class=\"mjx-n\" space=\"4\"><mjx-c class=\"mjx-c2264\"></mjx-c></mjx-mo><mjx-mn class=\"mjx-n\" space=\"4\"><mjx-c class=\"mjx-c31\"></mjx-c></mjx-mn><mjx-mstyle><mjx-mspace style=\"width: 0.167em;\"></mjx-mspace></mjx-mstyle><mjx-mn class=\"mjx-n\"><mjx-c class=\"mjx-c30\"></mjx-c><mjx-c class=\"mjx-c30\"></mjx-c><mjx-c class=\"mjx-c30\"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mo stretchy=\"false\">(</mo><mn>4</mn><mo>≤</mo><mi>N</mi><mo>≤</mo><mn>1</mn><mstyle scriptlevel=\"0\"><mspace width=\"0.167em\"></mspace></mstyle><mn>000</mn></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$(4\\le N\\le 1\\, 000$</span></mjx-container>; <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D441 TEX-I\"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>N</mi></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$N$</span></mjx-container>은 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mn class=\"mjx-n\"><mjx-c class=\"mjx-c34\"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mn>4</mn></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$4$</span></mjx-container>의 배수<mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mo class=\"mjx-n\"><mjx-c class=\"mjx-c29\"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mo stretchy=\"false\">)</mo></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$)$</span> </mjx-container></p>','<p>혜아가 <mjx-container class=\"MathJax\" jax=\"CHTML\" style=\"font-size: 109%; position: relative;\"><mjx-math class=\"MJX-TEX\" aria-hidden=\"true\"><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D441 TEX-I\"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>N</mi></math></mjx-assistive-mml><span aria-hidden=\"true\" class=\"no-mathjax mjx-copytext\">$N$</span></mjx-container>바이트 정수까지 저장할 수 있다고 생각하는 정수 자료형의 이름을 출력하여라.</p>','[\"구현\"]','[]','0.5 초 (추가 시간 없음)','1024 MB (추가 메모리 없음)');
/*!40000 ALTER TABLE `problem` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `problem_meta`
--

DROP TABLE IF EXISTS `problem_meta`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `problem_meta` (
  `problem_id` bigint(20) NOT NULL AUTO_INCREMENT,
  `problem_title` text DEFAULT NULL,
  `problem_submitted_count` bigint(20) DEFAULT NULL,
  `problem_master_user_seq` bigint(20) DEFAULT NULL,
  PRIMARY KEY (`problem_id`)
) ENGINE=InnoDB AUTO_INCREMENT=25315 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `problem_meta`
--

LOCK TABLES `problem_meta` WRITE;
/*!40000 ALTER TABLE `problem_meta` DISABLE KEYS */;
INSERT INTO `problem_meta` VALUES
(1000,'A+B',6,3),
(1001,'A-B',1,6),
(1002,'터렛',2,7),
(1003,'피보나치 함수',3,7),
(1008,'A/B',1,1),
(1012,'유기농 배추',2,1),
(1015,'수열 정렬',1,6),
(1049,'기타줄',1,6),
(1111,'IQ Test',1,2),
(1157,'단어 공부',1,7),
(1520,'내리막 길',1,12),
(1806,'부분합',1,3),
(2110,'공유기 설치',1,1),
(2557,'Hello World',1,6),
(3040,'백설 공주와 일곱 난쟁이',1,9),
(3649,'로봇 프로젝트',1,2),
(5052,'전화번호 목록',1,4),
(7569,'토마토',1,7),
(10026,'적록색약',1,2),
(10950,'A+B - 3',4,7),
(14499,'주사위 굴리기',1,15),
(14500,'테트로미노',1,6),
(14502,'연구소',1,6),
(14503,'로봇 청소기',1,6),
(14890,'경사로',1,6),
(15652,'N과 M (4)',1,19),
(16139,'인간-컴퓨터 상호작용',1,2),
(16935,'배열 돌리기 3',1,2),
(17070,'파이프 옮기기 1',1,7),
(17081,'RPG Extreme',1,4),
(17144,'미세먼지 안녕!',1,2),
(17406,'배열 돌리기 4',1,7),
(17485,'진우의 달 여행 (Large)',1,4),
(21610,'마법사 상어와 비바라기',1,6),
(24727,'인지융~',2,7),
(25314,'코딩은 체육과목 입니다',1,21);
/*!40000 ALTER TABLE `problem_meta` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `user`
--

DROP TABLE IF EXISTS `user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `user` (
  `user_seq` bigint(20) NOT NULL AUTO_INCREMENT,
  `user_backjoon_id` varchar(255) DEFAULT NULL,
  `user_created_at` datetime(6) DEFAULT NULL,
  `user_github_id` varchar(255) NOT NULL,
  PRIMARY KEY (`user_seq`),
  KEY `user_github_id` (`user_github_id`),
  KEY `idx_user_seq` (`user_seq`)
) ENGINE=InnoDB AUTO_INCREMENT=22 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `user`
--

LOCK TABLES `user` WRITE;
/*!40000 ALTER TABLE `user` DISABLE KEYS */;
INSERT INTO `user` VALUES
(1,'parkdh9018','2023-05-10 10:35:04.670594','parkdh9018'),
(2,'dldksco','2023-05-10 10:35:07.714494','dldksco'),
(3,'woonchoi','2023-05-10 10:41:13.780277','woonchoi'),
(4,'dldusgkr788','2023-05-10 10:41:35.144355','PlzNoErr'),
(6,'alice2596','2023-05-10 12:35:51.716918','s5hyeonkim'),
(7,'rkshktmshk','2023-05-10 12:38:42.820434','chancehee'),
(8,'cladren123','2023-05-11 15:58:41.550520','cladren123'),
(9,'dldksco','2023-05-11 17:46:50.941579','dldksco123'),
(10,'2sy0127','2023-05-12 13:07:29.737641','ssooynn'),
(11,'gyj118','2023-05-12 23:24:10.706355','wjddusgh'),
(12,'thereisnotruth12','2023-05-15 01:13:55.442120','Thereisnotruth'),
(15,'alice2596','2023-05-15 16:16:24.835635','Kim-Sohyeony'),
(16,'NO_SUBMITTED','2023-05-15 18:57:48.759617','Byongho96'),
(17,'NO_SUBMITTED','2023-05-16 14:56:31.587884','xordbs'),
(18,'NO_SUBMITTED','2023-05-16 18:22:16.103722','ggyu-seong'),
(19,'kimsy7','2023-05-17 20:21:13.854133','yongseong2'),
(20,'NO_SUBMITTED','2023-05-18 00:18:40.213539','userOfAlgopat'),
(21,'benmk425','2023-05-18 00:37:12.254986','benmk425');
/*!40000 ALTER TABLE `user` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `user_image`
--

DROP TABLE IF EXISTS `user_image`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `user_image` (
  `user_image_seq` bigint(20) NOT NULL AUTO_INCREMENT,
  `user_image_created_at` datetime(6) NOT NULL,
  `user_image_updated_at` datetime(6) DEFAULT NULL,
  `user_image_url` varchar(255) DEFAULT NULL,
  `user_seq` bigint(20) DEFAULT NULL,
  PRIMARY KEY (`user_image_seq`),
  KEY `user_seq` (`user_seq`),
  CONSTRAINT `FKidt4nxu25s37qlm00tyyud3o8` FOREIGN KEY (`user_seq`) REFERENCES `user` (`user_seq`)
) ENGINE=InnoDB AUTO_INCREMENT=22 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `user_image`
--

LOCK TABLES `user_image` WRITE;
/*!40000 ALTER TABLE `user_image` DISABLE KEYS */;
INSERT INTO `user_image` VALUES
(1,'2023-05-10 10:35:04.716554','2023-05-10 10:35:04.716554','https://avatars.githubusercontent.com/u/22982297?v=4',1),
(2,'2023-05-10 10:35:07.718047','2023-05-10 10:35:07.718047','https://avatars.githubusercontent.com/u/117557800?v=4',2),
(3,'2023-05-10 10:41:13.782279','2023-05-10 10:41:13.782279','https://avatars.githubusercontent.com/u/83646178?v=4',3),
(4,'2023-05-10 10:41:35.147981','2023-05-10 10:41:35.147981','https://avatars.githubusercontent.com/u/108788547?v=4',4),
(6,'2023-05-10 12:35:51.719021','2023-05-10 12:35:51.719021','https://avatars.githubusercontent.com/u/122209131?v=4',6),
(7,'2023-05-10 12:38:42.822162','2023-05-10 12:38:42.822162','https://avatars.githubusercontent.com/u/59447235?v=4',7),
(8,'2023-05-11 15:58:41.574582','2023-05-11 15:58:41.574582','https://avatars.githubusercontent.com/u/48821942?v=4',8),
(9,'2023-05-11 17:46:50.943679','2023-05-11 17:46:50.943679','https://avatars.githubusercontent.com/u/131981049?v=4',9),
(10,'2023-05-12 13:07:29.740532','2023-05-12 13:07:29.740532','https://avatars.githubusercontent.com/u/74709068?v=4',10),
(11,'2023-05-12 23:24:10.708341','2023-05-12 23:24:10.708341','https://avatars.githubusercontent.com/u/69251780?v=4',11),
(12,'2023-05-15 01:13:55.444429','2023-05-15 01:13:55.444429','https://avatars.githubusercontent.com/u/53485050?v=4',12),
(15,'2023-05-15 16:16:24.899803','2023-05-15 16:16:24.899803','https://avatars.githubusercontent.com/u/106232383?v=4',15),
(16,'2023-05-15 18:57:48.772163','2023-05-15 18:57:48.772163','https://avatars.githubusercontent.com/u/47059013?v=4',16),
(17,'2023-05-16 14:56:31.597893','2023-05-16 14:56:31.597893','https://avatars.githubusercontent.com/u/88662213?v=4',17),
(18,'2023-05-16 18:22:16.105128','2023-05-16 18:22:16.105128','https://avatars.githubusercontent.com/u/90883945?v=4',18),
(19,'2023-05-17 20:21:13.856338','2023-05-17 20:21:13.856338','https://avatars.githubusercontent.com/u/122865525?v=4',19),
(20,'2023-05-18 00:18:40.215327','2023-05-18 00:18:40.215327','https://avatars.githubusercontent.com/u/133892812?v=4',20),
(21,'2023-05-18 00:37:12.256465','2023-05-18 00:37:12.256465','https://avatars.githubusercontent.com/u/123550892?v=4',21);
/*!40000 ALTER TABLE `user_image` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `user_status`
--

DROP TABLE IF EXISTS `user_status`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `user_status` (
  `user_status_seq` bigint(20) NOT NULL AUTO_INCREMENT,
  `user_status_created_at` datetime(6) DEFAULT NULL,
  `user_status_status` varchar(255) DEFAULT NULL,
  `user_seq` bigint(20) DEFAULT NULL,
  PRIMARY KEY (`user_status_seq`),
  KEY `user_seq` (`user_seq` DESC),
  CONSTRAINT `FK2hqqfvg6a13ljhl58kv5ucvrr` FOREIGN KEY (`user_seq`) REFERENCES `user` (`user_seq`)
) ENGINE=InnoDB AUTO_INCREMENT=22 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `user_status`
--

LOCK TABLES `user_status` WRITE;
/*!40000 ALTER TABLE `user_status` DISABLE KEYS */;
INSERT INTO `user_status` VALUES
(1,'2023-05-10 10:35:04.704115','AVAILABLE',1),
(2,'2023-05-10 10:35:07.716006','AVAILABLE',2),
(3,'2023-05-10 10:41:13.781380','AVAILABLE',3),
(4,'2023-05-10 10:41:35.145490','AVAILABLE',4),
(6,'2023-05-10 12:35:51.718121','AVAILABLE',6),
(7,'2023-05-10 12:38:42.821416','AVAILABLE',7),
(8,'2023-05-11 15:58:41.567178','AVAILABLE',8),
(9,'2023-05-11 17:46:50.942852','AVAILABLE',9),
(10,'2023-05-12 13:07:29.739411','AVAILABLE',10),
(11,'2023-05-12 23:24:10.707567','AVAILABLE',11),
(12,'2023-05-15 01:13:55.443449','AVAILABLE',12),
(15,'2023-05-15 16:16:24.887312','AVAILABLE',15),
(16,'2023-05-15 18:57:48.769630','AVAILABLE',16),
(17,'2023-05-16 14:56:31.596249','AVAILABLE',17),
(18,'2023-05-16 18:22:16.104533','AVAILABLE',18),
(19,'2023-05-17 20:21:13.855406','AVAILABLE',19),
(20,'2023-05-18 00:18:40.214412','AVAILABLE',20),
(21,'2023-05-18 00:37:12.255766','AVAILABLE',21);
/*!40000 ALTER TABLE `user_status` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `user_submit_count`
--

DROP TABLE IF EXISTS `user_submit_count`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `user_submit_count` (
  `user_submit_count_sequence` bigint(20) NOT NULL AUTO_INCREMENT,
  `user_submit_created_at` datetime(6) NOT NULL,
  `user_submit_updated_at` datetime(6) DEFAULT NULL,
  `user_submit_count` bigint(20) DEFAULT 10,
  `user_seq` bigint(20) DEFAULT NULL,
  PRIMARY KEY (`user_submit_count_sequence`),
  KEY `user_seq` (`user_seq`),
  CONSTRAINT `FK7yngogk1869q17dd5q07lsylk` FOREIGN KEY (`user_seq`) REFERENCES `user` (`user_seq`)
) ENGINE=InnoDB AUTO_INCREMENT=1020 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `user_submit_count`
--

LOCK TABLES `user_submit_count` WRITE;
/*!40000 ALTER TABLE `user_submit_count` DISABLE KEYS */;
INSERT INTO `user_submit_count` VALUES
(1000,'2023-05-15 16:06:21.000000','2023-05-18 00:15:58.561034',186,1),
(1001,'2023-05-15 16:07:53.000000','2023-05-17 22:56:52.608765',192,2),
(1002,'2023-05-15 16:08:19.000000','2023-05-17 17:35:54.816500',198,3),
(1003,'2023-05-15 16:08:21.000000','2023-05-18 09:22:29.037670',195,4),
(1004,'2023-05-15 16:08:22.000000','2023-05-18 04:11:59.297428',191,6),
(1005,'2023-05-15 16:08:23.000000','2023-05-18 10:20:42.250155',181,7),
(1006,'2023-05-15 16:08:24.000000','2023-05-15 16:08:25.000000',200,8),
(1007,'2023-05-15 16:08:26.000000','2023-05-18 09:44:48.659289',199,9),
(1008,'2023-05-15 16:08:27.000000','2023-05-15 16:08:27.000000',200,10),
(1009,'2023-05-15 16:08:28.000000','2023-05-15 16:08:28.000000',200,11),
(1010,'2023-05-15 16:08:36.000000','2023-05-17 22:07:24.448274',198,12),
(1013,'2023-05-15 16:16:24.918698','2023-05-17 23:59:00.440894',199,15),
(1014,'2023-05-15 18:57:48.777659','2023-05-15 18:57:48.777659',200,16),
(1015,'2023-05-16 14:56:31.601647','2023-05-16 14:56:31.601647',10,17),
(1016,'2023-05-16 18:22:16.105721','2023-05-16 18:22:16.105721',10,18),
(1017,'2023-05-17 20:21:13.857004','2023-05-17 20:22:58.704013',9,19),
(1018,'2023-05-18 00:18:40.216134','2023-05-18 00:18:40.216134',10,20),
(1019,'2023-05-18 00:37:12.257150','2023-05-18 00:38:50.506288',9,21);
/*!40000 ALTER TABLE `user_submit_count` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `user_submit_problem`
--

DROP TABLE IF EXISTS `user_submit_problem`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `user_submit_problem` (
  `user_submit_problem_seq` bigint(20) NOT NULL AUTO_INCREMENT,
  `problem_id` bigint(20) DEFAULT NULL,
  `user_seq` bigint(20) DEFAULT NULL,
  `user_submit_problem_created_at` datetime DEFAULT NULL,
  `user_submit_problem_updated_at` datetime DEFAULT NULL,
  PRIMARY KEY (`user_submit_problem_seq`)
) ENGINE=InnoDB AUTO_INCREMENT=168 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `user_submit_problem`
--

LOCK TABLES `user_submit_problem` WRITE;
/*!40000 ALTER TABLE `user_submit_problem` DISABLE KEYS */;
INSERT INTO `user_submit_problem` VALUES
(126,1008,1,'2018-02-06 13:59:40','2018-02-06 13:59:40'),
(127,24727,7,'2022-12-04 20:47:40','2023-05-17 12:16:44'),
(128,1000,6,'2023-05-17 12:29:25','2023-05-17 12:29:25'),
(129,1012,1,'2023-05-10 10:35:41','2023-05-17 12:56:18'),
(130,1000,7,'2023-05-17 13:04:23','2023-05-17 17:35:50'),
(131,1001,6,'2023-05-17 13:41:55','2023-05-17 13:41:55'),
(132,16935,2,'2022-08-10 15:25:28','2022-08-10 15:25:28'),
(133,16139,2,'2022-12-15 15:59:43','2022-12-15 15:59:43'),
(134,14500,6,'2023-01-29 19:03:46','2023-01-29 19:03:46'),
(135,1003,6,'2022-08-27 21:56:38','2023-05-17 14:32:48'),
(136,1002,6,'2023-05-17 14:35:10','2023-05-17 14:35:10'),
(137,1111,2,'2022-12-12 19:55:31','2022-12-12 19:55:31'),
(138,17144,2,'2022-08-26 15:15:40','2022-08-26 15:15:40'),
(139,17081,4,'2023-05-16 13:23:50','2023-05-16 13:23:50'),
(140,1000,1,'2023-05-09 16:51:07','2023-05-09 16:51:07'),
(141,1002,7,'2021-07-26 16:47:53','2021-07-26 16:47:53'),
(142,3649,2,'2022-11-05 19:32:59','2022-11-05 19:32:59'),
(143,1003,7,'2022-01-01 18:44:28','2022-01-01 18:44:28'),
(144,1806,3,'2023-05-17 17:30:02','2023-05-17 17:30:02'),
(145,1000,3,'2021-08-05 10:28:21','2021-08-05 10:28:21'),
(146,1000,2,'2022-05-01 21:12:56','2022-05-01 21:12:56'),
(147,1157,7,'2023-05-17 20:03:16','2023-05-17 20:03:16'),
(148,15652,19,'2023-03-30 15:39:39','2023-03-30 15:39:39'),
(149,10950,7,'2023-05-17 21:43:17','2023-05-18 00:33:34'),
(150,17485,4,'2023-05-17 21:54:19','2023-05-17 21:54:19'),
(151,1520,12,'2023-05-17 22:07:18','2023-05-17 22:07:18'),
(152,10026,2,'2022-08-24 17:31:20','2022-08-24 17:31:20'),
(153,14499,15,'2023-05-11 17:57:02','2023-05-11 17:57:02'),
(154,2110,1,'2022-02-07 11:15:49','2022-02-07 11:15:49'),
(155,25314,21,'2023-02-22 00:14:38','2023-02-22 00:14:38'),
(156,17406,7,'2022-08-11 01:15:53','2022-08-11 01:15:53'),
(157,21610,6,'2023-05-18 02:30:09','2023-05-18 02:30:09'),
(158,1049,6,'2022-08-31 13:25:49','2022-08-31 13:25:49'),
(159,1015,6,'2022-08-28 09:49:06','2022-08-28 09:49:06'),
(160,2557,6,'2023-05-11 14:19:12','2023-05-11 14:19:12'),
(161,14502,6,'2023-01-29 21:31:49','2023-01-29 21:31:49'),
(162,14503,6,'2023-01-28 23:45:11','2023-01-28 23:45:11'),
(163,14890,6,'2023-02-06 22:05:12','2023-02-06 22:05:12'),
(164,5052,4,'2023-05-18 09:22:23','2023-05-18 09:22:23'),
(165,17070,7,'2022-09-30 11:56:36','2022-09-30 11:56:36'),
(166,3040,9,'2022-08-11 17:47:52','2022-08-11 17:47:52'),
(167,7569,7,'2023-05-18 10:19:18','2023-05-18 10:19:18');
/*!40000 ALTER TABLE `user_submit_problem` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `user_submit_solution`
--

DROP TABLE IF EXISTS `user_submit_solution`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `user_submit_solution` (
  `submission_id` bigint(20) NOT NULL AUTO_INCREMENT,
  `problem_id` bigint(20) DEFAULT NULL,
  `user_seq` bigint(20) DEFAULT NULL,
  `user_submit_solution_time` datetime DEFAULT NULL,
  `user_submit_solution_result` text DEFAULT NULL,
  `user_submit_solution_result_category` text DEFAULT NULL,
  `user_submit_solution_language` text DEFAULT NULL,
  `user_submit_solution_code` text DEFAULT NULL,
  `user_submit_solution_runtime` bigint(20) DEFAULT NULL,
  `user_submit_solution_memory` bigint(20) DEFAULT NULL,
  `user_submit_solution_code_length` bigint(20) DEFAULT NULL,
  `user_submit_problem_seq` bigint(20) DEFAULT NULL,
  PRIMARY KEY (`submission_id`),
  KEY `idx_problem_id` (`problem_id`),
  KEY `idx_submission_id` (`submission_id`),
  KEY `idx_user_seq` (`user_seq`)
) ENGINE=InnoDB AUTO_INCREMENT=4344543534343439867 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `user_submit_solution`
--

LOCK TABLES `user_submit_solution` WRITE;
/*!40000 ALTER TABLE `user_submit_solution` DISABLE KEYS */;
INSERT INTO `user_submit_solution` VALUES
(7720108,1008,1,'2018-02-06 13:59:40','맞았습니다!!','ac','cpp','#include <iostream>\r\n#include <stdio.h>\r\nusing namespace std;\r\n\r\nint main() \r\n{\r\n	double input1, input2;\r\n	\r\n	cin >> input1 >> input2;\r\n	double result = input1/input2;\r\n	\r\n	printf(\"%.11lf\",(double)result);\r\n	\r\n}',0,1984,198,126),
(31468002,1002,7,'2021-07-26 16:47:53','맞았습니다!!','ac','python','import sys\r\nimport math\r\ninput = sys.stdin.readline\r\n\r\n\r\nT = int(input())\r\n\r\n#sqrt 사용시 정밀도 오류 -> 따라서 제곱한 채로 크기 비교 \r\ndef location_count(x1,y1,r1,x2,y2,r2):\r\n    distance = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\r\n    dis = [r1,r2,distance]\r\n    m = max(dis)\r\n    dis.remove(m)\r\n\r\n\r\n    #무한대\r\n    if distance==0 and r1==r2:\r\n        print(-1)\r\n\r\n    #한점에서 만날때\r\n    elif (distance == r1 + r2) or m==sum(dis) :\r\n        print(1)\r\n\r\n    elif m > sum(dis):\r\n        print(0)\r\n    else:\r\n        print(2)\r\n\r\nfor i in range(T):\r\n    x1, y1, r1, x2, y2, r2 = map(int, input().split())\r\n    location_count(x1,y1,r1,x2,y2,r2)',76,31312,643,141),
(31846074,1000,3,'2021-08-05 10:28:21','맞았습니다!!','ac','cpp','#include <stdio.h>\r\n\r\nint    main(void)\r\n{\r\n    int    A;\r\n    int    B;\r\n    \r\n    scanf(\"%d %d\", &A, &B);\r\n    printf(\"%d\\n\", A + B);\r\n    return (0);\r\n}',0,1112,145,145),
(36914303,1003,7,'2022-01-01 18:44:28','맞았습니다!!','ac','python','import sys\r\ninput = sys.stdin.readline\r\n\r\nn = int(input())\r\ndata = []\r\nfor _ in range(n):\r\n    data.append(int(input()))\r\n\r\ndp = [[0,0] for _ in range(41)]\r\n\r\ndp[0] = [1,0]\r\ndp[1] = [0,1]\r\n\r\nif max(data) >= 2:\r\n    for i in range(2,max(data)+1):\r\n        dp[i][0] = dp[i-1][0] + dp[i-2][0]\r\n        dp[i][1] = dp[i-1][1] + dp[i-2][1]\r\n\r\nfor d in data:\r\n    print(dp[d][0], dp[d][1])',68,30840,363,143),
(38682815,2110,1,'2022-02-07 11:15:49','맞았습니다!!','ac','python','import sys\r\n#sys.stdin = open(\"input.txt\", \"rt\")\r\ninput = sys.stdin.readline\r\n\r\n\r\ndef check_space(space):\r\n\r\n    cnt = 0\r\n\r\n    i = 0\r\n    while i < n:\r\n        cur_home = home[i]\r\n        cnt += 1\r\n\r\n        while i < n and cur_home + space > home[i]:\r\n            i += 1\r\n\r\n    return cnt\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    n, c = map(int, input().split())\r\n    home = [int(input()) for _ in range(n)]\r\n\r\n    home.sort()\r\n\r\n    left = 1\r\n    right = home[n-1] - home[0]\r\n\r\n    while left <= right:\r\n        mid = (left + right) // 2\r\n        cnt = check_space(mid)\r\n\r\n        if cnt >= c:\r\n            left = mid + 1\r\n        else:\r\n            right = mid - 1\r\n\r\n    print(right)\r\n',452,38984,647,154),
(42713571,1000,2,'2022-05-01 21:12:56','맞았습니다!!','ac','python','A=0\r\nB=0\r\nA,B = input().split()\r\nA=int(A)\r\nB=int(B)\r\nprint(A+B)',68,30840,58,146),
(47489089,16935,2,'2022-08-10 15:25:28','맞았습니다!!','ac','java','import java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.List;\r\n\r\npublic class Main {\r\n	static int cnt=0; \r\n	static int row =0;\r\n	static int col =0;\r\n	public static void main(String[] args) throws IOException {\r\n		BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\r\n		StringBuilder sb = new StringBuilder();\r\n		String[] str = bf.readLine().split(\" \");\r\n		int N=Integer.parseInt(str[0]);\r\n		row=N;\r\n		int M=Integer.parseInt(str[1]);\r\n		col=M;\r\n		int rot=Integer.parseInt(str[2]);\r\n		int swab=0;\r\n		int [][]graph = new int[N][M];\r\n		for(int i = 0 ; i<N; i++) {\r\n			str=bf.readLine().split(\" \");\r\n			for(int j=0;j<M;j++)\r\n			graph[i][j]=Integer.parseInt(str[j]);\r\n		}\r\n		str=bf.readLine().split(\" \");\r\n		int mod[]=new int[rot];\r\n		for (int i= 0 ; i<rot ; i++)mod[i]=Integer.parseInt(str[i]);\r\n\r\n		for(int k : mod) {\r\n			if(k==1) {\r\n				up(graph);\r\n			}\r\n			if(k==2) {\r\n				left(graph);\r\n			}\r\n			if(k==3) {\r\n				\r\n				graph=rightRo(graph);\r\n\r\n			}\r\n			if(k==4) {\r\n				graph=leftRo(graph);\r\n\r\n			}\r\n			if(k==5) {\r\n				mode5(graph);\r\n			}if(k==6) {\r\n				mode6(graph);\r\n			}\r\n\r\n		}\r\n		\r\n		for(int i = 0 ; i<graph.length; i++) {\r\n			for(int j = 0 ; j<graph[0].length; j++) {\r\n				sb.append(graph[i][j]);\r\n				sb.append(\" \");\r\n			}\r\n			sb.append(\"\\n\");\r\n		}\r\n		System.out.println(sb);\r\n	}\r\n	static void up(int[][] graph) {\r\n		int temp=0;\r\n		for(int j=0;j<col;j++) {\r\n			for(int i=0; i<row/2 ; i++) {\r\n				\r\n				temp=graph[i][j];\r\n				graph[i][j]=graph[row-1-i][j];\r\n				graph[row-1-i][j]=temp;\r\n			}\r\n		}\r\n	}\r\n	static void left(int[][] graph) {\r\n			int temp=0;\r\n			for(int j=0;j<row;j++) {\r\n				for(int i=0; i<col/2 ; i++) {\r\n					\r\n					temp=graph[j][i];\r\n					graph[j][i]=graph[j][col-1-i];\r\n					graph[j][col-1-i]=temp;\r\n				}\r\n			}\r\n		\r\n		\r\n	}\r\n	static void mode6(int[][]graph) {\r\n			int[][] temp=new int [row/2][col/2];\r\n			for(int i = 0 ; i<row/2 ; i++) {\r\n				for(int j = 0 ; j<col/2; j++ ) {\r\n					temp[i][j]=graph[i][col/2+j];\r\n					graph[i][col/2+j]=graph[row/2+i][col/2+j];\r\n					graph[row/2+i][col/2+j]=graph[row/2+i][j];\r\n					graph[row/2+i][j]=graph[i][j];\r\n					graph[i][j]=temp[i][j];\r\n					\r\n				}\r\n			}\r\n			\r\n		}\r\n	static void mode5(int[][]graph) {\r\n			int[][] temp=new int [row/2][col/2];\r\n			for(int i = 0 ; i<row/2 ; i++) {\r\n				for(int j = 0 ; j<col/2; j++ ) {\r\n					temp[i][j]=graph[row/2+i][j];\r\n					graph[row/2+i][j]=graph[row/2+i][col/2+j];\r\n					graph[row/2+i][col/2+j]=graph[i][col/2+j];\r\n					graph[i][col/2+j]=graph[i][j];\r\n					\r\n					\r\n					graph[i][j]=temp[i][j];\r\n					\r\n				}\r\n			}\r\n	}\r\n	static int[][] rightRo(int[][]graph) {\r\n		int tem [][]=new int [col][row];\r\n		for(int i = 0 ; i<col ; i++) {\r\n			for(int j = 0 ; j<row ; j++){\r\n				tem[i][j]=graph[row-1-j][i];\r\n			}\r\n		}\r\n		int temp=col;\r\n		col=row;\r\n		row=temp;\r\n		return graph=tem;\r\n\r\n	}\r\n	static int[][] leftRo(int[][]graph) {\r\n		int tem [][]=new int [col][row];\r\n		for(int i = 0 ; i<col ; i++) {\r\n			for(int j = 0 ; j<row ; j++){\r\n				tem[i][j]=graph[j][col-1-i];\r\n			}\r\n		}\r\n		int temp=col;\r\n		col=row;\r\n		row=temp;\r\n		return graph=tem;\r\n\r\n	}\r\n	\r\n}\r\n\r\n',404,37548,3028,132),
(47524740,17406,7,'2022-08-11 01:15:53','맞았습니다!!','ac','java','import java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.FileInputStream;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Arrays;\r\nimport java.util.StringTokenizer;\r\n\r\npublic class Main \r\n{\r\n	static int N;\r\n	static int M;\r\n	static int K;\r\n	static int[][] map;\r\n	static int[][] rotation;\r\n	static boolean[] visited;\r\n	static int[] numbers;\r\n	static int min = Integer.MAX_VALUE;\r\n	\r\n	public static void main(String[] args) throws Exception \r\n	{\r\n		//System.setIn(new FileInputStream(\"input/17406.txt\"));\r\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n		BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\r\n		StringTokenizer st = null;\r\n		\r\n		st = new StringTokenizer(br.readLine(), \" \");\r\n		N = Integer.parseInt(st.nextToken());\r\n		M = Integer.parseInt(st.nextToken());\r\n		K = Integer.parseInt(st.nextToken());\r\n		map = new int[N][M];\r\n		for (int i=0; i<N; i++)\r\n		{\r\n			st = new StringTokenizer(br.readLine(), \" \");\r\n			for (int j=0; j<M; j++) \r\n			{\r\n				map[i][j] = Integer.parseInt(st.nextToken());\r\n			}\r\n		}\r\n		\r\n		\r\n		rotation = new int[K][3];\r\n		for (int i=0; i<K; i++)\r\n		{\r\n			st = new StringTokenizer(br.readLine(), \" \");\r\n			rotation[i][0] = Integer.parseInt(st.nextToken());\r\n			rotation[i][1] = Integer.parseInt(st.nextToken());\r\n			rotation[i][2] = Integer.parseInt(st.nextToken());\r\n		}\r\n		\r\n		visited = new boolean[K];\r\n		numbers = new int[K];\r\n		permutation(0, K);\r\n		bw.write(Integer.toString(min));\r\n		\r\n//		for (int[] data : rotation) {\r\n//			System.out.println(Arrays.toString(data));\r\n//		}\r\n		\r\n		\r\n		br.close();\r\n		bw.flush();\r\n		bw.close();\r\n	}\r\n	\r\n	static void permutation(int idx, int k) {\r\n		if (idx == K) {\r\n			// 배열을 복사 (기존 배열에 영향을 주지 않기 위해서)\r\n			int[][] copy = new int[N][M];\r\n			for (int i=0; i<N; i++) {\r\n				for (int j=0; j<M; j++) {\r\n					copy[i][j] = map[i][j];\r\n				}\r\n			}\r\n\r\n			for (int i=0; i<numbers.length; i++) {				\r\n				int lx = rotation[numbers[i]][0] - rotation[numbers[i]][2] - 1;\r\n				int ly = rotation[numbers[i]][1] - rotation[numbers[i]][2] - 1;\r\n				int rx = rotation[numbers[i]][0] + rotation[numbers[i]][2] - 1;\r\n				int ry = rotation[numbers[i]][1] + rotation[numbers[i]][2] - 1;\r\n				Rotate(lx, ly, rx, ry, copy);\r\n			}\r\n			// 배열 완성\r\n			for (int i=0; i<copy.length; i++) {\r\n				int sum = 0;\r\n				for (int j=0; j<copy[i].length; j++) {\r\n					sum += copy[i][j];\r\n				}\r\n				min = Math.min(min, sum);\r\n			}\r\n			\r\n			//System.out.println(Arrays.toString(numbers));\r\n			return;\r\n		}\r\n		\r\n		for (int i=0; i<K; i++) {\r\n			if (visited[i]) continue;\r\n			\r\n			visited[i] = true;\r\n			numbers[idx] = i;\r\n			permutation(idx+1, k);\r\n			visited[i] = false;\r\n		}\r\n	}\r\n	\r\n\r\n	static void Rotate(int lx, int ly, int rx, int ry, int[][] copy)  \r\n	{\r\n		if (lx == rx || ly == ry) return;\r\n		\r\n		// 지워질 수 있는 값 저장\r\n		int[] temp = new int[3];\r\n		temp[0] = copy[lx][ry];\r\n		temp[1] = copy[rx][ry];\r\n		temp[2] = copy[rx][ly];\r\n		\r\n		// 오른쪽으로 회전\r\n		for (int i=ry; i>ly; i-- ) {\r\n			copy[lx][i] = copy[lx][i-1];\r\n		}\r\n		\r\n		// 아래로 회전\r\n		for (int i=rx; i>lx; i--) {\r\n			if (i == lx + 1) {\r\n				copy[i][ry] = temp[0];\r\n			} else {				\r\n				copy[i][ry] = copy[i-1][ry];\r\n			}\r\n		}\r\n		\r\n		// 왼쪽으로 회전\r\n		for (int i=ly; i<ry; i++) {\r\n			if (i == ry - 1) {\r\n				copy[rx][i] = temp[1];\r\n			} else {				\r\n				copy[rx][i] = copy[rx][i+1];\r\n			}\r\n		}\r\n		\r\n		// 위로 회전\r\n		for (int i=lx; i<rx; i++) {\r\n			if (i == rx - 1) {\r\n				copy[i][ly] = temp[2];\r\n			} else {				\r\n				copy[i][ly] = copy[i+1][ly];\r\n			}\r\n		}\r\n		\r\n		Rotate(lx+1, ly+1, rx-1, ry-1, copy);\r\n		\r\n	}\r\n}',308,29156,3559,156),
(47557778,3040,9,'2022-08-11 17:47:52','맞았습니다!!','ac','java','\r\n	import java.io.BufferedReader;\r\n	import java.io.IOException;\r\n	import java.io.InputStreamReader;\r\n	import java.util.StringTokenizer;\r\n	\r\n	public class Main {\r\n		static int[] ori= new int[9];\r\n		static int[] tmp= new int[7];\r\n		static int cnt=0;\r\n		static int[] answer= new int[7];\r\n		static boolean[] visited= new boolean[9];\r\n		static int stop = 0;\r\n		\r\n		public static void main(String[] args) throws IOException {\r\n			BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\r\n			for(int i = 0 ; i<9 ; i ++) {\r\n			ori[i]=Integer.parseInt(bf.readLine());				\r\n			}\r\n			dfs(0,0);\r\n			for(int i = 0 ; i< 7 ; i++)\r\n			System.out.println(answer[i]);\r\n		}\r\n		static void dfs(int depth,int k) {\r\n				if(depth==7) {\r\n					int sum=0;\r\n					for(int i = 0 ; i<7 ; i++ )\r\n						sum+=tmp[i];\r\n					if(sum==100) {\r\n						stop=1;\r\n						for(int i = 0 ; i<7 ; i++ )\r\n							answer[i]=tmp[i];\r\n					}\r\n					return;\r\n				}\r\n			for(int i =k ; i<9 ; i++ ) {\r\n				if(visited[i]==false) {\r\n					visited[i]=true;\r\n					tmp[cnt++]=ori[i];\r\n					dfs(depth+1,i+1);\r\n					visited[i]=false;\r\n					cnt--;\r\n					tmp[cnt]=0;\r\n					}else {\r\n						dfs(depth+1,i+1);\r\n						visited[i]=false;\r\n					}\r\n					\r\n				}\r\n			return;\r\n			}\r\n			\r\n		}\r\n	\r\n\r\n\r\n',124,14148,1182,166),
(48230117,10026,2,'2022-08-24 17:31:20','맞았습니다!!','ac','java','\r\nimport java.util.*;\r\n\r\n\r\nimport java.io.*;\r\npublic class Main {\r\n	static int N;\r\n	static char map[][];\r\n	static ArrayList<Integer> answer;\r\n	 static int dx[]= {0,0,-1,1};\r\n	static int dy[]= {1,-1,0,0};\r\n	static int cnt1=0;\r\n	static int cnt=0;\r\n	static boolean vis[][];\r\n	static boolean vis2[][];\r\n    public static void main(String[] args) throws IOException {\r\n        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\r\n        StringBuilder sb = new StringBuilder();\r\n        N=Integer.parseInt(bf.readLine());\r\n        String str;\r\n        map=new char[N][N];\r\n        vis=new boolean[N][N];\r\n        vis2=new boolean[N][N];\r\n        for(int i = 0 ; i<N ; i ++) {\r\n        	str=bf.readLine();\r\n        	for(int j = 0 ; j<N ; j++)map[i][j]=str.charAt(j);\r\n        }\r\n        for(int i = 0 ; i< N ; i++) {\r\n        	for(int j = 0 ; j< N ; j++) {\r\n        		if(!vis[i][j]) {\r\n        			dfs(i,j,map[i][j]);\r\n        			cnt1++;\r\n        		}\r\n        		if(!vis2[i][j]) {\r\n        			dfs1(i,j,map[i][j]);\r\n        			cnt++;\r\n        		}\r\n        	}\r\n        	\r\n        }\r\n        System.out.println(cnt+\" \"+cnt1);\r\n       }\r\n   static void dfs(int y, int x, char a) {\r\n    	if(!vis[y][x]) {\r\n    		vis[y][x]=true;\r\n    		for(int i = 0 ; i<4 ; i++) {\r\n    			int nx = dx[i]+x;\r\n    			int ny = dy[i]+y;\r\n    			if(nx>=0 && nx<N && ny>= 0 && ny<N) {\r\n    				if(a==\'R\'||a==\'G\') {\r\n    					if(\'R\'==map[ny][nx]||\'G\'==map[ny][nx])dfs(ny,nx,a);\r\n    				}else {\r\n    					if(a==map[ny][nx])dfs(ny,nx,a);\r\n    				}\r\n    					\r\n    				\r\n    			}\r\n    		}\r\n    	}else {\r\n    		return;\r\n    	}\r\n    }\r\n   static void dfs1(int y, int x, char a) {\r\n   	if(!vis2[y][x]) {\r\n   		vis2[y][x]=true;\r\n   		for(int i = 0 ; i<4 ; i++) {\r\n   			int nx = dx[i]+x;\r\n   			int ny = dy[i]+y;\r\n   			if(nx>=0 && nx<N && ny>= 0 && ny<N) {\r\n   				\r\n   					if(a==map[ny][nx])dfs1(ny,nx,a);\r\n   				}\r\n   					\r\n   				\r\n   			}\r\n   		}\r\n   	else {\r\n   		return;\r\n   	}\r\n   }\r\n        \r\n   }\r\n\r\n\r\n',96,12568,1911,152),
(48325029,17144,2,'2022-08-26 15:15:40','맞았습니다!!','ac','java','\r\nimport java.util.*;\r\n\r\n\r\nimport java.io.*;\r\npublic class Main {\r\n	static int R;\r\n	static int C;\r\n	static int T;\r\n	static int[][]map;\r\n	static int[][]tmp;\r\n	static int MAX=Integer.MAX_VALUE;\r\n	static int [] dx= {0,0,-1,1};\r\n	static int [] dy= {1,-1,0,0};\r\n	static boolean [][] vis ;\r\n    public static void main(String[] args) throws IOException {\r\n        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\r\n        StringBuilder sb = new StringBuilder();\r\n        StringTokenizer st = new StringTokenizer(bf.readLine()) ;\r\n        R=Integer.parseInt(st.nextToken());\r\n        C=Integer.parseInt(st.nextToken());\r\n        T=Integer.parseInt(st.nextToken());\r\n        map=new int [R][C];\r\n        tmp=new int [R][C];\r\n        vis=new boolean[R][C];\r\n        int y = 0 ;\r\n        for(int i = 0 ; i<R ; i++) {\r\n        	st = new StringTokenizer(bf.readLine()) ;\r\n        	for(int j = 0 ; j<C ; j++) {\r\n        		map[i][j]=Integer.parseInt(st.nextToken());\r\n        		if(map[i][j]==-1)y=i;\r\n        	}\r\n        }\r\n\r\n        for(int time = 0 ; time<T ; time++) {\r\n            for(int i = 0 ; i<R ; i++) {\r\n            	tmp[i]=map[i].clone();\r\n            }\r\n        	for(int i = 0 ; i<R ; i++) {\r\n        		for(int j = 0 ; j<C ; j++) {\r\n        			if(map[i][j]>0)spread(i,j);\r\n        		}\r\n        	}\r\n        	air(y);\r\n        \r\n        for(int i =0 ; i<R; i++) {\r\n        	map[i]=tmp[i].clone();\r\n        }\r\n        }\r\n        int sum=0;\r\n        for(int i = 0 ; i < R; i++) {\r\n        	for(int j = 0 ; j<C ; j++) {\r\n        		sum+=map[i][j];\r\n        	}\r\n        }\r\n       System.out.println(sum+2);\r\n \r\n  }\r\n static void spread(int y, int x) {\r\n	 int count =4;\r\n	 for(int i = 0 ; i <4 ; i++) {\r\n		 int nx=x+dx[i];\r\n		 int ny=y+dy[i];\r\n		 if(nx<0 || nx>=C || ny<0 || ny>=R) {\r\n			 count--;\r\n			 continue;\r\n		 }\r\n		 if(map[ny][nx]==-1) {\r\n			 count--;\r\n			 continue;\r\n		 }\r\n\r\n		 tmp[ny][nx]=tmp[ny][nx]+(map[y][x]/5);\r\n	 }\r\n	 tmp[y][x]=tmp[y][x]-(map[y][x]/5)*count;\r\n }\r\n\r\nstatic void air(int y) {\r\n\r\n	for(int i = y-2 ; i>0 ; i--) {\r\n		tmp[i][0]=tmp[i-1][0];\r\n	}\r\n	for(int i = 0 ; i<=C-2 ; i++) {\r\n		tmp[0][i]=tmp[0][i+1];\r\n	}\r\n	for(int i = 0 ; i<=y-2; i ++) {\r\n		tmp[i][C-1]=tmp[i+1][C-1];\r\n	}\r\n	for(int i = C-1 ; i>1 ; i--) {\r\n		tmp[y-1][i]=tmp[y-1][i-1];\r\n	}\r\n	\r\n	for(int i = y+1 ; i<R-1 ; i++) {\r\n		tmp[i][0]=tmp[i+1][0];\r\n	}\r\n	for(int i=0 ; i<=C-2 ; i++) {\r\n		tmp[R-1][i]=tmp[R-1][i+1];\r\n	}\r\n	for(int i=R-1 ; i>=y+1 ; i --) {\r\n		tmp[i][C-1]=tmp[i-1][C-1];\r\n	}\r\n	for(int i=C-1 ; i>1 ; i--) {\r\n		tmp[y][i]=tmp[y][i-1];\r\n	}\r\n	tmp[y-1][1]=0;\r\n	tmp[y][1]=0;\r\n\r\n}\r\n}        \r\n \r\n\r\n\r\n',328,41388,2493,138),
(48382175,1003,6,'2022-08-27 21:56:38','맞았습니다!!','ac','cpp','#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nint result[51] = { 0, };\r\n\r\nstruct Node \r\n{\r\n	int z, o;\r\n};\r\n\r\nNode st[51] = { 0, };\r\n\r\nint fibonacci(int now)\r\n{\r\n	if (now == 1 || now == 0)\r\n	{\r\n		st[1].o = 1;\r\n		st[0].z = 1;\r\n		return result[now] = now;\r\n	}\r\n\r\n	if (result[now])\r\n	{\r\n		st[now].o = st[now - 1].o + st[now - 2].o;\r\n		st[now].z = st[now - 1].z + st[now - 2].z;\r\n		return result[now];\r\n	}\r\n\r\n	result[now] = fibonacci(now - 1) + fibonacci(now - 2);\r\n	st[now].o = st[now - 1].o + st[now - 2].o;\r\n	st[now].z = st[now - 1].z + st[now - 2].z;\r\n\r\n	return result[now];\r\n}\r\n\r\nint in[101] = { 0, };\r\n\r\nint main() {\r\n	int T;\r\n	cin >> T;\r\n	for (int i = 0; i < T; i++)\r\n	{\r\n		int num;\r\n		cin >> num;\r\n		in[i] = num;\r\n		fibonacci(num);\r\n		int de = 1;\r\n	}\r\n	for (int i = 0; i < T; i++)\r\n	{\r\n		cout << st[in[i]].z << \" \" << st[in[i]].o << endl;\r\n	}\r\n	return 0;\r\n}',4,2020,807,135),
(48395207,1015,6,'2022-08-28 09:49:06','맞았습니다!!','ac','cpp','#include <iostream>\r\n#include <queue>\r\n\r\nusing namespace std;\r\n\r\nstruct Node\r\n{\r\n	int num, index;\r\n};\r\n\r\nstruct cmp\r\n{\r\n	bool operator ()(Node A, Node B)\r\n	{\r\n		if (A.num > B.num) return true;\r\n		if (A.num < B.num) return false;\r\n\r\n		if (A.index > B.index) return true;\r\n		if (A.index < B.index) return false;\r\n		return false;\r\n	}\r\n};\r\n\r\npriority_queue<Node, vector<Node>, cmp> pq;\r\n\r\nint main() {\r\n	int N;\r\n	cin >> N;\r\n	int result[1001] = { 0, };\r\n	for (int i = 0; i < N; i++)\r\n	{\r\n		int num;\r\n		cin >> num;\r\n		pq.push({ num,i });\r\n	}\r\n	int num1 = 0;\r\n	for (int i = 0; i < N; i++)\r\n	{\r\n		Node A = pq.top();\r\n		pq.pop();\r\n		result[A.index] = num1;\r\n		num1++;\r\n	}\r\n	for (int i = 0; i < N; i++)\r\n	{\r\n		cout << result[i] << \" \";\r\n	}\r\n	return 0;\r\n\r\n}\r\n',0,2020,698,159),
(48536946,1049,6,'2022-08-31 13:25:49','맞았습니다!!','ac','cpp','#include <iostream>\r\n#include <vector>\r\nusing namespace std;\r\n\r\nstruct Node\r\n{\r\n	int st;\r\n	int qt;\r\n};\r\nvector <Node> v;\r\n\r\nint main()\r\n{\r\n	int N, M;\r\n	cin >> N >> M;\r\n	for (int i = 0; i < M; i++)\r\n	{\r\n		int num, num1;\r\n		cin >> num >> num1;\r\n		v.push_back({ num, num1 });\r\n	}\r\n	int stmn = 213232;\r\n	int qtmn = 213212;\r\n\r\n	for (int i = 0; i < M; i++)\r\n	{\r\n		if (stmn > v[i].st)\r\n		{\r\n			stmn = v[i].st;\r\n		}\r\n		if (qtmn > v[i].qt)\r\n		{\r\n			qtmn = v[i].qt;\r\n		}\r\n	}\r\n	int result = 1231231;\r\n	int result1 = 0;\r\n\r\n	result = N / 6 * stmn + N % 6 * qtmn;\r\n	result1 = (N / 6 + 1) * stmn;\r\n	if (result > result1)\r\n	{\r\n		result = result1;\r\n	}\r\n\r\n	result1 = N * qtmn;\r\n	\r\n	if (result < result1)\r\n	{\r\n		cout << result;\r\n	}\r\n	else\r\n	{\r\n		cout << result1;\r\n	}\r\n	return 0;\r\n}',0,2020,706,158),
(49888093,17070,7,'2022-09-30 11:56:36','맞았습니다!!','ac','java','\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.Arrays;\r\nimport java.util.StringTokenizer;\r\n\r\npublic class Main {\r\n\r\n	static int N;\r\n	static int[][] arr;\r\n	static int right = 0;\r\n	static int rightDown = 1;\r\n	static int down = 2;\r\n	static int result;\r\n	// 오른쪽, 오른쪽아래대각선, 아래 \r\n	static int[] dr = {0, 1, 1};\r\n	static int[] dc = {1, 1, 0};\r\n	\r\n	static class Pipe {\r\n		public int r1;\r\n		public int c1;\r\n		public int r2;\r\n		public int c2;\r\n		public int dir;\r\n\r\n		public Pipe(int r1, int c1, int r2, int c2, int dir) {\r\n			super();\r\n			this.r1 = r1;\r\n			this.c1 = c1;\r\n			this.r2 = r2;\r\n			this.c2 = c2;\r\n			this.dir = dir;\r\n		}\r\n		\r\n		\r\n	}\r\n	\r\n	public static void main(String[] args) throws Exception {\r\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n		StringTokenizer st;\r\n		\r\n		st = new StringTokenizer(br.readLine());\r\n		N = Integer.parseInt(st.nextToken());\r\n		arr = new int[N][N];\r\n		for (int i=0; i<N; i++) {\r\n			st = new StringTokenizer(br.readLine(), \" \");\r\n			for (int j=0; j<N; j++) {\r\n				arr[i][j] = Integer.parseInt(st.nextToken());\r\n			}\r\n		}\r\n		\r\n		Pipe pipe = new Pipe(0, 0, 0, 1, right);\r\n		\r\n		// 시작 파이프 위치 \r\n		arr[0][0] = -1;\r\n		arr[0][1] = -1;\r\n		\r\n		\r\n		// 입력\r\n		\r\n		// 로직\r\n		result = 0;\r\n		dfs(pipe);\r\n		System.out.println(result);\r\n		\r\n	}\r\n\r\n	private static void dfs(Pipe pipe) {\r\n//		System.out.println(result);\r\n//		for (int i=0; i<N; i++) {\r\n//			System.out.println(Arrays.toString(arr[i]));\r\n//		}\r\n//		System.out.println();\r\n		\r\n		// 기저조건: 끝까지 도달한 경우\r\n		if (pipe.r2==N-1 && pipe.c2==N-1) {\r\n			result += 1;\r\n			return;\r\n		}\r\n		\r\n		\r\n		// 재귀\r\n		// 이동 가능한 3가지 경우 탐색\r\n		int ogr1  = pipe.r1;\r\n		int ogc1  = pipe.c1;\r\n		int ogr2  = pipe.r2;\r\n		int ogc2  = pipe.c2;\r\n		int ogdir = pipe.dir;\r\n		//System.out.println(ogr1 + \" \" + ogc1 + \" \" + ogr2 + \" \" + ogc2);\r\n		\r\n\r\n		for (int d=0; d<3; d++) {\r\n			if (ogdir == right) {\r\n				if (d==2) continue;\r\n			} else if (ogdir == down) {\r\n				if (d==0) continue;\r\n			} \r\n			// 0,1 => d=1? 1,2\r\n			\r\n			int nr2 = pipe.r2 + dr[d];\r\n			int nc2 = pipe.c2 + dc[d];\r\n			int nr1 = ogr2;\r\n			int nc1 = ogc2;\r\n			\r\n			//System.out.println(nr1+\" \"+nc1+\" \"+nr2+\" \"+nc2);\r\n			\r\n			int ndir = 999;\r\n			if (d==0) ndir = right;\r\n			else if (d==1) ndir = rightDown;\r\n			else if (d==2) ndir = down;\r\n			\r\n			// 범위를 벗어나는지 체크\r\n			if (nr2<0 || nr2>=N || nc2<0 || nc2>=N) continue;\r\n			// 벽을 만나는지 체크 \r\n			if (arr[nr2][nc2] == 1) {\r\n				continue;\r\n			}\r\n			// 오른쪽아래대각선 이동시 필수적으로 3칸이 비어있는지 확인하기\r\n			if (d == rightDown) {\r\n				if (arr[nr2-1][nc2]==1 || arr[nr2][nc2-1]==1) continue;\r\n					\r\n			}\r\n			\r\n			// 방문여부 체크\r\n			if (arr[nr2][nc2] != 0) continue;\r\n			// 이동 가능한 경우\r\n			// 맵 정보 업데이트\r\n			// 직전 파이프의 방향에 따라 결정되는 다음 진행 방향이 다르다.\r\n			\r\n			//System.out.println(d);\r\n			//System.out.println(nr1 + \" \" + nc1 + \" \" + nr2 + \" \" + nc2);\r\n			//System.out.println(d);\r\n			arr[nr1][nc1] = -1;\r\n			arr[nr2][nc2] = -1;\r\n			arr[pipe.r1][pipe.c1] = 0;\r\n			//arr[pipe.r2][pipe.c2] = 0;\r\n			pipe.r1 = nr1;\r\n			pipe.c1 = nc1;\r\n			pipe.r2 = nr2;\r\n			pipe.c2 = nc2;\r\n			pipe.dir = ndir;\r\n			\r\n			dfs(pipe);\r\n			\r\n			arr[nr1][nc1] = 0;\r\n			arr[nr2][nc2] = 0;\r\n			arr[ogr1][ogc1] = -1;\r\n			arr[ogr2][ogc2] = -1;\r\n			pipe.r1 = ogr1;\r\n			pipe.c1 = ogc1;\r\n			pipe.r2 = ogr2;\r\n			pipe.c2 = ogc2;\r\n			pipe.dir = ogdir;\r\n//			for (int i=0; i<N; i++) {\r\n//				System.out.println(Arrays.toString(arr[i]));\r\n//			}\r\n//			System.out.println();\r\n		}\r\n		\r\n		\r\n	}\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n',512,15312,3586,165),
(51357713,3649,2,'2022-11-05 19:32:59','맞았습니다!!','ac','java','import java.io.BufferedReader;\r\nimport java.io.InputStreamReader;\r\nimport java.util.Arrays;\r\n \r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n        String str;\r\n        while((str = br.readLine())!=null) {\r\n            int X = Integer.parseInt(str)*10000000;\r\n            int N = Integer.parseInt(br.readLine());\r\n            int[] legos = new int[N];\r\n            for(int i=0; i<legos.length; i++) legos[i] = Integer.parseInt(br.readLine());\r\n            Arrays.sort(legos);\r\n            int s = 0, e = N-1;\r\n            boolean flag = false;\r\n            while(s<e) {\r\n                int sum = legos[s]+legos[e];\r\n                if(sum==X) {\r\n                    flag = true;\r\n                    break;\r\n                }\r\n                else if(sum<X) s++;\r\n                else e--;\r\n            }\r\n            if(flag) System.out.println(\"yes \"+legos[s]+\" \"+legos[e]);\r\n            else System.out.println(\"danger\");\r\n        }\r\n    }\r\n}',1660,305992,1040,142),
(52376911,24727,7,'2022-12-04 20:47:40','맞았습니다!! (100/100)','ac','java','\r\nimport java.util.LinkedList;\r\nimport java.util.Queue;\r\nimport java.util.Scanner;\r\n\r\npublic class Main {\r\n	static StringBuilder sb;\r\n	static int[] dr = {-1, 0, 1 , 0};\r\n	static int[] dc = {0 , -1, 0, 1};\r\n\r\n	static int N; // 지도의 크기 \r\n	static int[][] map; // 지도 \r\n	static int C, E; // 컴공크기, 공과대학크기 \r\n	\r\n	static int row, col;\r\n	\r\n	public static void main(String[] args) {\r\n		Scanner sc = new Scanner(System.in);\r\n		sb = new StringBuilder();\r\n		\r\n		N = sc.nextInt();\r\n		C = sc.nextInt();\r\n		E = sc.nextInt();\r\n		\r\n		map = new int[N][N];\r\n		\r\n		// 컴공, 공대 중에서 큰 공간을 구한다. (초기 공간 분열을 한 번만 진행 후, 남은 수의 공간을 적게 세기 위해서) \r\n		if (C >= E) {\r\n			// 큰 영역을 1로 채운다. (1: 컴공)\r\n			fill(map, C, 1);\r\n			// 울타리 채우기 \r\n			wood(map, 1);\r\n			if (check( E, 2)) {\r\n				System.out.println(1);	\r\n				fill2(map, E, 2);\r\n				print(map);\r\n			} else {\r\n				System.out.println(-1);\r\n			}\r\n		} else {\r\n			// 큰 영역을 2로 채운다. (2: 공과대학) \r\n			fill(map, E, 2);\r\n			// 울타리 채우기 \r\n			wood(map, 2);\r\n			if (check(C, 1)) {\r\n				System.out.println(1);\r\n				fill2(map, C, 1);\r\n				print(map);\r\n			} else {\r\n				System.out.println(-1);\r\n			}\r\n		}\r\n		\r\n		\r\n	}\r\n\r\n	private static void fill2(int[][] map, int min, int type) {\r\n		// BFS 로 채우기. (최선으로 채우는 방법) \r\n			Queue<int[]> queue = new LinkedList<>();\r\n			queue.add(new int[] {N-1, N-1});\r\n			map[N-1][N-1] = type;\r\n			int cnt = 1;\r\n			while (!queue.isEmpty()) {\r\n				int[] cur = queue.poll();\r\n					\r\n				for (int i=0; i<2; i++) {\r\n					if (cnt >= min) return;\r\n					int nr = cur[0] + dr[i];\r\n					int nc = cur[1] + dc[i];\r\n					\r\n					if (nr<0 || nr>=N || nc<0 || nc>=N) continue;\r\n						\r\n					if (map[nr][nc] != 0) continue;\r\n						\r\n					map[nr][nc] = type;\r\n					queue.add(new int[] {nr, nc});\r\n					cnt++;\r\n					\r\n						\r\n				}\r\n					\r\n			}\r\n	}\r\n\r\n	// 0 의 개수가 세울 수 있는 작은 건물의 영역만큼 넉넉한지 체크하는 함수 \r\n	private static boolean check(int min, int antiType) {\r\n		int cnt = 0;\r\n		for (int i=0; i<N; i++) {\r\n			for (int j=0; j<N; j++) {\r\n				if (map[i][j] == 0) {\r\n					cnt++; \r\n					if (cnt >= min) {\r\n						return true;\r\n					}\r\n				}\r\n			}\r\n		}\r\n		\r\n		return false;\r\n		\r\n	}\r\n\r\n	// 현재 채워진 건물 중심으로 울타리를 채운다. \r\n	private static void wood(int[][] map, int type) {\r\n		for (int i=0; i<N; i++) {\r\n			for (int j=0; j< N; j++) {\r\n				if (map[i][j] == type) { // 현재위치가 건물일 때 \r\n					//visited[i][j] = true;\r\n					// 주변에 울타리 설치가 가능한지 체크 \r\n					for (int d=2; d<4; d++) {\r\n						int nr = i + dr[d];\r\n						int nc = j + dc[d];\r\n						\r\n						if (nr<0 || nr>=N || nc<0 || nc>=N) continue; // 유효성 체크 \r\n						\r\n						if (map[nr][nc] == type || map[nr][nc] == 9) continue;\r\n						\r\n						// 울타리 설치 가능  (울타리 : 9) \r\n						map[nr][nc] = 9;\r\n\r\n					}\r\n					\r\n				}\r\n			}\r\n		}\r\n		\r\n	}\r\n\r\n	// type의 값으로 2중포문을 돌며 채운다. \r\n	private static void fill(int[][] map, int max, int type) {\r\n		\r\n//		// max개의 개수만큼만 채우기 위해서 cnt 변수를 통해 제어합니다. \r\n//		int cnt = 1;\r\n//		// 2중 반복문을 돌며 타입의 값으로 건물의 영역을 채웁니다. (최선으로 채우는 방법) (그리디) \r\n//		for (int i=0; i<N; i++) {\r\n//			for (int j=0; j<N; j++) {\r\n//				row = i;\r\n//				col = j;\r\n//				if (cnt++ > max) break;\r\n//				map[i][j] = type;\r\n//			}\r\n//		}\r\n		\r\n		\r\n		// BFS 로 채우기. (최선으로 채우는 방법) \r\n		Queue<int[]> queue = new LinkedList<>();\r\n		queue.add(new int[] {0, 0});\r\n		map[0][0] = type;\r\n		int cnt = 1;\r\n		while (!queue.isEmpty()) {\r\n			int[] cur = queue.poll();\r\n			\r\n			for (int i=2; i<4; i++) {\r\n				if (cnt >= max) return;\r\n				int nr = cur[0] + dr[i];\r\n				int nc = cur[1] + dc[i];\r\n				\r\n				if (nr<0 || nr>=N || nc<0 || nc>=N) continue;\r\n				\r\n				if (map[nr][nc] != 0) continue;\r\n				\r\n				map[nr][nc] = type;\r\n				queue.add(new int[] {nr, nc});\r\n				cnt++;\r\n				\r\n				\r\n			}\r\n			\r\n		}\r\n		\r\n		\r\n		\r\n	}\r\n	\r\n	// 2차원 배열을 출력하는 함수 \r\n	private static void print(int[][] map) {\r\n		\r\n		for (int i=0; i<N; i++) {\r\n			for (int j=0; j<N; j++) {\r\n				if (map[i][j] == 9) {\r\n					sb.append(0);\r\n				} else {\r\n					sb.append(map[i][j]);\r\n				}\r\n			}\r\n			sb.append(\"\\n\");\r\n		}\r\n		\r\n		System.out.print(sb.toString());\r\n	}\r\n\r\n}\r\n',228,18236,4292,127),
(52604648,1111,2,'2022-12-12 19:55:31','맞았습니다!!','ac','java','import java.io.BufferedReader;\r\nimport java.io.InputStreamReader;\r\nimport java.util.ArrayDeque;\r\nimport java.util.Collections;\r\nimport java.util.Deque;\r\nimport java.util.List;\r\nimport java.util.StringTokenizer;\r\n\r\npublic class Main {\r\n	static int N;\r\n	static int map[];\r\n	static int a, b;\r\n\r\n	public static void main(String[] args) throws Exception {\r\n		BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\r\n		N = Integer.parseInt(bf.readLine());\r\n		StringTokenizer st = new StringTokenizer(bf.readLine());\r\n		map = new int[N];\r\n		for (int i = 0; i < N; i++)\r\n			map[i] = Integer.parseInt(st.nextToken());\r\n		if (N == 1) {\r\n			System.out.println(\'A\');\r\n			return;\r\n		}\r\n		if (N == 2) {\r\n			if (map[0] == map[1]) {\r\n				System.out.println(map[0]);\r\n				return;\r\n			} else {\r\n				System.out.println(\'A\');\r\n				return;\r\n			}\r\n		}\r\n		if (map[0] == map[1]) {\r\n			a = 1;\r\n			b = 0;\r\n\r\n		} else {\r\n			if ((map[1] - map[2]) % (map[0] - map[1]) != 0) {\r\n				System.out.println(\'B\');\r\n				return;\r\n			} else {\r\n				a = (map[1] - map[2]) / (map[0] - map[1]);\r\n				b = map[1] - (map[0] * a);\r\n			}\r\n		}\r\n		for (int i = 1; i < N; i++) {\r\n			if (map[i] != map[i - 1] * a + b) {\r\n				System.out.println(\'B\');\r\n				return;\r\n			}\r\n		}\r\n		if (map[0] == map[1]) {\r\n			System.out.println(map[0]);\r\n		} else\r\n			System.out.println(map[N - 1] * a + b);\r\n	}\r\n\r\n}\r\n',76,11552,1303,137),
(52695049,16139,2,'2022-12-15 15:59:43','100점','ac','java','import java.util.*;\r\nimport java.io.*;\r\n\r\npublic class Main {\r\n	public static void main(String args[]) throws Exception {\r\n		BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\r\n		StringBuilder sb = new StringBuilder();\r\n		StringTokenizer st;\r\n		String str = bf.readLine();\r\n		if (str.length() > 1) {\r\n			int vis = 1 << 26;\r\n			int k = 0;\r\n			for (int i = 0; i < str.length(); i++) {\r\n				k = (int) str.charAt(i) - 97;\r\n				k = 1 << k;\r\n				if ((k & vis) > 0)\r\n					continue;\r\n				else {\r\n					vis = vis | k;\r\n				}\r\n			}\r\n			ArrayList<int[]> map = new ArrayList<>();\r\n			for (int i = 0; i < 26; i++) {\r\n				if ((vis & 1 << i) > 0)\r\n					map.add(new int[str.length()]);\r\n				else\r\n					map.add(new int[1]);\r\n			}\r\n\r\n			for (int i = 0; i < 26; i++) {\r\n				if (map.get(i).length == 1)\r\n					continue;\r\n				map.get(i)[0] = ((int) str.charAt(0) - 97 - i == 0 ? 1 : 0);\r\n				for (int j = 1; j < str.length(); j++) {\r\n					if ((int) str.charAt(j) - 97 - i == 0) {\r\n						map.get(i)[j] += map.get(i)[j - 1] + 1;\r\n					} else\r\n						map.get(i)[j] = map.get(i)[j - 1];\r\n				}\r\n			}\r\n			int N = Integer.parseInt(bf.readLine());\r\n			char a;\r\n			int start = 0;\r\n			int end = 0;\r\n			int answer = 0;\r\n//			for (int[] c : map)\r\n//				System.out.println(Arrays.toString(c));\r\n			for (int i = 0; i < N; i++) {\r\n				st = new StringTokenizer(bf.readLine());\r\n				a = st.nextToken().charAt(0);\r\n				start = Integer.parseInt(st.nextToken());\r\n				end = Integer.parseInt(st.nextToken());\r\n				if (map.get((int) a - 97).length > 1) {\r\n					if (start > 0)\r\n						answer = map.get((int) a - 97)[end] - map.get((int) a - 97)[start - 1];\r\n					else\r\n						answer = map.get((int) a - 97)[end];\r\n					sb.append(answer).append(\"\\n\");\r\n				} else if (map.get((int) a - 97).length == 1) {\r\n					sb.append(0).append(\"\\n\");\r\n				}\r\n			}\r\n		} else if (str.length() == 1) {\r\n			int N = Integer.parseInt(bf.readLine());\r\n			char a;\r\n			int start;\r\n			int end;\r\n			for (int i = 0; i < N; i++) {\r\n				st = new StringTokenizer(bf.readLine());\r\n				a = st.nextToken().charAt(0);\r\n				start = Integer.parseInt(st.nextToken());\r\n				end = Integer.parseInt(st.nextToken());\r\n				if (a == str.charAt(0))\r\n					sb.append(1).append(\"\\n\");\r\n				else\r\n					sb.append(0).append(\"\\n\");\r\n			}\r\n		}\r\n		System.out.println(sb.toString());\r\n		// 97 a\r\n		// 122 z\r\n	}\r\n\r\n}',704,102624,2254,133),
(54860348,14503,6,'2023-01-28 23:45:11','맞았습니다!!','ac','cpp','#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nint N, M;\r\n\r\nint rbx = 0;\r\nint rby = 0;\r\nint rbdir = 0;\r\n\r\nint dr[] = {-1,0,1,0};\r\nint dc[] = {0,1,0,-1};\r\n\r\nint room[51][51] = { 0, };\r\nint used[51][51] = { 0, };\r\nint cnt = 0;\r\n\r\nvoid robot_clean()\r\n{\r\n\r\n	int work = 0;\r\n	int rotate = rbdir;\r\n	for (int i = 0; i < 4; i++)\r\n	{\r\n		rotate--;\r\n		if (rotate < 0) rotate = 3;\r\n		int ny = dr[rotate] + rby;\r\n		int nx = dc[rotate] + rbx;\r\n		//벽\r\n		if (room[ny][nx]) continue;\r\n		//왼쪽방향 청소있음\r\n		if (i == 0 && used[ny][nx] == 0)\r\n		{\r\n			rbx = nx;\r\n			rby = ny;\r\n			rbdir = rotate;\r\n			cnt++;\r\n			used[ny][nx] = 1;\r\n			robot_clean();\r\n			return;\r\n		}\r\n		//왼쪽 방향 청소없는경우\r\n		//어느방향이라도 청소할게 있다.\r\n		if (!used[ny][nx])\r\n		{\r\n			work = 1;\r\n			rbdir = rotate+1;\r\n			break;\r\n		}\r\n	}\r\n	if (work == 1)\r\n	{\r\n		robot_clean();\r\n		return;\r\n	}\r\n	//일이 없다면\r\n	int by = -1 * dr[rbdir] + rby;\r\n	int bx = -1 * dc[rbdir] + rbx;\r\n	// 뒤가 벽이면 종료\r\n	if (room[by][bx]) return;\r\n	rbx = bx;\r\n	rby = by;\r\n	robot_clean();\r\n}\r\nint main()\r\n{\r\n	cin >> N >> M;\r\n\r\n	cin >> rby >> rbx >> rbdir;\r\n	used[rby][rbx] = 1;\r\n	for (int r = 0; r < N; r++)\r\n	{\r\n		for (int c = 0; c <M; c++)\r\n		{\r\n			cin >> room[r][c];\r\n			if (room[r][c] > 0) used[r][c] = 2;\r\n		}\r\n	}\r\n	//int de = 1;\r\n	cnt = 1;\r\n	int de = 1;\r\n	robot_clean();\r\n	cout << cnt;\r\n	return 0;\r\n}',0,2040,1298,162),
(54894098,14500,6,'2023-01-29 19:03:46','맞았습니다!!','ac','cpp','#include <iostream>\r\n\r\nusing namespace std;\r\n\r\n//테트로노미노는 길이가 4인 칸\r\nint num_arr[501][501] = { 0, };\r\nint used[501][501] = { 0, };\r\n\r\nint dr[4] = { 1,0, 0,-1 };\r\nint dc[4] = { 0,1, -1,0 };\r\nint N, M;\r\nint mxscore = 0;\r\nvoid len4_func(int y,  int x, int num, int score)\r\n{\r\n	if (num == 4)\r\n	{\r\n		if (mxscore < score) mxscore = score;\r\n		return;\r\n	}\r\n	// 중복 방지 위해 방향은 좌우하로만 제한\r\n	for (int i = 0; i < 3; i++)\r\n	{\r\n		int ny = y + dr[i];\r\n		int nx = x + dc[i];\r\n		if (ny <0 || nx <0 || ny>N || nx >M) continue;\r\n		if (used[ny][nx]) continue;\r\n		used[ny][nx] = 1;\r\n		len4_func(ny, nx, num+1, score+num_arr[ny][nx]);\r\n		used[ny][nx] = 0;\r\n	}\r\n}\r\n\r\nvoid octo_func(int y,  int x)\r\n{\r\n	int n = 0;\r\n	int mn = 123123;\r\n	int numsum = num_arr[y][x];\r\n	for (int i = 0; i < 4; i++)\r\n	{\r\n		int ny = y + dr[i];\r\n		int nx = x + dc[i];\r\n		if (ny <0 || nx <0 || ny>N || nx >M) continue;\r\n		n++;\r\n		if (num_arr[ny][nx] < mn) mn = num_arr[ny][nx];\r\n		numsum += num_arr[ny][nx];\r\n	}\r\n	if (n >= 4) numsum -= mn;\r\n	if (numsum > mxscore) mxscore = numsum;\r\n}\r\n\r\nint main()\r\n{\r\n	cin >> N >> M;\r\n	for (int r = 0; r < N; r++)\r\n	{\r\n		for (int c = 0; c < M; c++)\r\n		{\r\n			cin >> num_arr[r][c];\r\n		}\r\n	}\r\n\r\n	for (int r = 0; r < N; r++)\r\n	{\r\n		for (int c = 0; c < M; c++)\r\n		{\r\n			used[r][c] = 1;\r\n			len4_func(r, c, 1, num_arr[r][c]);\r\n			used[r][c] = 0;\r\n			octo_func(r, c);\r\n		}\r\n	}\r\n	cout << mxscore;\r\n}',80,3980,1354,134),
(54903147,14502,6,'2023-01-29 21:31:49','맞았습니다!!','ac','cpp','#include <iostream>\r\n#include <queue>\r\n\r\nusing namespace std;\r\n\r\nint N, M;\r\nint arr[10][10] = { 0, };\r\nint used[10][10] = { 0, };\r\nint mxscore = 0;\r\nstruct coord\r\n{\r\n	int y, x;\r\n};\r\nint sum = 0;\r\n\r\nqueue <coord> q;\r\nqueue <coord> q_next;\r\nint visited[10][10] = { 0, };\r\nint dr[] = { -1,1,0,0 };\r\nint dc[] = { 0,0,-1,1 };\r\nint nzerosub = 0;\r\nvoid bfs()\r\n{\r\n	if (mxscore >= sum - nzerosub)\r\n	{\r\n		while (!q.empty())\r\n		{\r\n			q.pop();\r\n		}\r\n		return;\r\n	}\r\n	while (!q.empty())\r\n	{\r\n		coord A = q.front();\r\n		q.pop();\r\n		for (int i = 0; i < 4; i++)\r\n		{\r\n			int nx = A.x + dc[i];\r\n			int ny = A.y + dr[i];\r\n			if (ny < 0 || nx < 0 || ny >= N || nx >= M) continue;\r\n			//벽, 지나간곳, 바이러스 회피\r\n			if (visited[ny][nx]) continue;\r\n			if (used[ny][nx])continue;\r\n			visited[ny][nx] = 1;\r\n			nzerosub++;\r\n			q_next.push({ ny,nx });\r\n		}\r\n	}\r\n	while (!q_next.empty())\r\n	{\r\n		coord A = q_next.front();\r\n		q_next.pop();\r\n		q.push({ A.y, A.x });\r\n	}\r\n	if (q.empty())\r\n	{\r\n		if (mxscore < sum - nzerosub) mxscore = sum - nzerosub;\r\n		return;\r\n	}\r\n	bfs();\r\n}\r\nvoid func(int r, int c, int n)\r\n{\r\n	if (c == M)\r\n	{\r\n		r +=1;\r\n		c = 0;\r\n	}\r\n	if (n == 3)\r\n	{\r\n		nzerosub = 0;\r\n		bfs();\r\n		for (int i = 0; i < N; i++)\r\n		{\r\n			for (int j = 0; j < M; j++)\r\n			{;\r\n				visited[i][j] = 0;\r\n				if (arr[i][j] == 2) q.push({ i,j });\r\n			}\r\n		}\r\n\r\n		return;\r\n	}\r\n	for (int i = r; i < N; i++)\r\n	{\r\n		for (int j = 0; j < M; j++)\r\n		{\r\n			if (i == r && j < c) continue;\r\n			if (used[i][j]) continue;\r\n			used[i][j] = 1;\r\n			func(r,c+1, n+1);\r\n			used[i][j] = 0;\r\n		}\r\n	}\r\n}\r\n\r\nint main()\r\n{\r\n	cin >> N >> M;\r\n\r\n	for (int i = 0; i < N; i++)\r\n	{\r\n		for (int j = 0; j < M; j++)\r\n		{\r\n			cin >> arr[i][j];\r\n			used[i][j] = arr[i][j];\r\n			if (arr[i][j] == 0) sum += 1;\r\n			if (arr[i][j] == 2) q.push({ i,j });\r\n		}\r\n	}\r\n	int de = 1;\r\n	sum -= 3;\r\n	mxscore = 0;\r\n	func(0, 0, 0);\r\n	cout << mxscore;\r\n	return 0;\r\n}',300,2024,1775,161),
(55367223,14890,6,'2023-02-06 22:05:12','맞았습니다!!','ac','cpp','#include <iostream>\r\n\r\nusing namespace std;\r\nint N, L;\r\nint arr[101][101] = { 0, };\r\n\r\n// -> 지나갈 수 있음: 모두 동일, \r\n// 지나가지 못하는 경우: 1층이 아닌 경우, 1층인데 두칸이 확보되지 않은 경우, 1층 변화 사이에 4칸이 확보되지않은 경우\r\n\r\nint sum = 0;\r\nvoid check(int n, int m)\r\n{\r\n	sum = 0;\r\n	for (int i = 0; i < n; i++)\r\n	{\r\n		int upflag = 1;\r\n		int downflag = 0;\r\n		for (int j = 0; j < n-1; j++){\r\n			//내려가는 경우\r\n			if (arr[i][j + 1] + 1 == arr[i][j]) {\r\n				if (downflag > 0) {\r\n					downflag = -1;\r\n					break;\r\n				}\r\n				downflag = 1;\r\n				if (downflag == m)\r\n				{\r\n					downflag = 0;\r\n					upflag = 0;\r\n				}\r\n			}\r\n			//올라가는 경우\r\n			else if (arr[i][j + 1] == arr[i][j]+1){\r\n				if (downflag > 0){\r\n					downflag = -1;\r\n					break;\r\n				}\r\n				if (upflag >= m) upflag = 1;\r\n				else{\r\n					upflag = - 1;\r\n					break;\r\n				}\r\n			}\r\n			else if (arr[i][j+1]==arr[i][j]){\r\n				// 내려가고 있었다.\r\n				if (downflag >0) {\r\n					downflag ++;\r\n					upflag = 0;\r\n					if (downflag == m) downflag = 0;\r\n				}\r\n				else {\r\n					upflag++;\r\n				}\r\n			}\r\n			else{\r\n				upflag = -1;\r\n				break;\r\n			}\r\n		}\r\n		if (upflag == -1 || downflag >= 1 || downflag == -1) continue;\r\n		sum++;\r\n	}\r\n\r\n	for (int j = 0; j < n; j++){\r\n		int upflag = 1;\r\n		int downflag = 0;\r\n		for (int i = 0; i < n - 1; i++){\r\n			//내려가는 경우\r\n			if (arr[i+1][j] + 1 == arr[i][j]){\r\n				if (downflag > 0) {\r\n					downflag = -1;\r\n					break;\r\n				}\r\n				downflag = 1;\r\n				if (downflag == m)\r\n				{\r\n					downflag = 0;\r\n					upflag = 0;\r\n				}\r\n			}\r\n			//올라가는 경우\r\n			else if (arr[i+1][j] == arr[i][j] + 1) {\r\n				if (downflag > 0) {\r\n					downflag = -1;\r\n					break;\r\n				}\r\n				if (upflag >= m) upflag = 1;\r\n				else {\r\n					upflag = -1;\r\n					break;\r\n				}\r\n			}\r\n			else if (arr[i+1][j] == arr[i][j]) {\r\n				// 내려가고 있었다.\r\n				if (downflag > 0) {\r\n					downflag++;\r\n					upflag = 0;\r\n					if (downflag == m) downflag = 0;\r\n				}\r\n				else {\r\n					upflag++;\r\n				}\r\n			}\r\n			// 2층 이상 차이나는 경우\r\n			else{\r\n				upflag = -1;\r\n				break;\r\n			}\r\n		}\r\n		if ( upflag == -1 || downflag >= 1 || downflag == -1) continue;\r\n		sum++;\r\n	}\r\n}\r\nint main(){\r\n	cin >> N >> L;\r\n	for (int i = 0; i < N; i++){\r\n		for (int j = 0; j < N; j++){\r\n			cin >> arr[i][j];\r\n		}\r\n	}\r\n	\r\n	check(N, L);\r\n	cout << sum << endl;\r\n	return 0;\r\n}',0,2060,2287,163),
(56252197,25314,21,'2023-02-22 00:14:38','맞았습니다!!','ac','python','N = int(input())\r\n\r\nfor i in range(N//4):\r\n    print(\"long\", end = \" \")\r\n\r\nprint(\"int\")',40,31256,82,155),
(58423920,15652,19,'2023-03-30 15:39:39','맞았습니다!!','ac','python','N, M = map(int,input().split())\r\nvisited = [0]*(N+2)\r\nans = []\r\n\r\ndef dfs(n, s, lst):\r\n    global ans\r\n    if n == M:\r\n        ans.append(lst)\r\n        return\r\n    for i in range(s, N + 1):\r\n        dfs(n+1, i, lst + [i])\r\n\r\ndfs(0, 1, [])\r\nfor x in ans:\r\n    print(*x)',60,32276,254,148),
(60519947,1000,1,'2023-05-09 16:51:07','맞았습니다!!','ac','c','#include<stdio.h>\r\nint main()\r\n{	\r\n	int a;\r\n	int b;\r\n	int result;\r\n\r\n	scanf(\"%d %d\",&a,&b);\r\n	result = a+b;\r\n	printf(\"%d\",result);\r\n	return 0;\r\n}',0,1112,134,140),
(60555780,1012,1,'2023-05-10 10:35:41','맞았습니다!!','ac','java','import java.io.BufferedReader;\r\nimport java.io.FileInputStream;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.LinkedList;\r\nimport java.util.Queue;\r\nimport java.util.StringTokenizer;\r\n\r\npublic class Main {\r\n\r\n	\r\n	public static int bfs(int[][] board, int n, int m) {\r\n	\r\n		\r\n		int result = 0;\r\n		int[][] visited = new int[n][m];\r\n		int[][] dir = {{0, 1} ,{1, 0}, {0, -1}, {-1, 0} };\r\n		\r\n		\r\n		for(int i=0;i<n;i++) {\r\n			for(int j=0;j<m;j++) {\r\n				\r\n				if (visited[i][j] == 0 && board[i][j] == 1) {\r\n					\r\n					result++;\r\n					\r\n					Queue<int[]> q = new LinkedList<int[]>();\r\n					q.add(new int[] {i, j});\r\n					visited[i][j] = 1;\r\n					\r\n					while(!q.isEmpty()) {\r\n						\r\n						int[] temp = q.poll();\r\n						int x = temp[0], y = temp[1];\r\n						\r\n						for(int[] d : dir) {\r\n							\r\n							int nx = x + d[0];\r\n							int ny = y + d[1];\r\n							\r\n							if (0 <= nx && nx < n && 0 <= ny && ny < m) {\r\n								if (visited[nx][ny] == 0 && board[nx][ny] == 1) {\r\n									q.add(new int[] {nx, ny});\r\n									visited[nx][ny] = 1;\r\n								} \r\n							}\r\n							\r\n						}\r\n						\r\n						\r\n					}\r\n					\r\n					\r\n				}\r\n				\r\n			}\r\n		}\r\n		\r\n		\r\n		\r\n		\r\n		\r\n		return result;\r\n	}\r\n	\r\n	public static int result;\r\n	public static StringBuilder answer;\r\n	public static void main(String[] args) throws IOException {\r\n		//System.setIn(new FileInputStream(\"input/1012.txt\"));\r\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n		StringTokenizer st;\r\n		\r\n		int testCnt = Integer.parseInt(br.readLine());\r\n		\r\n		for(int t=1;t<=testCnt;t++) {\r\n			st = new StringTokenizer(br.readLine());\r\n			\r\n			int n = Integer.parseInt(st.nextToken());\r\n			int m = Integer.parseInt(st.nextToken());\r\n			int k = Integer.parseInt(st.nextToken());\r\n			\r\n			int[][] board = new int[n][m];\r\n			\r\n			for(int i=0;i<k;i++) {\r\n				st = new StringTokenizer(br.readLine());\r\n				int x = Integer.parseInt(st.nextToken());\r\n				int y = Integer.parseInt(st.nextToken());\r\n				\r\n				board[x][y] = 1;\r\n			}\r\n			System.out.println(bfs(board, n, m));\r\n			\r\n		}\r\n\r\n	}\r\n\r\n}\r\n',164,16040,1993,129),
(60617442,2557,6,'2023-05-11 14:19:12','맞았습니다!!','ac','cpp','#include <iostream>\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    cout <<\"Hello World!\"<< endl;\r\n}',0,2020,90,160),
(60630938,14499,15,'2023-05-11 17:57:02','맞았습니다!!','ac','cpp','#include <iostream>\r\n#include <string>\r\n#include <unordered_map>\r\n\r\nusing namespace std;\r\nunordered_map<string, int> um;\r\nint N, M, K;\r\nint dr[] = { 0,0,0,-1,1 };\r\nint dc[] = { 0,1,-1,0,0 };\r\nint py, px;\r\nint arr[21][21] = { 0, };\r\n\r\nvoid init()\r\n{\r\n	um[\"top\"] = 0;\r\n	um[\"btm\"] = 0;\r\n	um[\"rgt\"] = 0;\r\n	um[\"lft\"] = 0;\r\n	um[\"frt\"] = 0;\r\n	um[\"bck\"] = 0;\r\n}\r\nvoid input()\r\n{\r\n	cin >> N >> M >> px >> py >> K;\r\n	for (int i = 0; i < N; i++)\r\n	{\r\n		for (int j = 0; j < M; j++)\r\n		{\r\n			cin >> arr[i][j];\r\n		}\r\n	}\r\n}\r\n\r\nvoid dice_change(int d)\r\n{\r\n	int empty = 0;\r\n	// 동서남북 1234\r\n	if (d < 3) // 동서\r\n	{\r\n		int m = d % 2; // 동: 1, 서: 0\r\n		// 동 1번 서 3번 반복\r\n		while (m <= d)\r\n		{\r\n			empty = um[\"top\"];\r\n			um[\"top\"] = um[\"lft\"];\r\n			um[\"lft\"] = um[\"btm\"];\r\n			um[\"btm\"] = um[\"rgt\"];\r\n			um[\"rgt\"] = empty;\r\n			m++;\r\n		}\r\n	}\r\n	else\r\n	{\r\n		int m = d % 2+1; // 북: 2, 남: 1\r\n		// 북 1번 남 3번 반복\r\n		while (m < d)\r\n		{\r\n			empty = um[\"top\"];\r\n			um[\"top\"] = um[\"frt\"];\r\n			um[\"frt\"] = um[\"btm\"];\r\n			um[\"btm\"] = um[\"bck\"];\r\n			um[\"bck\"] = empty;\r\n			m++;\r\n		}\r\n	}\r\n}\r\n\r\nvoid dice_move(int dir)\r\n{\r\n	//y는 횡 x는 종\r\n	int ny = py + dc[dir];\r\n	int nx = px + dr[dir];\r\n	// 바깥 향할시 명령 무시\r\n	if (ny < 0 || nx < 0 || ny >= M || nx >= N) return;\r\n	py = ny;\r\n	px = nx;\r\n	dice_change(dir);\r\n	cout << um[\"top\"] << endl;\r\n	// 이동한 칸 !=0 -> 주사위 바닥면 = 칸 && 칸=0;\r\n	if (arr[px][py] != 0)\r\n	{\r\n		um[\"btm\"] = arr[px][py];\r\n		arr[px][py] = 0;\r\n	}\r\n	// 이동할 칸 0이면 칸 = 주사위 바닥면\r\n	else arr[px][py] = um[\"btm\"];\r\n\r\n}\r\nvoid solve()\r\n{\r\n	int ord = 0;\r\n	for (int i = 0; i < K; i++)\r\n	{\r\n		cin >> ord;\r\n		dice_move(ord);\r\n	}\r\n}\r\nint main()\r\n{\r\n	init();\r\n	input();\r\n	int de = 1;\r\n	solve();\r\n	return 0;\r\n}',40,2032,1664,153),
(60845144,17081,4,'2023-05-16 13:23:50','맞았습니다!!','ac','java','import java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.StringTokenizer;\r\n\r\npublic class Main {\r\n\r\n	// 위, 아래, 왼쪽, 오른쪽\r\n	static int[] dr = { -1, 1, 0, 0 };\r\n	static int[] dc = { 0, 0, -1, 1 };\r\n	// 출력을 위한 화면 map\r\n	static char[][] map;\r\n	// 해당 위치의 실제 정보를 담고 있는 map\r\n	static Object_info[][] info_map;\r\n	// 플레이어 class\r\n	static Player player;\r\n	static int[] start;\r\n	// 각각의 장신구를 가지고 있는가?\r\n	static boolean O_HR = false;\r\n	static boolean O_RE = false;\r\n	static boolean O_CO = false;\r\n	static boolean O_EX = false;\r\n	static boolean O_DX = false;\r\n	static boolean O_HU = false;\r\n\r\n	public static void main(String[] args) throws IOException {\r\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n		StringTokenizer st = new StringTokenizer(br.readLine());\r\n		int H = Integer.parseInt(st.nextToken());\r\n		int W = Integer.parseInt(st.nextToken());\r\n		int number_item = 0;\r\n		int number_monster = 0;\r\n		map = new char[H][W];\r\n		info_map = new Object_info[H][W];\r\n		for (int i = 0; i < H; i++) {\r\n			map[i] = br.readLine().toCharArray();\r\n			for (int j = 0; j < W; j++) {\r\n				if (map[i][j] == \'B\')\r\n					number_item++;\r\n				if (map[i][j] == \'&\' || map[i][j] == \'M\')\r\n					number_monster++;\r\n				if (map[i][j] == \'@\') {\r\n					map[i][j] = \'.\';\r\n					player = new Player(i, j, 1, 20, 2, 2, 0, 20, 5);\r\n					start = new int[] { i, j };\r\n				}\r\n			}\r\n		} // 맵 정보 입력 + 플레이어 확인.\r\n\r\n		// 행동 커맨드.\r\n		String command = br.readLine();\r\n\r\n		for (int i = 0; i < number_monster; i++) {\r\n			st = new StringTokenizer(br.readLine());\r\n			int r = Integer.parseInt(st.nextToken()) - 1;\r\n			int c = Integer.parseInt(st.nextToken()) - 1;\r\n			String name = st.nextToken();\r\n			int ATT = Integer.parseInt(st.nextToken());\r\n			int DEF = Integer.parseInt(st.nextToken());\r\n			int HP = Integer.parseInt(st.nextToken());\r\n			int get_EXP = Integer.parseInt(st.nextToken());\r\n			info_map[r][c] = new Object_info(\"monster\", name, ATT, DEF, HP, get_EXP);\r\n		} // 몬스터 정보 입력\r\n\r\n		for (int i = 0; i < number_item; i++) {\r\n			st = new StringTokenizer(br.readLine());\r\n			int r = Integer.parseInt(st.nextToken()) - 1;\r\n			int c = Integer.parseInt(st.nextToken()) - 1;\r\n			String name = st.nextToken();\r\n			if (name.equals(\"O\")) {\r\n				String item_type = st.nextToken();\r\n				info_map[r][c] = new Object_info(\"item\", name + \"_\" + item_type, 0, 0);\r\n			} else if (name.equals(\"W\")) {\r\n				int ATT = Integer.parseInt(st.nextToken());\r\n				info_map[r][c] = new Object_info(\"item\", name, ATT, 0);\r\n			} else {\r\n				int DEF = Integer.parseInt(st.nextToken());\r\n				info_map[r][c] = new Object_info(\"item\", name, 0, DEF);\r\n			}\r\n		} // 아이탬 정보 입력\r\n\r\n		int now_turn = 1;\r\n		while (true) {\r\n			// 커멘드가 다 돌았지만 게임이 끝나지 않았을 때.\r\n			if (command.length() < now_turn) {\r\n				map[player.r][player.c] = \'@\';\r\n				print(now_turn - 1);\r\n				System.out.println(\"Press any key to continue.\");\r\n				return;\r\n			}\r\n\r\n			// 커맨드에 맞게 케릭터를 움직여 준다.\r\n			int R, C;\r\n			if (command.charAt(now_turn - 1) == \'U\') {\r\n				R = player.r + dr[0];\r\n				C = player.c + dc[0];\r\n			} else if (command.charAt(now_turn - 1) == \'D\') {\r\n				R = player.r + dr[1];\r\n				C = player.c + dc[1];\r\n			} else if ((command.charAt(now_turn - 1) == \'L\')) {\r\n				R = player.r + dr[2];\r\n				C = player.c + dc[2];\r\n			} else {\r\n				R = player.r + dr[3];\r\n				C = player.c + dc[3];\r\n			}\r\n			if (0 <= R && R < H && 0 <= C && C < W && map[R][C] != \'#\') {\r\n				player.r = R;\r\n				player.c = C;\r\n			}\r\n\r\n			R = player.r;\r\n			C = player.c;\r\n			// 스파이크 함정에 걸렸다!\r\n			if (map[R][C] == \'^\') {\r\n				// 주인공이 O_DX 아이탬을 가지고 있는가?\r\n				if (!O_DX) {\r\n					player.HP = Math.max(0, player.HP - 5);\r\n				} else {\r\n					player.HP = Math.max(0, player.HP - 1);\r\n				}\r\n\r\n				if (player.HP == 0) {\r\n					if (O_RE) {\r\n						// O_RE장신구를 지우고 시작위치로 돌려보낸다.\r\n						O_RE = false;\r\n						for (int i = 0; i < player.having_O.size(); i++) {\r\n							if (player.having_O.get(i).equals(\"O_RE\")) {\r\n								player.having_O.remove(i);\r\n								break;\r\n							}\r\n						}\r\n						player.HP = player.MAX_HP;\r\n						player.r = start[0];\r\n						player.c = start[1];\r\n					} else {\r\n						// 끄앙 사망\r\n						print(now_turn);\r\n						System.out.println(\"YOU HAVE BEEN KILLED BY SPIKE TRAP..\");\r\n						return;\r\n					}\r\n				}\r\n			} // 스파이크 함정\r\n\r\n			// 아이탬을 주웠다!\r\n			if (map[R][C] == \'B\') {\r\n				// 무기\r\n				if (info_map[R][C].item_type.equals(\"W\")) {\r\n					// 무기 교체\r\n					player.W = info_map[R][C].ATT;\r\n				}\r\n				// 방어구\r\n				else if (info_map[R][C].item_type.equals(\"A\")) {\r\n					// 방어구 교체\r\n					player.A = info_map[R][C].DEF;\r\n				}\r\n				// 무기와 방어구가 아니면 싹다 장신구 겠죵?\r\n				else {\r\n					// 보유 장신구가 4개 미만 && 해당 장신구를 가지고 있지 않다!\r\n					if (player.having_O.size() < 4 && !check_O(info_map[R][C].item_type)) {\r\n						player.having_O.add(info_map[R][C].item_type);\r\n						update_O(info_map[R][C].item_type);\r\n					}\r\n				}\r\n				info_map[R][C] = null;\r\n				map[R][C] = \'.\';\r\n			} // 아이탬 획득\r\n\r\n			// 몬스터와 조우했다!\r\n			if (map[R][C] == \'&\') {\r\n				in_Battle(R, C, info_map[R][C]);\r\n				// 혹시 죽었니?\r\n				if (player.HP == 0) {\r\n					// 끄앙 사망\r\n					print(now_turn);\r\n					System.out.println(\"YOU HAVE BEEN KILLED BY \" + info_map[R][C].monster_name + \"..\");\r\n					return;\r\n				}\r\n				info_map[R][C] = null;\r\n			}\r\n\r\n			// 보스 몬스터와 조우했다!\r\n			if (map[R][C] == \'M\') {\r\n				in_Battle(R, C, info_map[R][C]);\r\n				// 혹시 죽었니?\r\n				if (player.HP == 0) {\r\n					// 끄앙 사망\r\n					print(now_turn);\r\n					System.out.println(\"YOU HAVE BEEN KILLED BY \" + info_map[R][C].monster_name + \"..\");\r\n					return;\r\n				}\r\n				// 게임을 클리어 했다! 보스를 주겼...다?\r\n				else {\r\n					// 혹시 부활아이탬 쓴 거 아니지?\r\n					if (map[R][C] == \'.\') {\r\n						map[R][C] = \'@\';\r\n						print(now_turn);\r\n						System.out.println(\"YOU WIN!\");\r\n						return;\r\n					}\r\n				}\r\n			}\r\n			now_turn++;\r\n		} // RPG 시뮬레이터\r\n\r\n	}// main\r\n\r\n	static boolean check_O(String s) {\r\n		for (int i = 0; i < player.having_O.size(); i++) {\r\n			if (player.having_O.get(i).equals(s))\r\n				return true;\r\n		}\r\n		return false;\r\n	}// check_O\r\n\r\n	static void update_O(String s) {\r\n		if (s.equals(\"O_HR\"))\r\n			O_HR = true;\r\n		if (s.equals(\"O_RE\"))\r\n			O_RE = true;\r\n		if (s.equals(\"O_CO\"))\r\n			O_CO = true;\r\n		if (s.equals(\"O_EX\"))\r\n			O_EX = true;\r\n		if (s.equals(\"O_DX\"))\r\n			O_DX = true;\r\n		if (s.equals(\"O_HU\"))\r\n			O_HU = true;\r\n	}// 장신구 상태 업데이트\r\n\r\n	static void in_Battle(int R, int C, Object_info monster) {\r\n		int turn = 1;\r\n		int monster_HP = monster.HP;\r\n		// 보스 장신구 && 보스전 시작임 일단 에너지 풀로 채우고 시작\r\n		if (map[R][C] == \'M\' && O_HU)\r\n			player.HP = player.MAX_HP;\r\n\r\n		while (true) {\r\n			// 주인공은 언제나 선빵이다!\r\n			if (turn == 1 && O_CO && O_DX) {\r\n				monster.HP = Math.max(0, monster.HP - (Math.max(1, (player.ATT + player.W) * 3 - monster.DEF)));\r\n			} else if (turn == 1 && O_CO && !O_DX) {\r\n				monster.HP = Math.max(0, monster.HP - (Math.max(1, (player.ATT + player.W) * 2 - monster.DEF)));\r\n			} else {\r\n				monster.HP = Math.max(0, monster.HP - (Math.max(1, player.ATT + player.W - monster.DEF)));\r\n			}\r\n			// 혹시 몬스터가 뒤졌니?\r\n			if (monster.HP == 0) {\r\n				if (O_EX) {\r\n					player.EXP += (int) monster.get_EXP * 1.2;\r\n				} else {\r\n					player.EXP += monster.get_EXP;\r\n				}\r\n				if (O_HR)\r\n					player.HP = Math.min(player.MAX_HP, player.HP + 3);\r\n				update_player();\r\n				map[R][C] = \'.\';\r\n				return;\r\n			}\r\n			// 몬스터가 안죽었다! 공격들어온다!\r\n			if (turn == 1 && map[R][C] == \'M\' && O_HU) {\r\n				// 보스전이면서 턴1이다? HU아이탬 있으면 이번턴 적은 자동 턴넘김.\r\n				turn++;\r\n				continue;\r\n			} else {\r\n				player.HP = Math.max(0, player.HP - (Math.max(1, monster.ATT - (player.DEF + player.A))));\r\n			}\r\n			// 혹시 플레이어가 뒤졌니?\r\n			if (player.HP == 0) {\r\n				if (O_RE) {\r\n					// O_RE장신구를 지우고 시작위치로 돌려보낸다.\r\n					O_RE = false;\r\n					for (int i = 0; i < player.having_O.size(); i++) {\r\n						if (player.having_O.get(i).equals(\"O_RE\")) {\r\n							player.having_O.remove(i);\r\n							break;\r\n						}\r\n					}\r\n					monster.HP = monster_HP;\r\n					player.HP = player.MAX_HP;\r\n					player.r = start[0];\r\n					player.c = start[1];\r\n					return;\r\n				} else {\r\n					return;\r\n				}\r\n			}\r\n			turn++;\r\n		} // 전투중\r\n	}// 전투 시뮬레이션\r\n\r\n	static void update_player() {\r\n		if (player.EXP >= player.MAX_EXP) {\r\n			player.LV += 1;\r\n			player.MAX_EXP = player.LV * 5;\r\n			player.MAX_HP += 5;\r\n			player.ATT += 2;\r\n			player.DEF += 2;\r\n			player.HP = player.MAX_HP;\r\n			player.EXP = 0;\r\n		}\r\n	}// 레벨업!\r\n\r\n	static void print(int now_turn) {\r\n		StringBuilder sb = new StringBuilder();\r\n		for (int i = 0; i < map.length; i++) {\r\n			for (int j = 0; j < map[0].length; j++) {\r\n				sb.append(map[i][j]);\r\n			}\r\n			sb.append(\"\\n\");\r\n		}\r\n		sb.append(\"Passed Turns : \" + now_turn + \"\\n\");\r\n		sb.append(\"LV : \" + player.LV + \"\\n\");\r\n		sb.append(\"HP : \" + player.HP + \"/\" + player.MAX_HP + \"\\n\");\r\n		sb.append(\"ATT : \" + player.ATT + \"+\" + player.W + \"\\n\");\r\n		sb.append(\"DEF : \" + player.DEF + \"+\" + player.A + \"\\n\");\r\n		sb.append(\"EXP : \" + player.EXP + \"/\" + player.MAX_EXP);\r\n		System.out.println(sb.toString());\r\n	}\r\n\r\n	static class Object_info {\r\n		// item, monster\r\n		String type;\r\n		String item_type, monster_name;\r\n		int ATT, DEF, HP, get_EXP;\r\n\r\n		// monster constructor\r\n		public Object_info(String type, String monster_name, int aTT, int dEF, int hP, int get_EXP) {\r\n			this.type = type;\r\n			this.monster_name = monster_name;\r\n			ATT = aTT;\r\n			DEF = dEF;\r\n			HP = hP;\r\n			this.get_EXP = get_EXP;\r\n		}\r\n\r\n		// item constructor\r\n		public Object_info(String type, String item_type, int aTT, int dEF) {\r\n			this.type = type;\r\n			this.item_type = item_type;\r\n			ATT = aTT;\r\n			DEF = dEF;\r\n		}\r\n	}// Object_info\r\n\r\n	static class Player {\r\n		int r, c;\r\n		int LV, HP, ATT, DEF, EXP;\r\n		int MAX_HP, W, A, MAX_EXP;\r\n		ArrayList<String> having_O = new ArrayList<>();\r\n\r\n		public Player(int r, int c, int lV, int hP, int aTT, int dEF, int eXP, int mAX_HP, int mAX_EXP) {\r\n			this.r = r;\r\n			this.c = c;\r\n			LV = lV;\r\n			HP = hP;\r\n			ATT = aTT;\r\n			DEF = dEF;\r\n			EXP = eXP;\r\n			MAX_HP = mAX_HP;\r\n			MAX_EXP = mAX_EXP;\r\n		}\r\n	}// Player\r\n}',144,16760,10425,139),
(60894714,24727,7,'2023-05-17 12:16:44','맞았습니다!! (100/100)','ac','java','import java.util.LinkedList;\r\nimport java.util.Queue;\r\nimport java.util.Scanner;\r\n\r\npublic class Main {\r\n	static StringBuilder sb;\r\n	static int[] dr = {-1, 0, 1 , 0};\r\n	static int[] dc = {0 , -1, 0, 1};\r\n\r\n	static int N; // 지도의 크기 \r\n	static int[][] map; // 지도 \r\n	static int C, E; // 컴공크기, 공과대학크기 \r\n	\r\n	static int row, col;\r\n	\r\n	public static void main(String[] args) {\r\n		Scanner sc = new Scanner(System.in);\r\n		sb = new StringBuilder();\r\n		\r\n		N = sc.nextInt();\r\n		C = sc.nextInt();\r\n		E = sc.nextInt();\r\n		\r\n		map = new int[N][N];\r\n		\r\n		// 컴공, 공대 중에서 큰 공간을 구한다. (초기 공간 분열을 한 번만 진행 후, 남은 수의 공간을 적게 세기 위해서) \r\n		if (C >= E) {\r\n			// 큰 영역을 1로 채운다. (1: 컴공)\r\n			fill(map, C, 1);\r\n			// 울타리 채우기 \r\n			wood(map, 1);\r\n			if (check( E, 2)) {\r\n				System.out.println(1);	\r\n				fill2(map, E, 2);\r\n				print(map);\r\n			} else {\r\n				System.out.println(-1);\r\n			}\r\n		} else {\r\n			// 큰 영역을 2로 채운다. (2: 공과대학) \r\n			fill(map, E, 2);\r\n			// 울타리 채우기 \r\n			wood(map, 2);\r\n			if (check(C, 1)) {\r\n				System.out.println(1);\r\n				fill2(map, C, 1);\r\n				print(map);\r\n			} else {\r\n				System.out.println(-1);\r\n			}\r\n		}\r\n		\r\n		\r\n	}\r\n\r\n	private static void fill2(int[][] map, int min, int type) {\r\n		// BFS 로 채우기. (최선으로 채우는 방법) \r\n			Queue<int[]> queue = new LinkedList<>();\r\n			queue.add(new int[] {N-1, N-1});\r\n			map[N-1][N-1] = type;\r\n			int cnt = 1;\r\n			while (!queue.isEmpty()) {\r\n				int[] cur = queue.poll();\r\n					\r\n				for (int i=0; i<2; i++) {\r\n					if (cnt >= min) return;\r\n					int nr = cur[0] + dr[i];\r\n					int nc = cur[1] + dc[i];\r\n					\r\n					if (nr<0 || nr>=N || nc<0 || nc>=N) continue;\r\n						\r\n					if (map[nr][nc] != 0) continue;\r\n						\r\n					map[nr][nc] = type;\r\n					queue.add(new int[] {nr, nc});\r\n					cnt++;\r\n					\r\n						\r\n				}\r\n					\r\n			}\r\n	}\r\n\r\n	// 0 의 개수가 세울 수 있는 작은 건물의 영역만큼 넉넉한지 체크하는 함수 \r\n	private static boolean check(int min, int antiType) {\r\n		int cnt = 0;\r\n		for (int i=0; i<N; i++) {\r\n			for (int j=0; j<N; j++) {\r\n				if (map[i][j] == 0) {\r\n					cnt++; \r\n					if (cnt >= min) {\r\n						return true;\r\n					}\r\n				}\r\n			}\r\n		}\r\n		\r\n		return false;\r\n		\r\n	}\r\n\r\n	// 현재 채워진 건물 중심으로 울타리를 채운다. \r\n	private static void wood(int[][] map, int type) {\r\n		for (int i=0; i<N; i++) {\r\n			for (int j=0; j< N; j++) {\r\n				if (map[i][j] == type) { // 현재위치가 건물일 때 \r\n					//visited[i][j] = true;\r\n					// 주변에 울타리 설치가 가능한지 체크 \r\n					for (int d=2; d<4; d++) {\r\n						int nr = i + dr[d];\r\n						int nc = j + dc[d];\r\n						\r\n						if (nr<0 || nr>=N || nc<0 || nc>=N) continue; // 유효성 체크 \r\n						\r\n						if (map[nr][nc] == type || map[nr][nc] == 9) continue;\r\n						\r\n						// 울타리 설치 가능  (울타리 : 9) \r\n						map[nr][nc] = 9;\r\n\r\n					}\r\n					\r\n				}\r\n			}\r\n		}\r\n		\r\n	}\r\n\r\n	// type의 값으로 2중포문을 돌며 채운다. \r\n	private static void fill(int[][] map, int max, int type) {\r\n		\r\n//		// max개의 개수만큼만 채우기 위해서 cnt 변수를 통해 제어합니다. \r\n//		int cnt = 1;\r\n//		// 2중 반복문을 돌며 타입의 값으로 건물의 영역을 채웁니다. (최선으로 채우는 방법) (그리디) \r\n//		for (int i=0; i<N; i++) {\r\n//			for (int j=0; j<N; j++) {\r\n//				row = i;\r\n//				col = j;\r\n//				if (cnt++ > max) break;\r\n//				map[i][j] = type;\r\n//			}\r\n//		}\r\n		\r\n		\r\n		// BFS 로 채우기. (최선으로 채우는 방법) \r\n		Queue<int[]> queue = new LinkedList<>();\r\n		queue.add(new int[] {0, 0});\r\n		map[0][0] = type;\r\n		int cnt = 1;\r\n		while (!queue.isEmpty()) {\r\n			int[] cur = queue.poll();\r\n			\r\n			for (int i=2; i<4; i++) {\r\n				if (cnt >= max) return;\r\n				int nr = cur[0] + dr[i];\r\n				int nc = cur[1] + dc[i];\r\n				\r\n				if (nr<0 || nr>=N || nc<0 || nc>=N) continue;\r\n				\r\n				if (map[nr][nc] != 0) continue;\r\n				\r\n				map[nr][nc] = type;\r\n				queue.add(new int[] {nr, nc});\r\n				cnt++;\r\n				\r\n				\r\n			}\r\n			\r\n		}\r\n		\r\n		\r\n		\r\n	}\r\n	\r\n	// 2차원 배열을 출력하는 함수 \r\n	private static void print(int[][] map) {\r\n		\r\n		for (int i=0; i<N; i++) {\r\n			for (int j=0; j<N; j++) {\r\n				if (map[i][j] == 9) {\r\n					sb.append(0);\r\n				} else {\r\n					sb.append(map[i][j]);\r\n				}\r\n			}\r\n			sb.append(\"\\n\");\r\n		}\r\n		\r\n		System.out.print(sb.toString());\r\n	}\r\n\r\n}',220,18296,4290,127),
(60895315,1000,6,'2023-05-17 12:29:25','맞았습니다!!','ac','cpp','#include <iostream>\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    int num1, num2;\r\n    cin >> num1 >> num2;\r\n    cout << num1+num2 << endl;\r\n    return 0;\r\n}',0,2020,146,128),
(60896293,1012,1,'2023-05-17 12:56:18','맞았습니다!!','ac','java','import java.io.BufferedReader;\r\nimport java.io.FileInputStream;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.LinkedList;\r\nimport java.util.Queue;\r\nimport java.util.StringTokenizer;\r\n\r\npublic class Main {\r\n\r\n	\r\n	public static int bfs(int[][] board, int n, int m) {\r\n	\r\n		\r\n		int result = 0;\r\n		int[][] visited = new int[n][m];\r\n		int[][] dir = {{0, 1} ,{1, 0}, {0, -1}, {-1, 0} };\r\n		\r\n		\r\n		for(int i=0;i<n;i++) {\r\n			for(int j=0;j<m;j++) {\r\n				\r\n				if (visited[i][j] == 0 && board[i][j] == 1) {\r\n					\r\n					result++;\r\n					\r\n					Queue<int[]> q = new LinkedList<int[]>();\r\n					q.add(new int[] {i, j});\r\n					visited[i][j] = 1;\r\n					\r\n					while(!q.isEmpty()) {\r\n						\r\n						int[] temp = q.poll();\r\n						int x = temp[0], y = temp[1];\r\n						\r\n						for(int[] d : dir) {\r\n							\r\n							int nx = x + d[0];\r\n							int ny = y + d[1];\r\n							\r\n							if (0 <= nx && nx < n && 0 <= ny && ny < m) {\r\n								if (visited[nx][ny] == 0 && board[nx][ny] == 1) {\r\n									q.add(new int[] {nx, ny});\r\n									visited[nx][ny] = 1;\r\n								} \r\n							}\r\n							\r\n						}\r\n						\r\n						\r\n					}\r\n					\r\n					\r\n				}\r\n				\r\n			}\r\n		}\r\n		\r\n		\r\n		\r\n		\r\n		\r\n		return result;\r\n	}\r\n	\r\n	public static int result;\r\n	public static StringBuilder answer;\r\n	public static void main(String[] args) throws IOException {\r\n		//System.setIn(new FileInputStream(\"input/1012.txt\"));\r\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n		StringTokenizer st;\r\n		\r\n		int testCnt = Integer.parseInt(br.readLine());\r\n		\r\n		for(int t=1;t<=testCnt;t++) {\r\n			st = new StringTokenizer(br.readLine());\r\n			\r\n			int n = Integer.parseInt(st.nextToken());\r\n			int m = Integer.parseInt(st.nextToken());\r\n			int k = Integer.parseInt(st.nextToken());\r\n			\r\n			int[][] board = new int[n][m];\r\n			\r\n			for(int i=0;i<k;i++) {\r\n				st = new StringTokenizer(br.readLine());\r\n				int x = Integer.parseInt(st.nextToken());\r\n				int y = Integer.parseInt(st.nextToken());\r\n				\r\n				board[x][y] = 1;\r\n			}\r\n			System.out.println(bfs(board, n, m));\r\n			\r\n		}\r\n\r\n	}\r\n\r\n}\r\n',172,16008,1993,129),
(60896584,1000,7,'2023-05-17 13:04:23','맞았습니다!!','ac','java','import java.util.Scanner;\r\n\r\nclass Main{\r\n    public static void main(String args []) {\r\n        Scanner sc = new Scanner(System.in);\r\n        \r\n        int sumValueA, sumValueB;\r\n        sumValueA = sc.nextInt();\r\n        sumValueB = sc.nextInt();\r\n        \r\n        System.out.println(sumValueA+sumValueB);\r\n    }\r\n}   ',216,17756,309,130),
(60898163,1001,6,'2023-05-17 13:41:55','맞았습니다!!','ac','cpp','#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nint main(){\r\nint num1, num2;\r\n    cin >> num1 >> num2;\r\n    cout << num1 - num2 << endl;\r\n    return 0;\r\n}',0,2020,144,131),
(60901305,1003,6,'2023-05-17 14:32:48','맞았습니다!!','ac','cpp','#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nint result[51] = { 0, };\r\n\r\nstruct Node \r\n{\r\n	int z, o;\r\n};\r\n\r\nNode st[51] = { 0, };\r\n\r\nint fibonacci(int now)\r\n{\r\n	if (now == 1 || now == 0)\r\n	{\r\n		st[1].o = 1;\r\n		st[0].z = 1;\r\n		return result[now] = now;\r\n	}\r\n\r\n	if (result[now])\r\n	{\r\n		st[now].o = st[now - 1].o + st[now - 2].o;\r\n		st[now].z = st[now - 1].z + st[now - 2].z;\r\n		return result[now];\r\n	}\r\n\r\n	result[now] = fibonacci(now - 1) + fibonacci(now - 2);\r\n	st[now].o = st[now - 1].o + st[now - 2].o;\r\n	st[now].z = st[now - 1].z + st[now - 2].z;\r\n\r\n	return result[now];\r\n}\r\n\r\nint in[101] = { 0, };\r\n\r\nint main() {\r\n	int T;\r\n	cin >> T;\r\n	for (int i = 0; i < T; i++)\r\n	{\r\n		int num;\r\n		cin >> num;\r\n		in[i] = num;\r\n		fibonacci(num);\r\n		int de = 1;\r\n	}\r\n	for (int i = 0; i < T; i++)\r\n	{\r\n		cout << st[in[i]].z << \" \" << st[in[i]].o << endl;\r\n	}\r\n	return 0;\r\n}',4,2020,807,135),
(60901486,1002,6,'2023-05-17 14:35:10','맞았습니다!!','ac','cpp','#include <iostream>\r\n\r\nusing namespace std;\r\nstruct Node\r\n{\r\n	int y, x, r;\r\n};\r\nNode arr[1001] = { 0, };\r\nNode arr2[1001] = { 0, };\r\nint result[1001] = { 0, };\r\nint main()\r\n{\r\n	int T;\r\n	cin >> T;\r\n	for (int i = 0; i < T; i++)\r\n	{\r\n		cin >> arr[i].y >> arr[i].x >> arr[i].r;\r\n		cin >> arr2[i].y >> arr2[i].x >> arr2[i].r;\r\n	}\r\n	for (int i = 0; i < T; i++)\r\n	{\r\n		int val = (arr[i].y - arr2[i].y)*(arr[i].y - arr2[i].y) + (arr[i].x - arr2[i].x)* (arr[i].x - arr2[i].x);\r\n		if (arr[i].y == arr2[i].y && arr[i].x == arr2[i].x && arr[i].r == arr2[i].r)\r\n		{\r\n			result[i] = -1;\r\n			continue;\r\n		}\r\n		else if (arr[i].y == arr2[i].y && arr[i].x == arr2[i].x && arr[i].r != arr2[i].r)\r\n		{\r\n			result[i] = 0;\r\n			continue;\r\n		}\r\n		else if ((max(arr[i].r, arr2[i].r) - min(arr[i].r, arr2[i].r))* (max(arr[i].r, arr2[i].r) - min(arr[i].r, arr2[i].r)) == val)\r\n		{\r\n			result[i] = 1;\r\n			continue;\r\n		}\r\n		else if ((max(arr[i].r, arr2[i].r) - min(arr[i].r, arr2[i].r))* (max(arr[i].r, arr2[i].r) - min(arr[i].r, arr2[i].r)) > val )\r\n		{\r\n			result[i] = 0;\r\n			continue;\r\n		}\r\n		else if ((arr[i].r + arr2[i].r)* (arr[i].r + arr2[i].r) > val)\r\n		{\r\n			result[i] = 2;\r\n			continue;\r\n		}\r\n		else if ((arr[i].r + arr2[i].r)* (arr[i].r + arr2[i].r) == val)\r\n		{\r\n			result[i] = 1;\r\n			continue;\r\n		}\r\n\r\n	}\r\n	for (int i = 0; i < T; i++)\r\n	{\r\n		cout << result[i] << endl;\r\n	}\r\n	return 0;\r\n}\r\n',8,2048,1313,136),
(60912612,1806,3,'2023-05-17 17:30:02','맞았습니다!!','ac','cpp','#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\nlong long	arr[100001];\r\nint			n, m;\r\n\r\nint		main(void)\r\n{\r\n	int		i, j;\r\n	int		ans;\r\n	\r\n	scanf(\"%d %d\", &n, &m);	\r\n	ans = n + 1;\r\n	i = 1;\r\n	while (i <= n)\r\n	{\r\n		scanf(\"%d\", &arr[i]);\r\n		arr[i] += arr[i - 1];\r\n		i++;\r\n	}\r\n	i = 0;\r\n	j = 1;\r\n	while (j <= n)\r\n	{\r\n		if (arr[j] - arr[i] < m)\r\n			j++;     \r\n		else if (arr[j] - arr[i] >= m)\r\n		{\r\n			ans = min(j - i, ans);\r\n			i++;\r\n		}\r\n	}\r\n	if (ans == n + 1)\r\n		printf(\"0\\n\");\r\n	else\r\n		printf(\"%d\\n\", ans);\r\n	return (0);\r\n}',16,2800,484,144),
(60912962,1000,7,'2023-05-17 17:35:50','맞았습니다!!','ac','java','import java.util.Scanner;\r\n\r\nclass Main{\r\n    public static void main(String args []) {\r\n        Scanner sc = new Scanner(System.in);\r\n        \r\n        int sumValueA, sumValueB;\r\n        sumValueA = sc.nextInt();\r\n        sumValueB = sc.nextInt();\r\n        \r\n        System.out.println(sumValueA+sumValueB);\r\n    }\r\n}   ',212,17752,309,130),
(60919420,1157,7,'2023-05-17 20:03:16','맞았습니다!!','ac','python','import sys\r\ninput = sys.stdin.readline\r\n\r\ns = input()\r\nS = s.upper()\r\n\r\n\r\nal = \'ABCDEFGHIJKLMNOPQRSTUVWXYZ\'\r\nvisited = [0] * 26\r\nfor i in range(len(S)-1):\r\n    idx = al.find(S[i])\r\n\r\n    if visited[idx]==0:\r\n        visited[idx] = 1\r\n    else:\r\n        visited[idx] = visited[idx]+1\r\n\r\n\r\nm1 = max(visited)\r\nm1_idx = visited.index(max(visited))\r\n\r\nvisited[m1_idx]=0\r\nm2 = max(visited)\r\n\r\n\r\na = []\r\na.append(m1)\r\na.append(m2)\r\n\r\nif a[0]==a[1]:\r\n    print(\'?\')\r\nelse:\r\n    print(al[m1_idx])',400,33212,455,147),
(60924215,10950,7,'2023-05-17 21:43:17','맞았습니다!!','ac','java','import java.util.*;\r\n\r\nclass Main {\r\n  public static void main(String[] args) {\r\n    Scanner sc = new Scanner(System.in);\r\n    int N = sc.nextInt();\r\n    for (int i=0; i<N; i++) {\r\n      int a = sc.nextInt();\r\n      int b = sc.nextInt();\r\n      System.out.println(a + b); \r\n    }\r\n  }\r\n}',224,17748,275,149),
(60924749,17485,4,'2023-05-17 21:54:19','맞았습니다!!','ac','java','import java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.Arrays;\r\nimport java.util.StringTokenizer;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws IOException {\r\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n        StringTokenizer st = new StringTokenizer(br.readLine());\r\n\r\n        int n = Integer.parseInt(st.nextToken());\r\n        int m = Integer.parseInt(st.nextToken());\r\n\r\n        int[][] arr = new int[n][m];\r\n        int[][][] dp = new int[n][m][3];\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            st = new StringTokenizer(br.readLine());\r\n            for (int j = 0; j < m; j++) {\r\n                arr[i][j] = Integer.parseInt(st.nextToken());\r\n            }\r\n        }\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            for (int j = 0; j < m; j++) {\r\n                Arrays.fill(dp[i][j], 1000001);\r\n            }\r\n        }\r\n        \r\n        for (int i = 0; i < m; i++) {\r\n            for (int j = 0; j < 3; j++) {\r\n                dp[0][i][j] = arr[0][i];\r\n            }\r\n        }\r\n\r\n        for (int i = 1; i < n; i++) {\r\n            for (int j = 0; j < m; j++) {\r\n                if (j == 0) {\r\n                    dp[i][j][0] = Math.min(dp[i - 1][j + 1][1], dp[i - 1][j + 1][2]) + arr[i][j];\r\n                    dp[i][j][1] = dp[i - 1][j][0] + arr[i][j];\r\n                } else if (j == m - 1) {\r\n                    dp[i][j][1] = dp[i - 1][j][2] + arr[i][j];\r\n                    dp[i][j][2] = Math.min(dp[i - 1][j - 1][1], dp[i - 1][j - 1][0]) + arr[i][j];\r\n                } else {\r\n                    dp[i][j][0] = Math.min(dp[i - 1][j + 1][1], dp[i - 1][j + 1][2]) + arr[i][j];\r\n                    dp[i][j][1] = Math.min(dp[i - 1][j][0], dp[i - 1][j][2]) + arr[i][j];\r\n                    dp[i][j][2] = Math.min(dp[i - 1][j - 1][0], dp[i - 1][j - 1][1]) + arr[i][j];\r\n                }\r\n            }\r\n        }\r\n\r\n        int result = Integer.MAX_VALUE;\r\n        for (int i = 0; i < m; i++) {\r\n            for (int j = 0; j < 3; j++) {\r\n                result = Math.min(result, dp[n - 1][i][j]);\r\n            }\r\n        }\r\n        System.out.println(result);\r\n    }\r\n}\r\n',696,112368,2167,150),
(60925343,10950,7,'2023-05-17 22:05:41','맞았습니다!!','ac','java','import java.util.*;\r\n\r\nclass Main {\r\n  public static void main(String[] args) {\r\n    Scanner sc = new Scanner(System.in);\r\n    int N = sc.nextInt();\r\n    for (int i=0; i<N; i++) {\r\n      int a = sc.nextInt();\r\n      int b = sc.nextInt();\r\n      System.out.println(a + b); \r\n    }\r\n  }\r\n}',224,17972,275,149),
(60925423,1520,12,'2023-05-17 22:07:18','맞았습니다!!','ac','java','import java.io.*;\r\nimport java.util.*;\r\n\r\npublic class Main {\r\n	static int M, N, ny, nx;\r\n	static int[][] map;\r\n	static int[][] dp;\r\n	static boolean[][] visited;\r\n	static int[] dx = {-1, 1, 0, 0};\r\n	static int[] dy = {0, 0, -1, 1};\r\n\r\n	public static void main(String[] args) throws Exception {\r\n		// TODO Auto-generated method stub\r\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n		BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\r\n		StringTokenizer st = new StringTokenizer(br.readLine());\r\n		\r\n		M = Integer.parseInt(st.nextToken());\r\n		N = Integer.parseInt(st.nextToken());\r\n		\r\n		map = new int[M][N];\r\n		dp = new int[M][N];\r\n		visited = new boolean[M][N];\r\n\r\n		for(int i = 0; i < M; i++) {\r\n			st = new StringTokenizer(br.readLine());\r\n			for(int j = 0; j < N; j++) {\r\n				map[i][j] = Integer.parseInt(st.nextToken());\r\n				dp[i][j] = -1;\r\n			}\r\n		}\r\n		\r\n		bw.write(String.valueOf(DFS(0, 0)) + \"\\n\");\r\n		bw.flush();\r\n		br.close();\r\n		bw.close();\r\n		\r\n	}\r\n	\r\n	static int DFS(int y, int x) {\r\n		if(dp[y][x] != -1) {\r\n			return dp[y][x];\r\n		}\r\n		if(y == M - 1 && x == N - 1) {\r\n			return 1;\r\n		}\r\n		\r\n		dp[y][x] = 0;\r\n\r\n		for(int i = 0; i < 4; i++) {\r\n			ny = y + dy[i];\r\n			nx = x + dx[i];\r\n			\r\n			if(ny >= 0 && ny < M && nx >= 0 && nx < N) {\r\n				if(map[y][x] > map[ny][nx]) {\r\n					dp[y][x] += DFS(ny, nx);\r\n				}\r\n			}\r\n		}\r\n		return dp[y][x];\r\n	}\r\n}\r\n',304,37640,1353,151),
(60926350,10950,7,'2023-05-17 22:26:54','맞았습니다!!','ac','java','import java.util.*;\r\n\r\nclass Main {\r\n  public static void main(String[] args) {\r\n    Scanner sc = new Scanner(System.in);\r\n    int N = sc.nextInt();\r\n    for (int i=0; i<N; i++) {\r\n      int a = sc.nextInt();\r\n      int b = sc.nextInt();\r\n      System.out.println(a + b); \r\n    }\r\n  }\r\n}',228,17960,275,149),
(60932851,10950,7,'2023-05-18 00:33:34','맞았습니다!!','ac','java','import java.util.*;\r\n\r\nclass Main {\r\n  public static void main(String[] args) {\r\n    Scanner sc = new Scanner(System.in);\r\n    int N = sc.nextInt();\r\n    for (int i=0; i<N; i++) {\r\n      int a = sc.nextInt();\r\n      int b = sc.nextInt();\r\n      System.out.println(a + b); \r\n    }\r\n  }\r\n}',324,17908,275,149),
(60935478,21610,6,'2023-05-18 02:30:09','맞았습니다!!','ac','cpp','#include <iostream>\r\n#include <queue>\r\nusing namespace std;\r\n\r\nstruct Node\r\n{\r\n	int dir, dis;\r\n};\r\nstruct coord\r\n{\r\n	int y, x;\r\n};\r\nqueue <coord> cloud_pos;\r\nqueue <coord> cloud_npos;\r\n\r\nint N, M;\r\nint map[51][51] = { 0, };\r\nint post_cloud[51][51] = { 0, };\r\n//구름 이동 \r\nint dr_cloud[9] = {0,0,-1,-1,-1,0,1,1,1};\r\nint dc_cloud[9] = {0,-1,-1,0,1,1,1,0,-1};\r\n\r\n//복사 방향\r\nint dr_copy[4] = { -1,-1,1,1 };\r\nint dc_copy[4] = { -1,1,-1,1 };\r\n\r\nvoid cloud_move(int ord, int dis)\r\n{\r\n	while (!cloud_pos.empty())\r\n	{\r\n		coord A = cloud_pos.front();\r\n		cloud_pos.pop();\r\n		int ny = A.y+dr_cloud[ord] * dis;\r\n		int nx = A.x+dc_cloud[ord] * dis;\r\n		if (ny < 0) ny += N * 100;\r\n		if (nx < 0) nx += N * 100;\r\n		if (ny > N) ny = ny %N;\r\n		if (nx > N) nx = nx %N;\r\n		if (ny == 0) ny = N;\r\n		if (nx == 0) nx = N;\r\n		cloud_npos.push({ ny,nx });\r\n		map[ny][nx]++;\r\n		post_cloud[ny][nx]++;\r\n	}\r\n}\r\n\r\nvoid hydro_copy()\r\n{\r\n	while (!cloud_npos.empty())\r\n	{\r\n		coord A = cloud_npos.front();\r\n		cloud_npos.pop();\r\n		int n = 0;\r\n		for (int i = 0; i < 4; i++)\r\n		{\r\n			int ny = A.y + dr_copy[i];\r\n			int nx = A.x + dc_copy[i];\r\n			if (ny <= 0 || nx <= 0 || ny > N || nx > N) continue;\r\n			if (map[ny][nx] <1) continue;\r\n			n++;\r\n		}\r\n		map[A.y][A.x] += n;\r\n	}\r\n}\r\n\r\nvoid cloud_enchant()\r\n{\r\n	for (int i = 1; i <= N; i++)\r\n	{\r\n		for (int j = 1; j <= N; j++)\r\n		{\r\n			if (post_cloud[i][j] == 1)\r\n			{\r\n				post_cloud[i][j] = 0;\r\n				continue;\r\n			}\r\n			if (map[i][j] >= 2)\r\n			{\r\n				map[i][j] -= 2;\r\n				cloud_pos.push({ i,j });\r\n			}\r\n		}\r\n	}\r\n}\r\n\r\nint main()\r\n{\r\n\r\n	cin >> N >> M;\r\n	for (int i = 1; i <= N; i++)\r\n	{\r\n		for (int j = 1; j <= N; j++)\r\n		{\r\n			cin >> map[i][j];\r\n		}\r\n	}\r\n	Node info_cloud[101] = { 0, };\r\n	for (int i = 0; i < M; i++)\r\n	{\r\n		cin >> info_cloud[i].dir >> info_cloud[i].dis;\r\n	}\r\n\r\n	//비바라기 시전\r\n	cloud_pos.push({ N,1 });\r\n	cloud_pos.push({ N,2 });\r\n	cloud_pos.push({ N-1,1 });\r\n	cloud_pos.push({ N-1,2 });\r\n\r\n	for (int i = 0; i < M; i++)\r\n	{\r\n		// 구름의 이동, 1 증가, 사라진다\r\n		cloud_move(info_cloud[i].dir, info_cloud[i].dis);\r\n		// 복사 마법\r\n		hydro_copy();\r\n		// 구름 생성\r\n		cloud_enchant();\r\n		/*\r\n		for (int i = 1; i <= N; i++)\r\n		{\r\n			for (int j = 1; j <= N; j++)\r\n			{\r\n				cout << map[i][j] << \" \";\r\n			}\r\n			cout << endl;\r\n		}\r\n		*/\r\n	}\r\n	int result = 0;\r\n	for (int i = 1; i <= N; i++)\r\n	{\r\n		for (int j = 1; j <= N; j++)\r\n		{\r\n			result += map[i][j];\r\n		}\r\n	}\r\n\r\n	cout << result;\r\n	return 0;\r\n\r\n}',8,2044,2316,157),
(60938752,5052,4,'2023-05-18 09:22:23','맞았습니다!!','ac','java','import java.io.BufferedReader;\r\nimport java.io.InputStreamReader;\r\nimport java.util.HashSet;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n        int tc = Integer.parseInt(br.readLine());\r\n        here:\r\n        while (tc-- > 0) {\r\n            int n = Integer.parseInt(br.readLine());\r\n            HashSet<String> set = new HashSet<>();\r\n            String[] arr = new String[n];\r\n            for (int i = 0; i < n; i++) {\r\n                arr[i] = br.readLine();\r\n                set.add(arr[i]);\r\n            }\r\n            for (int i = 0; i < n; i++) {\r\n                String s = \"\";\r\n                for (int j = 0; j < arr[i].length() - 1; j++) {\r\n                    s += arr[i].charAt(j);\r\n                    if (set.contains(s)) {\r\n                        System.out.println(\"NO\");\r\n                        continue here;\r\n                    }\r\n                }\r\n            }\r\n            System.out.println(\"YES\");\r\n        }//\r\n    }\r\n}\r\n',680,101112,1047,164),
(60940802,7569,7,'2023-05-18 10:19:18','맞았습니다!!','ac','java','import java.io.BufferedReader;\r\nimport java.io.InputStreamReader;\r\nimport java.util.LinkedList;\r\nimport java.util.Queue;\r\nimport java.util.StringTokenizer;\r\n\r\npublic class Main {\r\n	\r\n	// 4방향 \r\n	static int[] dr = {-1, 1, 0, 0};\r\n	static int[] dc = {0, 0, -1, 1};\r\n	static int[] dh = {-1, 1};\r\n\r\n	// 3차원 배열로 관리\r\n	static int[][][] map;\r\n	\r\n	// 3차원 방문 배열 \r\n	static boolean[][][] visited;\r\n	\r\n	static Queue<int[]> queue;\r\n	\r\n	// 열, 행, 높이  \r\n	static int C, R, H;\r\n	\r\n	public static void main(String[] args) throws Exception {\r\n		BufferedReader  br = new BufferedReader(new InputStreamReader(System.in));\r\n		StringTokenizer st = null;\r\n		\r\n		st = new StringTokenizer(br.readLine(), \" \");\r\n		C  = Integer.parseInt(st.nextToken());\r\n		R  = Integer.parseInt(st.nextToken());\r\n		H  = Integer.parseInt(st.nextToken());\r\n		\r\n		map = new int[R][C][H]; // 토마토를 보관하는 3차원 행열 생성 \r\n		visited = new boolean[R][C][H];\r\n		\r\n		queue = new LinkedList<>();\r\n		\r\n		for (int h=0; h<H; h++) {			\r\n			for (int r=0; r<R; r++) {\r\n				st = new StringTokenizer(br.readLine(), \" \");\r\n				for (int c=0; c<C; c++) {\r\n					map[r][c][h] = Integer.parseInt(st.nextToken());\r\n					if (map[r][c][h] == 1) queue.add(new int[] {r, c, h});\r\n				}\r\n			}\r\n		}\r\n		\r\n		\r\n		// 배열을 순회하며, 익은 토마토 and 방문한적이 없다면 BFS를 수행 \r\n		bfs();\r\n		\r\n		\r\n		System.out.println( Math.max(check() - 1, -1));\r\n			\r\n		\r\n		\r\n	}\r\n	\r\n	// 익지 않은 토마토가 존재하면  false \r\n	private static int check() {\r\n		\r\n		int result = -1;\r\n		\r\n		for (int h=0; h<H; h++) {\r\n			for (int r=0; r<R; r++) {\r\n				for (int c=0; c<C; c++) {\r\n					if(map[r][c][h] == 0) return -1;\r\n					\r\n					result = Math.max(result, map[r][c][h]);\r\n					\r\n				}\r\n			}\r\n		}\r\n		\r\n		return result;\r\n	}\r\n\r\n	private static void bfs() {\r\n\r\n		while (!queue.isEmpty())\r\n		{\r\n			\r\n			// 행, 열, 높이 \r\n			int[] cur = queue.poll();\r\n			\r\n			for (int d=0; d<4; d++) {\r\n				int nr = cur[0] + dr[d];\r\n				int nc = cur[1] + dc[d];\r\n				\r\n				// 유효성 검사 \r\n				if (nr<0 || nr>=R || nc<0 || nc>=C || visited[nr][nc][cur[2]] || map[nr][nc][cur[2]] == -1) continue;\r\n				\r\n				if (map[nr][nc][cur[2]] == 0) {					\r\n					queue.add(new int[] {nr, nc, cur[2]});\r\n					visited[nr][nc][cur[2]] = true;\r\n					map[nr][nc][cur[2]] = map[cur[0]][cur[1]][cur[2]]+1;\r\n				}\r\n			} // 행 열 \r\n			\r\n			for (int d=0; d<2; d++) {\r\n				int nh = cur[2] + dh[d];\r\n				\r\n				if (nh<0 || nh>= H || visited[cur[0]][cur[1]][nh] || map[cur[0]][cur[1]][nh] == -1) continue;\r\n				\r\n				if (map[cur[0]][cur[1]][nh] == 0) {					\r\n					queue.add(new int[] {cur[0], cur[1], nh});\r\n					visited[cur[0]][cur[1]][nh] = true;\r\n					map[cur[0]][cur[1]][nh] = map[cur[0]][cur[1]][cur[2]]+1;\r\n				}\r\n			} // 높이 \r\n			\r\n			\r\n			\r\n		} // while\r\n						\r\n		\r\n	}\r\n\r\n	private static void print(int[][][] map) {\r\n		for (int h=0; h<H; h++) {\r\n			for (int r=0; r<R; r++) {\r\n				for (int c=0; c<C; c++) {\r\n					System.out.print(map[r][c][h] + \" \");\r\n				}\r\n				System.out.println();\r\n			}\r\n		}\r\n	}\r\n\r\n}\r\n',780,132072,2941,167);
/*!40000 ALTER TABLE `user_submit_solution` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2023-05-18  1:52:43
